---
title: "Analysis of CAPE in using individual transcripts in pancreatic islets"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---


The purpose of this workflow is to analyze the results from 
cape_run_transcripts.Rmd

```{r setup}
plot.mod.net = FALSE
exp.name <- "top_three_PC"
geno.type = "modules"
exp.dir <- paste(geno.type, exp.name, sep = "_")
```

```{r load_code}
library("here")
all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("cape", "gprofiler2", "pheatmap", "cluster", "easyPubMed",
"wordcloud", "wordcloud2", "tm", "stringr", "biomaRt", "GOSim", "org.Mm.eg.db",
"qtl2", "gProfileR", "cape")
load_libraries(all.packages)
```

The following heat map shows the results from the cape run for 
the 42 WGCNA modules.

Most interactions are negative, but a few modules have multiple positive 
interactions.

```{r load_results, fig_height = 5, fig.width = 5}
gene.info <- as.matrix(read.table(here("Data", "mouse_gene_info.txt"), sep = "\t", 
header = TRUE, stringsAsFactors = FALSE))

cross <- readRDS(here("Results", exp.dir, "cross.RData"))
var.inf <- plot_variant_influences(cross, covar_width = 1, pheno_width = 1)
#take out the allele names
rownames(var.inf) <- gsub("_B", "", rownames(var.inf))
colnames(var.inf) <- gsub("_B", "", colnames(var.inf))
```

The following boxplot shows the influences of each transcript ordered
by the mean of all its influences. The majority of transcripts have 
negative effects on other transcripts. A few have positive effects.

```{r just_int, fig.width = 10, fig.height = 4}
just.int <- var.inf[,1:nrow(var.inf)]
mean.out <- apply(just.int, 1, function(x) mean(x, na.rm = TRUE))
mean.out.order <- order(mean.out)
boxplot(t(just.int[mean.out.order,]), las = 2, main = "Interactions Going Out");abline(h = 0)

mean.in <- apply(just.int, 2, function(x) mean(x, na.rm = TRUE))
mean.in.order <- order(mean.in)
boxplot(just.int[,mean.in.order], las = 2, main = "Interactions Coming In");abline(h = 0)
```

## Main Effects
We used the first three eigentraits of the full trait matrix as our traits.
The SVD plot is below. It shows only the traits that we used in this analysis.

```{r svdplot, fig.height = 7.5, fig.width = 5}
#quartz(width = 5, height = 7.5)
plot_svd(cross, just_selected_et = TRUE)
```

The first ET represents the concordance among all the traits, and is dominated
by insulin levels and HOMA_IR. The second trait contrasts the pancreatic 
measurements, like WPIC, number of islets, and the HOMA traits with the
rest of the traits. The third ET represents the contrast between in-vivo 
insulin measurements and the rest of the traits. 

The following heatmap shows the main effects for all transcripts included here.
Most transcripts have main effects on all three eigentraits. 

```{r main_effects, fig.width = 4, fig.height = 10}
#quartz(width = 4, height = 8)
just.main <- var.inf[,(nrow(var.inf)+1):ncol(var.inf)]
just.main[which(is.na(just.main))] <- 0
pheatmap(just.main)
```

## Module Enrichment  {.tabset .tabset-fade .tabset-pills}

The following plots show enrichments for each WGCNA module.
The enrichments are discouragingly redundant. Lots of RNA processing,
lots of organelle enrichments. 

Very short summaries of the module enrichments are as follows:

**MEdarkgreen** organelles
**MEgrey** ion transport
**MEgreenyellow** synapse, neuron development/differentiation
**MEbrown** ER, mitochondrion, organelles
**MEdarkolivegreen** signal transduction and regulation of metabolic process
**MEdarkturquoise** nucleus, organelle
**MElighcyan** RNA processing
**MEyellow** ER
**MEpaleturquoise** neuron
**MEwhite** organelles
**MEpurple** nuclus, organelles
**MEmidnightblue** protein, enzyme, and GTPase binding
**MEblack** nuclear, organelles
**MEgreen** lots of metabolism stuff
**MEturquoise** nuclear, organelles
**MEtan** organelles
**MEorangered4** inflammatory response (2 genes)
**MEmagenta** immune response
**MEroyalblue** cell signaling, metabolism
**MEorange** microtubule, cilium stuff
**MEblue** mitochondrion
**MEred** cytoskeleton
**MEcyan** ECM
**MEsalmon** ribosome
**MEdarkred** nucleus, organelles
**MEdarkgrey** extracellular
**MEdarkorange** imune processes
**MEGrey60** chromatin binding, insuling secretion
**MElightyellow** development, angiogenesis
**MEpink** nucleus, organelles
**MEsaddlebrown** nucleus, organelles
**MEskyblue3** immune, inflammatory
**MEdarkmagenta** ER, Golgi
**MEviolet** cell cycle
**MEsteelblue** kinase activity, ion transport
**MElighgreen** cell metabolism
**MEyellowgreen** synapse, ion transport
**MEskyblue** cell metabolism
**MEsienna3** ribosome, mitochondrion, cellular respiration
**MEplum1** none
**MEsteelblue1** nucleic acid binding
**MEmediumpurple3** none


```{r get_mod_enrich}
all.var <- ls()
  data.loaded <- as.logical(length(which(all.var == "dataset.clinical.phenotypes")))
  if(!data.loaded){
    islets <- load(here("data", "Attie_DO378_eQTL_viewer_v6.Rdata"))
    }
  transcript.info <- dataset.islet.rnaseq$annots
  u_modules <- unique(transcript.info[,"module"])
  module_transcripts <- lapply(u_modules, function(x) transcript.info[which(transcript.info[,"module"] == x),"symbol"])
  names(module_transcripts) <- u_modules
  module.enrich.file <- here("Results", exp.dir, "Module.Enrichment.RDS")
  if(!file.exists(module.enrich.file)){
    module.enrich <- lapply(module_transcripts, function(x) gost(x, "mmusculus", sources = "GO"))
    names(module.enrich) <- paste0("ME", u_modules)
    saveRDS(module.enrich, module.enrich.file)
  }else{
    module.enrich <- readRDS(module.enrich.file)
  }
```

```{r go_sum}
summ_go <- function(enrichment.table, n.terms = 10){
  if(is.null(enrichment.table)){
    return("none")
  }else{
    if(class(enrichment.table) == "list"){
      enrichment.table <- enrichment.table[[1]]
    }
    terms <- enrichment.table[order(-log10(as.numeric(enrichment.table[,"p_value"])), decreasing = TRUE),"term_name"]
    split.terms <- strsplit(terms, " ")
    summ_term <- paste(unique(unlist(split.terms[1:n.terms])), collapse = "_")
    return(summ_term)
  }
}

enrich.summ <- sapply(module.enrich, function(x) summ_go(x, 2))
```


```{r plot_mod_enrich, results = "asis", fig.width = 10, fig.height = 7}

for(i in 1:length(module.enrich)){
  cat("###", names(module.enrich)[i], "\n")
  #quartz(width = 10, height = 7)
  #par(mfrow = c(1,2))
  plot.enrichment(module.enrich[[i]], num.terms = 20, order.by = "p_value",
  plot.label = "")
  
  #split.terms <- unlist(strsplit(module.enrich[[i]]$result[,"term_name"], " "))
  #par(mar = c(0,0,0,0))
  #wordcloud(split.terms)
  cat("\n\n")
}

```

## Module Enrichment Based on Main Effects  {.tabset .tabset-fade .tabset-pills}

We will go through each trait and examine the networks associated with
upregulation and downregulation of each. The following heatmaps show
functional enrichments for ordered lists of transcripts that are associated
with up and down regulation of each eigentrait. There is a lot of overlap 
because the same transcripts are represented in each eigentrait.

```{r trait_networks, results = "asis", fig.height = 7, fig.width = 7}

for(i in 1:ncol(just.main)){
  cat("### ET", i, "\n")
  up.locale <- which(just.main[,i] > 0)
  down.locale <- which(just.main[,i] < 0)

  up.mod.locale <- match(rownames(just.main)[up.locale], names(module.enrich))
  up.mod.locale <- up.mod.locale[which(!is.na(up.mod.locale))]
  down.mod.locale <- match(rownames(just.main)[down.locale], names(module.enrich))
  down.mod.locale <- down.mod.locale[which(!is.na(down.mod.locale))]
  #quartz(width = 7, height = 20)
  all.up <- Reduce("rbind", lapply(module.enrich[up.locale], function(x) x$result))
  all.down <- Reduce("rbind", lapply(module.enrich[down.locale], function(x) x$result))
  
  enrich.group <- list("Up" = all.up, "Down" = all.down)
  plot.enrichment.group(enrich.group, plot.label = colnames(just.main)[i], 
  n.terms = 20, sort.by = "p_value")
  cat("\n\n")
}

```

## ET networks {.tabset .tabset-fade .tabset-pills}

Because the network is the same across all eigentraits, 
but the main effects differ, we make one network here,
but add main effect values for each eigentrait.

```{r ET_nets}
cape.adj <- just.int
zero.locale <- which(is.na(cape.adj))
cape.adj[zero.locale] <- 0
cape.net <- graph_from_adjacency_matrix(cape.adj, mode = "directed", weighted = TRUE)
E(cape.net)$edge.sign <- sign(E(cape.net)$weight)
E(cape.net)$weight <- abs(E(cape.net)$weight)
V(cape.net)$et1 <- just.main[,1]
V(cape.net)$et2 <- just.main[,2]
V(cape.net)$et3 <- just.main[,3]
```

The following plots show the networks for each ET. The network edges
are identical in each case, but which vertices are included is based
on the main effects for each ET.


**Degree and Betweenness:** We examined both degree and betweenness of
vertices. We looked at in degree, out degree, and total degree. 

```{r dir_fun}
#This function gets directed edge weights from a graph
#based on module assignments
dir_weights <- function(net, mods, source.mod, target.mod){
  
  vnames <- V(net)$name
  eweights <- E(net)$weight*E(net)$pos.neg
  elist <- as_edgelist(net)

  #find all edges that go from the source module to the 
  #target module

  source.mod.v <- vnames[which(mods == source.mod)]
  target.mod.v <- vnames[which(mods == target.mod)]


  source.v.locale <- which(elist[,1] %in% source.mod.v)
  target.v.locale <- which(elist[,2] %in% target.mod.v)

  spanning.edges <- intersect(source.v.locale, target.v.locale)
  spanning.weights <- eweights[spanning.edges]
  return(spanning.weights)
}

#This function takes in a network with assigned modules and 
#looks at the relationship between a single vertex and the
#modules
ind_weights <- function(net, vertex.name, et.which = 1){

  vnames <- V(net)$name
  eweights <- E(net)$weight*E(net)$edge.sign
  elist <- as_edgelist(net)

  v.as.source <- which(elist[,1] == vertex.name)
  v.as.target <- which(elist[,2] == vertex.name)

  n.out <- length(v.as.source)
  n.in <- length(v.as.target)
  
  targets <- elist[v.as.source,2]
  sources <- elist[v.as.target,1]

  out.weights <- eweights[v.as.source]
  names(out.weights) <- targets
  in.weights <- eweights[v.as.target]
  names(in.weights) <- sources

  vert.att <- vertex_attr(net)
  att.locale <- which(names(vert.att) == et.which)

  source.main <- vert.att[[att.locale]][match(sources, vnames)]
  names(source.main) <- sources
  target.main <- vert.att[[att.locale]][match(targets, vnames)]
  names(target.main) <- targets

  vert.main <- vert.att[[att.locale]][which(vnames == vertex.name)]
  names(vert.main) <- vertex.name

  results.list <- list("num.in.out" = c("in" = n.in, "out" = n.out),
  "weights.in.out" = list("in" = in.weights, "out" = out.weights),
  "main.in.out" = list("in" = source.main, "out" = target.main, "vert" = vert.main))

  return(results.list)
}

plot_net <- function(net, ecol = NULL, mcol = NULL){
  
  eweights <- E(net)$weight
  if(length(unique(sign(eweights))) > 1){
    edge.col <- colors.from.values(eweights, split.at.vals = TRUE, col.scale = c("blue", "brown"), grad.dir = "ends")
  }else{
    edge.col = colors.from.values(eweights, col.scale = c("purple"), grad.dir = "high")
  }
  E(net)$weight <- abs(E(net)$weight)

  if(is.null(mcol)){
    mweights <- V(net)$main.effect
    if(!is.null(mweights)){
      main.col <- colors.from.values(mweights, use.pheatmap.colors = TRUE)
    }else{
      main.col <- rep(2, vcount(net))
    }
  }else{
    main.col <- mcol
  }

  plot(net, edge.color = edge.col, vertex.color = main.col, layout = layout_nicely)
}

plot_ind_vert <- function(vertex.name, vert.results){
  layout.mat <- matrix(c(1,1,2,3,4,5), ncol = 2, byrow = TRUE)
  layout(layout.mat, heights = c(0.2, 1))
  
  par(mar = c(0,0,0,0))
  plot.text(paste("Source -->", vertex.name, "--> Target"), cex = 2)
  n.in.out <- vert.results$num.in.out
  
  par(mar = c(4,4,3,2))
  
  barplot(vert.results$num.in.out)

  boxplot(vert.results$weights.in.out, ylab = "Edge Weights", 
  main = paste("Edge Weights for", vertex.name))
  par(xpd = FALSE)
  abline(h = 0)

  #finally, plot the vertex with its sources and targets
  source.verts <- vert.results$weights.in.out$"in"
  target.verts <- vert.results$weights.in.out$"out"

  all.main <- unlist(vert.results$main.in.out)
  names(all.main) <- sapply(strsplit(names(all.main), "[.]"), function(x) x[2])

  if(length(source.verts) > 0){
    in_edges <- cbind(names(source.verts), rep(vertex.name, length(source.verts)))
    toy_net_in <- graph_from_edgelist(in_edges)
    E(toy_net_in)$weight <- as.numeric(source.verts)  
    common.v.names <- intersect(names(all.main), V(toy_net_in)$name)
    V(toy_net_in)$main.effect <- all.main[match(common.v.names, V(toy_net_in)$name)]
    plot_net(toy_net_in)
  }

 if(length(target.verts) > 0){
  out_edges <- cbind(rep(vertex.name, length(target.verts)), names(target.verts))
  toy_net_out <- graph_from_edgelist(out_edges)
  E(toy_net_out)$weight <- as.numeric(target.verts)  
  common.v.names <- intersect(names(all.main), V(toy_net_out)$name)
  V(toy_net_out)$main.effect <- all.main[match(common.v.names, V(toy_net_out)$name)]
  plot_net(toy_net_out)
 }

}
```

```{r net_plots, results = "asis", fig.width = 6, fig.height = 6}

for(i in 1:length(et.nets)){
  
  cat("### ET", i, "\n")
  
  par(mfrow = c(2,2))

  par(mar = c(0,0,0,0))
  vert.weights <- just.main[,et]
  edge.weights <- E(cape.net)$weight
  pos.neg <- E(cape.net)$edge.sign
  
  edge.col <- colors.from.values(edge.weights*pos.neg, split.at.vals = TRUE,
  split.point = 0, col.scale = c("blue", "brown"), grad.dir = "ends")
  vertex.col <- colors.from.values(vert.weights, split.at.vals = TRUE,
  split.point = 0, col.scale = c("blue", "brown"), grad.dir = "ends")
  
  plot(cape.net, vertex.size = 5, vertex.color = vertex.col, 
  layout = layout_with_kk, edge.color = edge.col, vertex.label.dist = 1,
  vertex.label.cex = 0.5, edge.arrow.size = 0.3)

  par(mar = c(4,4,2,2), xpd = FALSE)

  #barplot(degree(net))
  in.deg <- degree(cape.net, mode = "in")
  out.deg <- degree(cape.net, mode = "out")
  all.deg <- degree(cape.net, mode = "all")
  bet <- betweenness(cape.net)
  
  max.deg <- max(c(in.deg, out.deg, all.deg))
  max.bet <- max(bet)
  xmax <- max.deg*1.05
  ymax <- max.bet*1.05

  plot(out.deg, bet, xlab = "Out Degree", ylab = "Betweenness", pch = 16, 
  col = vertex.col, xlim = c(0, xmax), ylim = c(0, ymax), main = "Out Degree")
  text(out.deg, bet, labels = V(simp.net)$name, pos = 3, cex = 0.7)

  plot(in.deg, bet, xlab = "In Degree", ylab = "Betweenness", pch = 16, 
  col = vertex.col, xlim = c(0, xmax), ylim = c(0, ymax), main = "In Degree")
  text(in.deg, bet, labels = V(simp.net)$name, pos = 3, cex = 0.7)

  plot(all.deg, bet, xlab = "Total Degree", ylab = "Betweenness", pch = 16, 
  col = vertex.col, xlim = c(0, xmax), ylim = c(0, ymax), main = "All Degree")
  text(all.deg, bet, labels = V(simp.net)$name, pos = 3, cex = 0.7)

  cat("\n\n")

}
```

## Individual Vertex Placement

Sex had a very high betweenness in this network and was in between the
two modules. We looked more specifically at how that variable fit into 
the network.

The plots below show that Sex had equal numbers of in and out edges,
but they were completely sorted by module. All the edges going into 
sex were from module 2 and were negative. All edges coming out of 
sex go to module 1 and are positive. That is true for all networks,
although I do not show them below.

```{r, ind_verts, fig.width = 6, fig.height = 6}
vert.name <- "MEroyalblue"
vert.results <- ind_weights(cape.net, vert.name, "et1")
plot_ind_vert(vert.name, vert.results) 
```

The **MEmagenta**, **MEskyblue3**, and **MEorangered4** modules were related to 
immune response.

```{r immune_mods}
immune.mods <- c("MEmagenta", "MEskyblue3", "MEorangered4")
for(i in 1:length(immune.mods)){
  vert.results <- ind_weights(cape.net, immune.mods[i], et.which = "et1")
  plot_ind_vert(immune.mods[i], vert.results) 
}
```

ER and Golgi related modules are 

```{r er_golgi_mods}
golgi.mods <- c("MEdarkmagenta", "MEyellow", "MEbrown")
for(i in 1:length(immune.mods)){
  quartz()
  vert.results <- ind_weights(cape.net, golgi.mods[i], et.which = "et1")
  plot_ind_vert(immune.mods[i], vert.results) 
}
```

If we plot in weights vs. out weights, we see that most vertices
are imbalanced. There are only four vertices that have positive 
weights going in and out.

There are more that have negative weights in both directions. 

```{r all_vert_results}
enrich.summ <- c(enrich.summ, "sexM")
names(enrich.summ)[length(enrich.summ)] <- "sexM"


sum.in <- rowSums(just.int, na.rm = TRUE)
sum.out <- colSums(just.int, na.rm = TRUE)
mean.in <- rowMeans(just.int, na.rm = TRUE)
mean.out <- colMeans(just.int, na.rm = TRUE)

plot(sum.in, sum.out, xlab = "Total Out Weight", ylab = "Total In Weight",
xlim = c(min(sum.in)*1.1, max(sum.in)*2))
text(sum.in, sum.out, labels = enrich.summ, cex = 0.7, pos = 4)
abline(h = 0, v = 0)

#quartz(width = 10, height = 10)
plot(mean.in, mean.out, xlab = "Mean Out Weight", ylab = "Mean In Weight",
xlim = c(min(mean.in)*1.1, max(mean.in)*2))
text(mean.in, mean.out, labels = enrich.summ, cex = 0.7, pos = 4)
abline(h = 0, v = 0)
```

I want to explore which modules have enrichment for any given term, for example
"inflammation." Just using the top terms isn't necessarily descriptive of the 
whole module.

```{r term_search}
search_term <- function(enrichment.table, term.name){
  if(class(enrichment.table) == "list"){
    enrichment.table <- enrichment.table[[1]]
  }
  term.locale <- grep(term.name, enrichment.table[,"term_name"], ignore.case = TRUE)
  if(length(term.locale) > 0){
    return(enrichment.table[term.locale,])
  }else{
    return(NULL)
  }
}

test.term <- "extracellular matrix"
mods.which <- lapply(module.enrich, function(x) search_term(x, test.term))
not.null <- which(sapply(mods.which, length) > 0)
all.search.terms <- Reduce("rbind", mods.which[not.null])

term.col <- rep("gray", length(mean.in))
names(term.col) <- names(module.enrich)
term.col[not.null] <- "red"
plot(mean.in, mean.out, xlab = "Mean Out Weight", ylab = "Mean In Weight",
xlim = c(min(mean.in)*1.1, max(mean.in)*2), col = term.col, pch = 16, main = test.term)
#text(mean.in, mean.out, labels = enrich.summ, cex = 0.7, pos = 4)
abline(h = 0, v = 0)

```

Let's look at some effects.


```{r effects}
geno_obj <- readRDS(here("Results", exp.dir, "cross_geno.RData"))
plot_effects(cross, geno_obj, marker1 = "MEyellow_B", pheno_type = "ET", plot_type = "b",
error_bars = "se")
plot_effects(cross, geno_obj, marker1 = "MEgrey60_B", pheno_type = "ET", plot_type = "b",
error_bars = "se")
plot_effects(cross, geno_obj, marker1 = "MEyellow_B", marker2 = "MEgrey60_B", 
pheno_type = "ET", plot_type = "h", error_bars = "se")

marker1 = "MEyellow";marker2 = "MEgrey60"
par(mfrow = c(1,3))
for(i in 1:ncol(cross$ET)){
  pheno.col <- colors.from.values(cross$ET[,i], use.pheatmap.colors = TRUE)
  plot(geno_obj[,2,marker1], geno_obj[,2,marker2], col = pheno.col, pch = 16,
  main = paste("ET", i), xlab = marker1, ylab = marker2)
}


```