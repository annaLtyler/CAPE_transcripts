---
title: "SOM Analysis CC-RIX"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

The purpose of this workflow is to analyze the results
generated by SOM_CC-RIX.Rmd.


```{r get_args}
tissue.name <- "liver"
is.interactive <- FALSE
#is.interactive <- TRUE
```

```{r source_code}
library("here")

all.fun <- list.files(here("Code"), pattern = ".R", full.names = TRUE)
for(j in 1:length(all.fun)){source(all.fun[j])}
```


```{r load_libraries,  warning = FALSE, message = FALSE, error = FALSE}
needed.packages <- c("pheatmap", "knitr")
load_libraries(needed.packages, personal.library = TRUE)
```

```{r load_data}
#This loads an environment called env that can be
load(here("Results", "SOM", paste0("CC-RIX_", tissue.name, ".RData")))
adj.expr <- readRDS(here("Results", "SOM", paste0("Adjusted.Expression.", tissue.name, ".RDS")))
adj.expr <- apply(adj.expr, 2, rankZ)
adj.bw <- readRDS(here("Results", "SOM", "Adjusted.BW.RDS"))
adj.chem <- readRDS(here("Results", "SOM", "Adjusted.Chem.RDS"))
```

## Look for phenotype variation among clusters of individuals

As part of the SOM, the individual mice are clustered according to their
overall gene expression patterns. We look here to ask whether the groupings
correlate with any of the traits. 

```{r pheno_clusters}
groups <- env$group.labels
group.colors <- env$group.colors
u_groups <- unique(groups)
u_colors <- unique(group.colors)
ind.groups <- lapply(u_groups, function(x) names(groups)[which(groups == x)])
names(ind.groups) <- u_groups
```


## BW by Group

The plots below show the distribution of phenotypes over each
group identified by the SOM based on transcriptional clustering.

```{r pheno_by_group, width = 12, height = 8}
pheno.by.group <- function(pheno.mat){
  pheno.ind <- lapply(ind.groups, function(x) which(rownames(pheno.mat) %in% x))
  mean.pheno <- matrix(NA, nrow = length(pheno.ind), ncol = ncol(pheno.mat))
  rownames(mean.pheno) <- names(pheno.ind)
  colnames(mean.pheno) <- colnames(pheno.mat)

  if(is.interactive){quartz(width = 8, height = 8)}
  layout.mat <- get.layout.mat(ncol(pheno.mat))
  layout(layout.mat)
  par(mar = c(10,2,2,2))
  for(i in 1:ncol(pheno.mat)){  
    group.pheno <- lapply(pheno.ind, function(x) pheno.mat[x,i])
    med.order <- order(sapply(group.pheno, function(x) median(x, na.rm = TRUE)), 
    decreasing = FALSE)
    boxplot(group.pheno[med.order], main = colnames(pheno.mat)[i],
    col = u_colors[med.order], las = 2)
    mean.pheno[,i] <- sapply(group.pheno, function(x) mean(x, na.rm = TRUE))
  }
  return(mean.pheno)
}
```

```{r group_bw}
mean.bw <- pheno.by.group(adj.bw)
```

The following heatmap shows the mean chemstries across groups.

```{r mean_bw}
par(mar = c(4, 10, 2, 2))
barplot(sort(mean.bw[,1]), las = 2, horiz = TRUE, xlab = "Body Weight")
```


## Chemistry by Group

```{r chem_by_group}
mean.chem <- pheno.by.group(adj.chem)
```

The following heatmap shows the mean chemstries across groups.

```{r mean_chem}
pheatmap(t(mean.chem), scale = "row")
```

## Metagenes

The transcriptome is also clustered. The genes are clustered into a 
grid of metagenes. The distribution of genes per metagene is shown 
below. 

```{r genes_per_metagene}
metagene.assig <- env$som.result$feature.BMU
n.meta <- max(metagene.assig)
meta.genes <- lapply(1:n.meta, function(x) names(metagene.assig)[which(metagene.assig == x)])
n.genes <- sapply(meta.genes, length)

hist(n.genes, breaks = 100, main = "Number of Genes per Metagene",
xlab = "Number of Genes")
```

The following plots show the absolute value of the correlations
between phenotypes and metagenes.

```{r plot_portrait_fun}
plot_portrait <- function(portraitV, global.min = NULL, global.max = NULL){
  if(is.interactive){quartz()}
  portraitV[which(is.na(portraitV))] <- 0
  map.dim <- sqrt(length(portraitV))
  map.mat <- rotate.mat(rotate.mat(rotate.mat(matrix(portraitV, nrow = map.dim, ncol = map.dim, byrow = FALSE))))
  if(!is.null(global.min)){
    imageWithText(map.mat, show.text = FALSE, use.pheatmap.colors = TRUE, 
      global.color.scale = TRUE, global.min = global.min, global.max = global.max)  
  }else{
    imageWithText(map.mat, show.text = FALSE, use.pheatmap.colors = TRUE)
  }
}
```


```{r spot_cor}
spot.cor <- function(pheno.mat){
  kmeta <- env$spot.list.kmeans$spots
  metagenes <- env$metadata
  map.dim <- sqrt(nrow(metagenes))

  pheno.metagene.cor <- vector(mode = "list", length = ncol(pheno.mat))
  names(pheno.metagene.cor) <- colnames(pheno.mat)

  common.ind <- intersect(colnames(metagenes), rownames(pheno.mat))
  metagene.locale <- match(common.ind, colnames(metagenes))
  pheno.locale <- match(common.ind, rownames(pheno.mat))
  expr.locale <- match(common.ind, rownames(adj.expr))
  #head(cbind(colnames(metagenes)[metagene.locale], rownames(pheno.mat)[pheno.locale]))

  for(m in 1:ncol(pheno.mat)){
    metagene.cor <- apply(metagenes[,metagene.locale], 1, 
      function(x) cor(pheno.mat[pheno.locale,m], x, use = "pairwise.complete.obs"))
    pheno.metagene.cor[[m]] <- matrix(metagene.cor, nrow = map.dim, ncol = map.dim, byrow = FALSE)
    #pheatmap(pheno.metagene.cor[[m]], cluster_rows = FALSE, cluster_cols = FALSE,main = colnames(adj.pheno)[m])
  }
  return(pheno.metagene.cor)
}
```

### Body Weight

```{r bw_cor}
bw.metagene.cor <- spot.cor(adj.bw)
hist(unlist(lapply(bw.metagene.cor, abs)), breaks = 100, xlab = "Correlation",
main = "Correlation between body weight and metagenes")
```

### Chemistry


```{r chem_cor}
chem.metagene.cor <- spot.cor(adj.chem)
all.chem.cor <- lapply(chem.metagene.cor, function(x) unlist(abs(x)))
boxplot(all.chem.cor, las = 2, main = "Correlation between blood chemistries and metagenes", 
  ylab = "Correlation")
```


## Correlation Maps  {.tabset .tabset-fade .tabset-pills}

The following plots show maps of the correlations between traits 
and metagenes. Each trait has roughly the same correlation pattern 
with the metagenes. 

In one tab we show the correlations all on the same scale to show 
relative correlations across traits.

The second tab shows each correlation plot on its own scale to 
highlight the overall patterns in the correlations. 

The correlations are much lower than I had thought they would be, and are
also much lower than what we saw with CCA. With CCA we maximize the correlation
between transcripts and traits. We were able to achive correlations from -0.6 
to 0.6 across all tissues. Here, when we cluster the transcripts without taking
the traits into account, we get much lower correlations. 

The following histogram shows the distribution of correlations between
all metagenes and all traits for `r tissue.name`.

### Global Color Scale {.tabset .tabset-fade .tabset-pills}

#### Body Weight

```{r metagene_cor_maps, fig.width = 10, fig.height = 9}
plot_metagene_cor <- function(pheno.metagene.cor, pheno.mat, global.color.scale = TRUE){
  min.cor <- min(unlist(pheno.metagene.cor))
  max.cor <- max(unlist(pheno.metagene.cor))

  layout.mat <- get.layout.mat((length(pheno.metagene.cor)+1))

  layout(layout.mat)
  par(mar = c(0,0,4,0))
  for(m in 1:length(pheno.metagene.cor)){
    imageWithText(pheno.metagene.cor[[m]], use.pheatmap.colors = TRUE, 
    show.text = FALSE, global.color.scale = global.color.scale, 
    global.min = min.cor, global.max = max.cor, main = colnames(pheno.mat)[m])
  }
  par(mar = c(0,4,4,4))
  imageWithTextColorbar(matrix(segment_region(min.cor, max.cor, 10), ncol = 1), 
    use.pheatmap.colors = TRUE, cex = 1, global.color.scale = global.color.scale,
    global.min = min.cor, global.max = max.cor)
}
```

```{r bw_cor_global}
plot_metagene_cor(bw.metagene.cor, adj.bw)
```


#### Chemistry

```{r chem_cor_global
plot_metagene_cor(chem.metagene.cor, adj.chem)
```



### Individual Color Scale {.tabset .tabset-fade .tabset-pills}

```{r bw_cor_local}
plot_metagene_cor(bw.metagene.cor, adj.bw, global.color.scale = FALSE)
```


#### Chemistry

```{r chem_cor_local}
plot_metagene_cor(chem.metagene.cor, adj.chem, global.color.scale = FALSE)
```


## Gene Set Correlations {.tabset .tabset-fade .tabset-pills}

The following code looks for gene sets with maximal correlations with clinical
phenotypes. Here we plot the top and bottom 10 processes associated with each
trait.

```{r gsz_cor}
gsz <- env$samples.GSZ.scores

gene_set_cor <- function(pheno.mat){
  common.ind <- intersect(colnames(gsz), rownames(pheno.mat))
  gsz.locale <- match(common.ind, colnames(gsz))
  pheno.locale <- match(common.ind, rownames(pheno.mat))

  gsz.cor.mat <- matrix(NA, nrow = nrow(gsz), ncol = ncol(pheno.mat))
  rownames(gsz.cor.mat) <- rownames(gsz)
  colnames(gsz.cor.mat) <- colnames(pheno.mat)

  for(m in 1:ncol(pheno.mat)){
    gsz.cor.mat[,m] <- apply(gsz[,gsz.locale], 1, 
      function(x) cor(pheno.mat[pheno.locale,m], x, use = "pairwise.complete.obs"))
  }
  return(gsz.cor.mat)
}

plot_top_cor <- function(gsz.cor.mat, pheno.mat){
  all.top.cor <- vector(mode = "list", length = ncol(pheno.mat))
  names(all.top.cor) <- colnames(pheno.mat)
  for(ph in 1:ncol(gsz.cor.mat)){
    if(is.interactive){quartz()}
    cat("###", colnames(pheno.mat)[ph], "\n")
    sorted.cor <- sort(gsz.cor.mat[,ph])
    top.cor <- c(head(sorted.cor, 10), tail(sorted.cor, 10))
    all.top.cor[[ph]] <- top.cor
    par(mar = c(4, 18, 4, 2))
    barplot(top.cor, las = 2, horiz = TRUE, cex.names = 0.7, main = colnames(pheno.mat)[ph],
    xlab = "Correlation")
    all.top.cor[[ph]] <- top.cor
    cat("\n\n")
  }
  return(all.top.cor)
}
```

### Body Weight

```{r bw_gene_sets}
bw.gene.sets <- gene_set_cor(adj.bw)
bw.top.cor <- plot_top_cor(bw.gene.sets, adj.bw)
```

### Blood Chemistry

```{r chem_gene_sets}
chem.gene.sets <- gene_set_cor(adj.chem)
chem.top.cor <- plot_top_cor(chem.gene.sets, adj.chem)
```


## Trait-Process Correlation Heatmap {.tabset .tabset-fade .tabset-pills}

The following code generates a heatmap showing the top processes 
associated with all traits. This plot and a box plot of this 
matrix can be found in the SOM results folder. 

```{r process_cor, fig.height = 20, fig.width = 9}
top_cor_heatmap <- function(gene.set.cor.mat, top.cor, file.label = "results"){
  u_processes <- unique(unlist(lapply(top.cor, function(x) names(x))))
  process.locale <- match(u_processes, rownames(gene.set.cor.mat))
  
  pdf(here("Results", "SOM", paste0("Top_Processes_", tissue.name, "_", file.label, ".pdf")), 
  width = 7, height = 20)

  if(ncol(gene.set.cor.mat) == 1){cluster_cols = FALSE}else{cluster_cols = TRUE}  
  pheatmap(gene.set.cor.mat[process.locale,], cluster_cols = cluster_cols)

  process.order <- order(rowMeans(gene.set.cor.mat[process.locale,,drop=FALSE]))

  par(mar = c(4, 15, 2, 2))
  boxplot(t(gene.set.cor.mat[process.locale[process.order],]), horizontal = TRUE, las = 2,
  cex.axis = 0.5, main = "Top Correlated Processes")
  abline(v = 0)
  dev.off()
}
```

```{r plot_top_processes}
top_cor_heatmap(bw.gene.sets, bw.top.cor, "BW")
top_cor_heatmap(chem.gene.sets, chem.top.cor, "Chem")
```

## Clustered Metagenes

The SOM clusters metagenes into clusters using k-means clustering. 
Neighboring metagenes are very highly correlated with each other. 
The clustering of metagenes allows us to reduce the dimentionality 
even more. 

The barplot below shows the number of genes in each of the K-means 
clusters. They are remarkably even in size.

```{r metagenes, fig.width = 9, fig.height = 5}
kmeta <- env$spot.list.kmeans$spots
cluster.sizes <- sapply(kmeta, function(x) length(x$genes))
barplot(cluster.sizes)
```

## Metagene Cluster Trends

Here we look at correlation matrices for clustered metagenes. We find all the 
metagenes in a single cluster and decompose the cluster using SVD. We then
use the first principle component of the metagene matrix as the clustered
metagene. We calculated the correlation of each of these clustered metagenes
to the clinical traits, and scanned each. 

The correlations with the traits are very comparable to WGCNA eigengene
correlations with traits. The mapping is also par with mapping of other 
gene modules. Maybe a little better.

```{r metagene_clusters, warning = FALSE}

eig_genes <- function(pheno.mat){
  metagenes <- env$metadata
  kmeans <- env$spot.list.kmeans
  kmap <- kmeans$overview.map
  u_k <- sort(unique(as.vector(kmap)))

  #matrix for keeping correlations between eigenegenes and traits
  k.gene.cor <- matrix(NA, nrow = length(u_k), ncol = ncol(pheno.mat))
  rownames(k.gene.cor) <- names(kmeans$spots)
  colnames(k.gene.cor) <- colnames(pheno.mat)

  #matrix for keeping eigengene values for each individual
  #The individuals in this matrix are indexed using the 
  #trait matrix
  k.gene.mat <- matrix(NA, nrow = nrow(pheno.mat), ncol = length(u_k))
  colnames(k.gene.mat) <- names(kmeans$spots)
  rownames(k.gene.mat) <- rownames(pheno.mat)

  #identify individuals with both expression and traits
  common.ind <- intersect(rownames(pheno.mat), colnames(metagenes))
  pheno.locale <- match(common.ind, rownames(pheno.mat))
  expr.locale <- match(common.ind, rownames(adj.expr))

  for(k in 1:length(u_k)){

    #get the gene names included in the kth metagene
    k.genes <- kmeta[[k]]$genes

    #use svd to decompose the gene expression in expression space
    #if there are genes not in this dataset, there is probably a tissue mismatch
    #all genes from the expression matrix should be present in the metagenes
    #and vice versa
    #plot.decomp(adj.expr[expr.locale,k.genes])
    k.gene.decomp <- plot.decomp(adj.expr[expr.locale,k.genes], plot.results = FALSE)

    k.gene.mat[k.gene.decomp$rows.used,k] <- k.gene.decomp$u[,1]
    #k.cor <- apply(adj.pheno[pheno.locale,], 2, function(x) cor(x, k.gene[metagene.locale], use = "pairwise.complete.obs"))
    k.cor <- apply(pheno.mat[pheno.locale,,drop=FALSE], 2, 
      function(x) cor(x, k.gene.mat[,k], use = "pairwise.complete.obs"))
    #plot.with.model(pheno.mat[pheno.locale,1,drop=FALSE], k.gene.mat[expr.locale,])
    k.gene.cor[k,] <- k.cor
  }
  result <- list("k.eigengene.mat" = k.gene.mat, "k.cor" = k.gene.cor)
  return(result)
}
```

```{r bw_gene_eig}
bw.eig.gene <- eig_genes(adj.bw)
barplot_with_num(round(bw.eig.gene$k.cor[,1], 2), text.srt = 90)
```

```{r chem_gene_eig}
chem.eig.gene <- eig_genes(adj.chem)
pheatmap(chem.eig.gene$k.cor, display_numbers = TRUE)
```

The following code runs genetic mapping on metagenes. I tried 
mapping the metagenes directly and got very strange mapping.
So instead I am mapping the first principle component of the 
expression matrix defined by the metagene clusters.

```{r kgene_scan, fig.width = 12, fig.height = 6}
metagene.scan.file <- here("Results", "SOM", paste0("Metagene.Scan.", tissue.name, ".RDS"))

if(!file.exists(metagene.scan.file)){
  k.gene.scan <- scan1(genoprobs, bw.eig.gene$k.eigengene.mat)
  saveRDS(k.gene.scan, metagene.scan.file)
}else{
  k.gene.scan <- readRDS(metagene.scan.file)
}

par(xpd = NA)
multilod.plot(k.gene.scan, map = map, lod.thresh = 4, row.names = colnames(k.gene.scan),
row.name.shift = -1000)
par(xpd = TRUE)
```

## LOD traces for clustered metagenes {.tabset .tabset-fade .tabset-pills}

The following plots show the LOD trace for each metagene along with its
cis-trans eQTL plot to help show where the metagene QTLs might be coming
from.

```{r eqtl_fun}
#get a table with eQTL chromosome, position,
#and lod score.
get_eqtl_table <- function(gene.ids){
    gene.locale <- match(gene.ids, lod.table[[1]])
    gene.locale <- gene.locale[which(!is.na(gene.locale))]
    sub.table <- as.matrix(lod.table[gene.locale,])
    split.qtl.pos <- strsplit(sub.table[,2], "_")
    qtl.chr <- sapply(split.qtl.pos, function(x) x[1])
    qtl.pos <- as.numeric(sapply(split.qtl.pos, function(x) x[2]))/1e6
    final.table <- cbind(sub.table[,1], qtl.chr, qtl.pos)
    return(final.table)
}

#get a table with transcript chromosome and
#position
get_transcript_table <- function(gene.ids){
    trans.locale <- match(gene.ids, gene.info[[1]])
    sub.table <- as.matrix(gene.info[trans.locale,])
    final.table <- sub.table[,c(1,4,5)]
    return(final.table)
}
```

```{r plot_ind, fig.width = 12, fig.height = 8, results = "asis"}
lod.table <- expr.data$lod$additive
gene.info <- expr.data$annot.mrna

all.marker.chr <- unlist(sapply(1:length(map), function(x) rep(names(map)[x], length(map[[x]]))))
all.marker.pos <- as.numeric(unlist(map))
rel.marker.pos <- get_relative_genomic_position(all.marker.chr, all.marker.pos, map)
chr.col <- rep("darkgray", length(all.marker.chr))
chr.col[which(as.numeric(all.marker.chr) %% 2 == 1)] <- "#1f78b4"

layout.mat <- matrix(c(1,2), ncol = 1)

for(i in 1:ncol(k.gene.scan)){
  if(is.interactive){quartz(width = 10, height = 6)}
  cat("###", colnames(k.gene.scan)[i], "\n")
  layout(layout.mat, heights = c(0.5, 1))

  par(mar = c(0,2,2,2))
  #plot(k.gene.scan, map = map, lodcol = i)
  #quartz()
  plot(rel.marker.pos, k.gene.scan[,i], col = chr.col, type = "h", 
    axes = FALSE, ylab = "LOD Score")
  axis(2);abline(h = 6)

  cluster.genes <- kmeta[[i]]$genes
  #mod.eig <- plot.decomp(adj.expr[,cluster.genes], plot.results = FALSE)$u[,1,drop=FALSE]
  #rownames(mod.eig) <- rownames(adj.pheno)
  #eig.scan <- scan1(genoprobs, mod.eig)
  #plot(rel.marker.pos, eig.scan[,1], col = chr.col, type = "h", 
  #  axes = FALSE, ylab = "LOD Score")
  #axis(2);abline(h = 6)
 
  eqtl.table <- get_eqtl_table(cluster.genes)
  transcript.pos.table <- get_transcript_table(cluster.genes)
  lod.col <- colors.from.values(sqrt(as.numeric(eqtl.table[,3])), 
  col.scale = "blue", light.dark = "d")
  par(mar = c(2,2,0,2))
  plot.cistrans.table(eqtl.table, transcript.pos.table, map = map,
    add = FALSE, cex = 0.5, col = lod.col, label.cex = 0.7)  
  
  mtext(side = 3, outer = TRUE, text = paste("Metagene", colnames(k.gene.scan)[i]),
  line = -2.5)
  cat("\n\n")
}
```

## Peak Allele Effects {.tabset .tabset-fade .tabset-pills}

```{r scan_allele_effects}
metagene.peak.scan.file <- here("Results", "SOM", 
  paste0("Metagene.LOD.Scores.", tissue.name, ".RDS"))
metagene.peak.allele.file <- here("Results", "SOM", 
  paste0("Metagene.Allele.Effects.", tissue.name, ".RDS"))

peak.table <- find_peaks(k.gene.scan, map = map, threshold = 6)

if(!file.exists(metagene.peak.scan.file)){
  metagene.peak.lod.scans <- metagene.peak.allele.scans <- vector(mode = "list", length = nrow(peak.table))
  scan.names <- apply(peak.table, 1, function(x) paste0(x[2], "_Chr", str_trim(x[3])))
  for(i in 1:nrow(peak.table)){
    peak.chr <- as.vector(peak.table[i,"chr"])
    if(peak.chr != "X"){
      peak.pos <- as.numeric(peak.table[i,"pos"])
      peak.trait <- peak.table[i,"lodcolumn"]
      chr.locale <- which(names(map) == peak.chr)
      lod.scan <- scan1(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      metagene.peak.lod.scans[[i]] <- lod.scan
      coef.scan <- scan1coef(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      #coef.scan <- scan1blup(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      metagene.peak.allele.scans[[i]] <- coef.scan
    }
  }
  saveRDS(metagene.peak.allele.scans, metagene.peak.allele.file)
  saveRDS(metagene.peak.lod.scans, metagene.peak.scan.file)
}else{
  metagene.peak.allele.scans <- readRDS(metagene.peak.allele.file)
  metagene.peak.lod.scans <- readRDS(metagene.peak.scan.file)
}
```

```{r plot_scans, results = "asis", fig.height = 8, fig.widdth = 12}
for(i in 1:length(metagene.peak.lod.scans)){
  peak.chr <- peak.table[i,"chr"]
  peak.pos <- as.numeric(peak.table[i,"pos"])
  if(peak.chr != "X"){
    cat("###", peak.table[i,"lodcolumn"], "Chr", peak.chr, "\n")
    par(mfrow = c(2,1), mar = c(2,2,2,2))
    plot(metagene.peak.lod.scans[[i]], map = map);abline(v = peak.pos)
    plot_coefCC(metagene.peak.allele.scans[[i]], map = map)
    abline(v = peak.pos)
    cat("\n\n")
  }
}
```


```{r cluster_analysis, eval = FALSE}
cluster.name = "L"
p.thresh <- 20
cluster.locale <- which(names(kmeta) == cluster.name)
cluster.enrich <- kmeta[[cluster.locale]]$Fisher.p
log.p <- -log10(cluster.enrich)
par(mar = c(4, 18, 2, 2))
barplot(sort(log.p[which(log.p > p.thresh)]), horiz = TRUE, las = 2, xlab = "-log10(p)",
main = paste("Metagene", cluster.name))

cl.names <- lapply(kmeta, function(x) tail(sort(-log10(x$Fisher.p)), 1))

barplot(unlist(cl.names), las = 2, horiz = TRUE)
```

## Cluster Enrichments {.tabset .tabset-fade .tabset-pills}

The following plots show the locations and top associated biological
processes of each metagene.

```{r cluster_enrichments, results = "asis", fig.width = 10, fig.height = 6}
layout.matrix <- matrix(c(1,2,0,2), byrow = TRUE, ncol = 2)
for(k in 1:length(kmeta)){
  cat("### Cluster", names(kmeta)[k], "\n")
  if(is.interactive){quartz(width = 10, height = 6)}
  layout(layout.matrix, widths = c(0.7, 1), heights = c(1,0.5))
  par(mar = c(0,2,2,0))
  plot_portrait(kmeta[[k]]$mask)
  enrich <- sort(-log10(kmeta[[k]]$Fisher.p))
  top.enrich <- tail(enrich, 20)
  par(mar = c(4, 18, 4, 4))
  barplot(top.enrich, horiz = TRUE, las = 2, main = paste("Metagene", names(kmeta)[k]))
  cat("\n\n")
}
```