---
title: "SOM Analysis CC-RIX"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

```{r get_args}
tissue.name <- "adipose"
is.interactive <- FALSE
#is.interactive <- TRUE
```

TThis workflow shows results from the `r tissue.name` analysis
generated by SOM_CC-RIX.Rmd.


```{r source_code}
library("here")

all.fun <- list.files(here("Code"), pattern = ".R", full.names = TRUE)
for(j in 1:length(all.fun)){source(all.fun[j])}
```


```{r load_libraries,  warning = FALSE, message = FALSE, error = FALSE}
needed.packages <- c("pheatmap", "knitr")
load_libraries(needed.packages, personal.library = TRUE)
```

```{r load_data}
#This loads an environment called env that can be
load(here("Results", "SOM", paste0("CC-RIX_", tissue.name, ".RData")))
adj.expr <- readRDS(here("Results", "SOM", paste0("Adjusted.Expression.", tissue.name, ".RDS")))
#rankZ normalize
adj.expr <- apply(adj.expr, 2, rankZ)
adj.bw <- readRDS(here("Results", "SOM", "Adjusted.BW.RDS"))
adj.chem <- readRDS(here("Results", "SOM", "Adjusted.Chem.RDS"))
```

## Look for phenotype variation among clusters of individuals

As part of the SOM, the individual mice are clustered according to their
overall gene expression patterns. We look here to ask whether the groupings
correlate with any of the traits. 

```{r pheno_clusters}
groups <- env$group.labels
group.colors <- env$group.colors
u_groups <- unique(groups)
u_colors <- unique(group.colors)
ind.groups <- lapply(u_groups, function(x) names(groups)[which(groups == x)])
names(ind.groups) <- u_groups
```


## BW by Group {.tabset .tabset-fade .tabset-pills}

The plots below show the distribution of phenotypes over each
group identified by the SOM based on transcriptional clustering.

```{r pheno_by_group, width = 12, height = 8}
pheno.by.group <- function(pheno.mat){
  pheno.ind <- lapply(ind.groups, function(x) which(rownames(pheno.mat) %in% x))
  mean.pheno <- matrix(NA, nrow = length(pheno.ind), ncol = ncol(pheno.mat))
  rownames(mean.pheno) <- names(pheno.ind)
  colnames(mean.pheno) <- colnames(pheno.mat)

  if(is.interactive){quartz(width = 8, height = 8)}
  layout.mat <- get.layout.mat(ncol(pheno.mat))
  layout(layout.mat)
  par(mar = c(10,2,2,2))
  for(i in 1:ncol(pheno.mat)){  
    group.pheno <- lapply(pheno.ind, function(x) pheno.mat[x,i])
    med.order <- order(sapply(group.pheno, function(x) median(x, na.rm = TRUE)), 
    decreasing = FALSE)
    boxplot(group.pheno[med.order], main = colnames(pheno.mat)[i],
    col = u_colors[med.order], las = 2)
    mean.pheno[,i] <- sapply(group.pheno, function(x) mean(x, na.rm = TRUE))
  }
  return(mean.pheno)
}
```

### Distributions by group

```{r group_bw}
mean.bw <- pheno.by.group(adj.bw)
```

### Mean by group

```{r mean_bw}
par(mar = c(4, 10, 2, 2))
barplot(sort(mean.bw[,1]), las = 2, horiz = TRUE, xlab = "Body Weight")
```


## Chemistry by Group {.tabset .tabset-fade .tabset-pills}

### Distribution by group

```{r chem_by_group, fig.width = 10, fig.height = 10}
mean.chem <- pheno.by.group(adj.chem)
```

### Mean by group

```{r mean_chem, fig.width = 6, fig.height = 6}
pheatmap(t(mean.chem), scale = "row")
```

## Metagenes

The transcriptome is also clustered. The genes are clustered into a 
grid of metagenes. The distribution of genes per metagene is shown 
below. 

```{r genes_per_metagene}
metagene.assig <- env$som.result$feature.BMU
n.meta <- max(metagene.assig)
meta.genes <- lapply(1:n.meta, function(x) names(metagene.assig)[which(metagene.assig == x)])
n.genes <- sapply(meta.genes, length)

hist(n.genes, breaks = 100, main = "Number of Genes per Metagene",
xlab = "Number of Genes")
```

The following plots show the absolute value of the correlations
between phenotypes and metagenes.

```{r plot_portrait_fun}
plot_portrait <- function(portraitV, global.min = NULL, global.max = NULL){
  if(is.interactive){quartz()}
  portraitV[which(is.na(portraitV))] <- 0
  map.dim <- sqrt(length(portraitV))
  map.mat <- rotate.mat(rotate.mat(rotate.mat(matrix(portraitV, nrow = map.dim, ncol = map.dim, byrow = FALSE))))
  if(!is.null(global.min)){
    imageWithText(map.mat, show.text = FALSE, use.pheatmap.colors = TRUE, 
      global.color.scale = TRUE, global.min = global.min, global.max = global.max)  
  }else{
    imageWithText(map.mat, show.text = FALSE, use.pheatmap.colors = TRUE)
  }
}
```


```{r spot_cor}
spot.cor <- function(pheno.mat, expr.mat){
  kmeta <- env$spot.list.kmeans$spots
  metagenes <- env$metadata
  map.dim <- sqrt(nrow(metagenes))

  pheno.metagene.cor <- vector(mode = "list", length = ncol(pheno.mat))
  names(pheno.metagene.cor) <- colnames(pheno.mat)

  common.ind <- intersect(colnames(metagenes), rownames(pheno.mat))
  metagene.locale <- match(common.ind, colnames(metagenes))
  pheno.locale <- match(common.ind, rownames(pheno.mat))
  expr.locale <- match(common.ind, rownames(expr.mat))
  #head(cbind(colnames(metagenes)[metagene.locale], rownames(pheno.mat)[pheno.locale]))

  for(m in 1:ncol(pheno.mat)){
    metagene.cor <- apply(metagenes[,metagene.locale], 1, 
      function(x) cor(pheno.mat[pheno.locale,m], x, use = "pairwise.complete.obs"))
    pheno.metagene.cor[[m]] <- matrix(metagene.cor, nrow = map.dim, ncol = map.dim, byrow = FALSE)
    #pheatmap(pheno.metagene.cor[[m]], cluster_rows = FALSE, cluster_cols = FALSE,main = colnames(adj.pheno)[m])
  }
  return(pheno.metagene.cor)
}
```

### Body Weight

```{r bw_cor}
bw.metagene.cor <- spot.cor(adj.bw, adj.expr)
hist(unlist(bw.metagene.cor), breaks = 100, xlab = "Correlation",
main = "Correlation between body weight and metagenes")
```

### Chemistry


```{r chem_cor}
chem.metagene.cor <- spot.cor(adj.chem, adj.expr)
all.chem.cor <- lapply(chem.metagene.cor, function(x) unlist(abs(x)))
boxplot(all.chem.cor, las = 2, main = "|Correlation| between blood chemistries and metagenes", 
  ylab = "Correlation")
```


## Correlation Maps  {.tabset .tabset-fade .tabset-pills}

The following plots show maps of the correlations between traits 
and metagenes. Each trait has roughly the same correlation pattern 
with the metagenes. 

In one tab we show the correlations all on the same scale to show 
relative correlations across traits.

The second tab shows each correlation plot on its own scale to 
highlight the overall patterns in the correlations. 

The correlations are much lower than I had thought they would be, and are
also much lower than what we saw with CCA. With CCA we maximize the correlation
between transcripts and traits. We were able to achive correlations from -0.6 
to 0.6 across all tissues. Here, when we cluster the transcripts without taking
the traits into account, we get much lower correlations. 

The following histogram shows the distribution of correlations between
all metagenes and all traits for `r tissue.name`.

### Global Color Scale {.tabset .tabset-fade .tabset-pills}

#### Body Weight

```{r metagene_cor_maps, fig.width = 10, fig.height = 9}
plot_metagene_cor <- function(pheno.metagene.cor, pheno.mat, global.color.scale = TRUE){
  min.cor <- min(unlist(pheno.metagene.cor))
  max.cor <- max(unlist(pheno.metagene.cor))

  layout.mat <- get.layout.mat((length(pheno.metagene.cor)+1))

  layout(layout.mat)
  par(mar = c(0,0,4,0))
  for(m in 1:length(pheno.metagene.cor)){
    imageWithText(pheno.metagene.cor[[m]], use.pheatmap.colors = TRUE, 
    show.text = FALSE, global.color.scale = global.color.scale, 
    global.min = min.cor, global.max = max.cor, main = colnames(pheno.mat)[m])
  }
  par(mar = c(0,4,4,4))
  imageWithTextColorbar(matrix(segment_region(min.cor, max.cor, 10), ncol = 1), 
    use.pheatmap.colors = TRUE, cex = 1, global.color.scale = global.color.scale,
    global.min = min.cor, global.max = max.cor)
}
```

```{r bw_cor_global}
plot_metagene_cor(bw.metagene.cor, adj.bw)
```


#### Chemistry

```{r chem_cor_global}
plot_metagene_cor(chem.metagene.cor, adj.chem)
```



### Individual Color Scale {.tabset .tabset-fade .tabset-pills}

#### Body Weight

```{r bw_cor_local}
plot_metagene_cor(bw.metagene.cor, adj.bw, global.color.scale = FALSE)
```


#### Chemistry

```{r chem_cor_local}
plot_metagene_cor(chem.metagene.cor, adj.chem, global.color.scale = FALSE)
```


## Gene Set Correlations {.tabset .tabset-fade .tabset-pills}

The following code looks for gene sets with maximal correlations with clinical
phenotypes. Here we plot the top and bottom 10 processes associated with each
trait.

```{r gsz_cor}
gsz <- env$samples.GSZ.scores

gene_set_cor <- function(pheno.mat){
  common.ind <- intersect(colnames(gsz), rownames(pheno.mat))
  gsz.locale <- match(common.ind, colnames(gsz))
  pheno.locale <- match(common.ind, rownames(pheno.mat))

  gsz.cor.mat <- matrix(NA, nrow = nrow(gsz), ncol = ncol(pheno.mat))
  rownames(gsz.cor.mat) <- rownames(gsz)
  colnames(gsz.cor.mat) <- colnames(pheno.mat)

  for(m in 1:ncol(pheno.mat)){
    gsz.cor.mat[,m] <- apply(gsz[,gsz.locale], 1, 
      function(x) cor(pheno.mat[pheno.locale,m], x, use = "pairwise.complete.obs"))
  }
  return(gsz.cor.mat)
}

plot_top_cor <- function(gsz.cor.mat, pheno.mat){
  cor.min <- min(gsz.cor.mat, na.rm = TRUE)
  cor.max <- max(gsz.cor.mat, na.rm = TRUE)
  all.top.cor <- vector(mode = "list", length = ncol(pheno.mat))
  names(all.top.cor) <- colnames(pheno.mat)
  for(ph in 1:ncol(gsz.cor.mat)){
    if(is.interactive){quartz()}
    cat("####", colnames(pheno.mat)[ph], "\n")
    sorted.cor <- sort(gsz.cor.mat[,ph])
    top.cor <- c(head(sorted.cor, 10), tail(sorted.cor, 10))
    all.top.cor[[ph]] <- top.cor
    par(mar = c(4, 18, 4, 2))
    barplot(top.cor, las = 2, horiz = TRUE, cex.names = 0.7, main = colnames(pheno.mat)[ph],
    xlab = "Correlation", xlim = c(cor.min, cor.max))
    all.top.cor[[ph]] <- top.cor
    cat("\n\n")
  }
  return(all.top.cor)
}
```

### Body Weight {.tabset .tabset-fade .tabset-pills}

```{r bw_gene_sets, results = "asis"}
bw.gene.sets <- gene_set_cor(adj.bw)
bw.top.cor <- plot_top_cor(bw.gene.sets, adj.bw)
```

### Blood Chemistry {.tabset .tabset-fade .tabset-pills} 

```{r chem_gene_sets, results = "asis"}
chem.gene.sets <- gene_set_cor(adj.chem)
chem.top.cor <- plot_top_cor(gsz.cor.mat = chem.gene.sets, adj.chem)
```


## Trait-Process Correlation Heatmap {.tabset .tabset-fade .tabset-pills}

The following code generates a heatmap showing the top processes 
associated with all traits. This plot and a box plot of this 
matrix can be found in the SOM results folder. 

```{r process_cor, fig.height = 20, fig.width = 9}
top_cor_heatmap <- function(gene.set.cor.mat, top.cor, file.label = "results"){
  u_processes <- unique(unlist(lapply(top.cor, function(x) names(x))))
  process.locale <- match(u_processes, rownames(gene.set.cor.mat))
  
  pdf(here("Results", "SOM", paste0("Top_Processes_", tissue.name, "_", file.label, ".pdf")), 
  width = 7, height = 20)

  if(ncol(gene.set.cor.mat) == 1){cluster_cols = FALSE}else{cluster_cols = TRUE}  
  pheatmap(gene.set.cor.mat[process.locale,], cluster_cols = cluster_cols)

  process.order <- order(rowMeans(gene.set.cor.mat[process.locale,,drop=FALSE]))

  par(mar = c(4, 15, 2, 2))
  boxplot(t(gene.set.cor.mat[process.locale[process.order],]), horizontal = TRUE, las = 2,
  cex.axis = 0.5, main = "Top Correlated Processes")
  abline(v = 0)
  dev.off()
}
```

```{r plot_top_processes}
if(is.interactive){
  top_cor_heatmap(bw.gene.sets, bw.top.cor, "BW")
  top_cor_heatmap(chem.gene.sets, chem.top.cor, "Chem")
}
```

## Clustered Metagenes

The SOM clusters metagenes into clusters using k-means clustering. 
Neighboring metagenes are very highly correlated with each other. 
The clustering of metagenes allows us to reduce the dimentionality 
even more. 

The barplot below shows the number of genes in each of the K-means 
clusters. They are remarkably even in size.

```{r metagenes, fig.width = 9, fig.height = 5}
kmeta <- env$spot.list.kmeans$spots
cluster.sizes <- sapply(kmeta, function(x) length(x$genes))
barplot(cluster.sizes)
```

## Metagene Cluster Trends {.tabset .tabset-fade .tabset-pills}

Here we look at correlation matrices for clustered metagenes. We find all the 
metagenes in a single cluster and decompose the cluster using SVD. We then
use the first principle component of the metagene matrix as the clustered
metagene. We calculated the correlation of each of these clustered metagenes
to the clinical traits, and scanned each. 

The correlations with the traits are very comparable to WGCNA eigengene
correlations with traits. The mapping is also par with mapping of other 
gene modules. Maybe a little better.

```{r metagene_clusters, warning = FALSE}

eig_genes <- function(pheno.mat, expr.mat){
  metagenes <- env$metadata
  kmeans <- env$spot.list.kmeans
  kmap <- kmeans$overview.map
  u_k <- sort(unique(as.vector(kmap)))

  #matrix for keeping correlations between eigenegenes and traits
  k.gene.cor <- matrix(NA, nrow = length(u_k), ncol = ncol(pheno.mat))
  rownames(k.gene.cor) <- names(kmeans$spots)
  colnames(k.gene.cor) <- colnames(pheno.mat)

  #matrix for keeping eigengene values for each individual
  #The individuals in this matrix are indexed using the 
  #trait matrix
  k.gene.mat <- matrix(NA, nrow = nrow(pheno.mat), ncol = length(u_k))
  colnames(k.gene.mat) <- names(kmeans$spots)
  rownames(k.gene.mat) <- rownames(pheno.mat)

  #identify individuals with both expression and traits
  common.ind <- intersect(rownames(pheno.mat), colnames(metagenes))
  pheno.locale <- match(common.ind, rownames(pheno.mat))
  expr.locale <- match(common.ind, rownames(expr.mat))

  for(k in 1:length(u_k)){

    #get the gene names included in the kth metagene
    k.genes <- kmeta[[k]]$genes

    #use svd to decompose the gene expression in expression space
    #if there are genes not in this dataset, there is probably a tissue mismatch
    #all genes from the expression matrix should be present in the metagenes
    #and vice versa
    #plot.decomp(expr.mat[expr.locale,k.genes])
    k.gene.decomp <- plot.decomp(expr.mat[expr.locale,k.genes], plot.results = FALSE)

    k.gene.mat[k.gene.decomp$rows.used,k] <- k.gene.decomp$u[,1]
    #k.cor <- apply(adj.pheno[pheno.locale,], 2, function(x) cor(x, k.gene[metagene.locale], use = "pairwise.complete.obs"))
    k.cor <- apply(pheno.mat[pheno.locale,,drop=FALSE], 2, 
      function(x) cor(x, k.gene.mat[,k], use = "pairwise.complete.obs"))
    #plot.with.model(pheno.mat[pheno.locale,1,drop=FALSE], k.gene.mat[expr.locale,])
    k.gene.cor[k,] <- k.cor
  }
  result <- list("k.eigengene.mat" = k.gene.mat, "k.cor" = k.gene.cor)
  return(result)
}
```

### Body Weight

```{r bw_gene_eig, fig.width = 7, fig.height = 6}
bw.eig.gene <- eig_genes(adj.bw, adj.expr)
barplot_with_num(round(bw.eig.gene$k.cor[,1], 2), text.srt = 90)
```

### Chemistries 

```{r chem_gene_eig, fig.height = 6, fig.width = 6}
chem.eig.gene <- eig_genes(adj.chem, adj.expr)
pheatmap(chem.eig.gene$k.cor, display_numbers = TRUE)
```

## Contrasts

Here we look for metagenes that vary by group status,
for example, sex, diet, or treatment.

```{r contrasts}
group.mat <- t(sapply(strsplit(groups, "_"), function(x) x))
colnames(group.mat) <- c("Sex", "Diet", "Treatment")

contrast = "Sex"
contrast_labels <- unique(group.mat[,contrast])
contrast_groups <- lapply(contrast_labels, function(x) which(group.mat[,contrast] == x))

adj.mat <- group.mat[,-which(colnames(group.mat) == contrast)]
covar.mat <- dummy_covar(adj.mat)

#adjust the traits and transcripts for the remaining factors,
#so we can isolate the effects of the treatment of interest
contrast_bw <- adjust(adj.bw, covar.mat)
contrast_chem <- adjust(adj.chem, covar.mat)
contrast_expr <- adjust(adj.expr, covar.mat)

test.gene.sets <- gene_set_cor(contrast_bw)
test.top.cor <- plot_top_cor(test.gene.sets, contrast_bw)
top_cor_heatmap(test.gene.sets, test.top.cor, paste("BW_contrast", contrast, sep = "_"))

test.gene.sets <- gene_set_cor(contrast_chem)
test.top.cor <- plot_top_cor(test.gene.sets, contrast_chem)
top_cor_heatmap(test.gene.sets, test.top.cor, paste("Chem_contrast", contrast, sep = "_"))

```