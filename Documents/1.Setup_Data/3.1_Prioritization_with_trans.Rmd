---
title: "Prioritize with trans eQTL"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
The purpose of this workflow is to use TRiAGE to prioritize
plausible causal candidates in QTLs that map to traits and 
are trans bands, like the Chr 11 QTL.

We are also interested in whether the first PC of the trans
band is correlated with any of the traits.
    
The network used is the same as the specified tissue. 


```{r get_args}
args <- commandArgs(trailingOnly=T)
tissue.name = args[1]
n.cores <- as.numeric(args[2])

if(is.na(tissue.name)){
    tissue.name = "Adipose"
    n.cores = 4
}

#delete_previous <- TRUE
delete_previous <- FALSE

network.names <- c("Adipose" = "adipose tissue", 
                    "Islet" = "islets of langerhans", 
                    "Liver" = "liver", 
                    "SkeletalMuscle" = "skeletal muscle")

network.name = network.names[which(names(network.names) == tissue.name)]

trait.name = "Ins_tAUC"
qtl.chr = 11

exp.name = paste0(tissue.name, "_Chr", qtl.chr, "_Trans")
project.name = "Chr11_Trans"
Mb.buffer = 1
```

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

data.dir <- here("Results", "CCA_Clusters", "all_traits")
results.dir <- here("Results", "Prioritization", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
devtools::install_github("wesleycrouse/bmediatR", build_vignettes = TRUE)

needed.libraries <- c("Matrix", "knitr", "here", "igraph", "DescTools", "pheatmap", 
"e1071", "parallel", "doParallel", "gprofiler2", "DT", "qtl2", "XML", "RCurl", 
"R.utils", "bmediatR") 

load_libraries(needed.libraries, personal.library = TRUE)
```


```{r load_data}
tissue.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
traits <- as.matrix(read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE))
num.traits <- apply(traits[,c(12:(ncol(traits)-1))], 2, as.numeric)
rownames(num.traits) <- traits[,1]

data.set <- get(paste0("dataset.DO.Cube.", tissue.name))
covar.mat <- data.set$covar.matrix
expr.data <- data.set$data$norm

adj.expr <- adjust(expr.data, covar.mat)
adj.pheno <- adjust(num.traits, covar.mat)

gene.table <- data.set$annot.mrna
eqtl.table <- data.set$lod.peaks$additive
```

The figure below shows the genetic mapping of `r trait.name`.
We define the QTL as the area between the red lines. We are
using a pretty broad definition of the QTL to make sure we 
capture all relevant trans-regulated transcripts.

```{r get_plot_idx}
#finds the x position of a mapping position on an
#existing QTL plot or the full genome.

get_plot_idx <- function(map, chr, Mb){
    full.map <- length(unlist(map))
    pt.marker <- find_marker(map, chr = chr, pos = Mb)
    idx <- which(unlist(lapply(map, names)) == pt.marker)
    plot.dim <- par("usr")
    x.coord <- (idx/full.map)*plot.dim[2]
    return(x.coord)
}

```

```{r trait_scan, fig.width = 8, fig.height = 5}
trait.scan <- scan1(genoprobs, adj.pheno[,trait.name], kinship = K)
peak.table <- find_peaks(trait.scan, map = map, threshold = 6, drop = 6)
chr.locale <- which(peak.table[,"chr"] == qtl.chr)
chr.peak <- peak.table[chr.locale,]
qtl.start <- (floor(chr.peak[,"ci_lo"])-Mb.buffer)*1e6
qtl.end <- (ceiling(chr.peak[,"ci_hi"])+Mb.buffer)*1e6

plot(trait.scan, map = map)
qtl.start.x <- get_plot_idx(map, chr = 11, Mb = qtl.start/10^6)
qtl.end.x <- get_plot_idx(map, chr = 11, Mb = qtl.end/10^6)
abline(v = c(qtl.start.x, qtl.end.x), col = "red", lwd = 2)
```

We identified all transcripts that map to this interval using
the data in the QTLviewer object.

```{r interval_transcripts}
eqtl.markers <- strsplit(eqtl.table[[2]], "_")
eqtl.chr <- sapply(eqtl.markers, function(x) x[1])
eqtl.pos <- as.numeric(sapply(eqtl.markers, function(x) x[2]))
chr.idx <- which(eqtl.chr == chr.peak[,"chr"])
above.min <- which(eqtl.pos >= qtl.start)
below.max <- which(eqtl.pos <= qtl.end)
trans.idx <- Reduce("intersect", list(chr.idx, above.min, below.max))

trans.table <- eqtl.table[trans.idx,]
```

We removed the transcripts that are located in the trait QTL.
We don't want to spike our gene list with local genes.

```{r remove_cis}
chr.locale <- which(gene.table[[4]] == chr.peak[,"chr"])
above.min <- which(gene.table[[5]]*10^6 >= qtl.start)
below.max <- which(gene.table[[6]]*10^6 <= qtl.end)
cis.idx <- Reduce("intersect", list(chr.locale, above.min, below.max))
cis.transcripts <- unique(gene.table[cis.idx,][[1]])

cis.locale <- which(trans.table[[1]] %in% cis.transcripts)
trans.locale <- setdiff(1:nrow(trans.table), cis.locale)
trans.table <- trans.table[trans.locale,]
```

There are `r nrow(trans.table)` trans targets in this locus.

The positions of eQTL markers for these genes is shown below.

```{r eqtl, width = 10, height = 5}
split.marker <- strsplit(trans.table$marker.id, "_")
marker.pos <- as.numeric(sapply(split.marker, function(x) x[2]))
a <- hist(marker.pos/1e6, breaks = 50, plot = FALSE)
plot.new()
plot.window(xlim = c(min(a$mids), max(a$mids)), ylim = c(0, max(a$counts)))
points(a$mids, a$counts, type = "h", lwd = 20, col = "lightgray")
text(a$mids, a$counts, labels = a$counts)
axis(1);axis(2)
mtext("Position (Mb)", side = 1, line = 2.5)
mtext("Number of Trans Targets", side = 2, line = 2.5)
abline(v = peak.table[1,"pos"])
text(x = peak.table[1,"pos"], y = max(a$counts), labels = "Peak Trait QTL", adj = 0)
```

The functional enrichment of the trans-regulated genes
is shown below.

```{r trans_enrich, fig.width = 7, fig.height = 7}
enrichment <- gost(trans.table$gene.id, organism = "mmusculus")
plot.enrichment(enrichment, num.terms = 25, plot.label = 
    "Enrichment of trans band targets", max.term.size = 5000)
```

The allele effects of all transcripts in this region
are shown below. There are small groups of transcripts
that share allele effects. The F and G alleles have
the most consistent effects across transcripts.

```{r allele_effects}
allele.effects <- as.matrix(trans.table[,LETTERS[1:8]])
pheatmap(allele.effects, scale = "row")
#allele.cor <- cor(t(allele.effects))
#pheatmap(allele.cor)
```

The figure below shows the first four PCs of the trans-regulated
gene expression matrix plotted against each other. Each dot represents
an individual anima. In some cases there are strange clusters of 
individuals. Further investigation has revealed that these clusters
tend to be related to pseudogenes that have expression patterns that
have very divergent from the rest of the transcripts. 

```{r trans_expr, fig.height = 8, fig.width = 8}
trans.id <- unique(trans.table[[1]])
trans.info <- gene.table[match(trans.id, gene.table[[1]]),]
trans.expr <- adj.expr[,trans.id] 
matched.mats <- get.xz(trans.expr, adj.pheno)
trans.decomp <- plot.decomp(matched.mats$X, pc = 6)
#pheatmap(matched.mats$X)
```

In TRiAGE we only use protein coding genes with entrez IDs.
If we filter to only those genes here, most of the strainge
clustering patterns disappear. 


```{r filter_entrez, fig.height = 8, fig.width = 8}
entrezgene <- gconvert(trans.id, organism = "mmusculus", target = "ENTREZGENE_ACC")
triage.id <- entrezgene[,"input"]

trans.expr <- adj.expr[,triage.id] 
matched.mats <- get.xz(trans.expr, adj.pheno)
trans.decomp <- plot.decomp(matched.mats$X, pc = 6)
```

We asked whether the PCs of the trans-regulated 
transcripts were correlated with `r trait.name`.
This varied by tissue. Adipose expression was
the most highly correlated with `r trait.name`.


```{r pc_trait_cor, fig.width = 8, fig.height = 6}
if(is.interactive){quartz(width = 8, height = 6)}
par(mfrow = c(2,3))
for(i in 1:ncol(trans.decomp$u)){
    plot.with.model(trans.decomp$u[,i], matched.mats$Z[,trait.name], 
    xlab = paste("PC", i), ylab = trait.name, main = paste("PC", i))
}
```

The transcripts have somewhat correlated expression, which
we would expect if they are all regulated by a single locus
in trans. Sub clusters may represent multiple QTL in the region
or shared haplotype effects, like the CAST and PWK allele effects 
we saw above.

```{r expr_decomp, fig.height = 7, fig.width = 7}
pheatmap(cor(matched.mats$X), show_rownames = FALSE, show_colnames = FALSE)
```

We used these transcripts to train SVMs to classify genes 
related to these transcripts. The following text explains 
this process.

```{r download_net, eval = TRUE, echo = FALSE}
#Download the network if it hasn't been previously downloaded. 
#full list available at:  http://fntm.princeton.edu
tissue.type = gsub(" ", "_", network.name)
net.file <- here("Data", paste0(tissue.type, "_top.RData"))
if(!file.exists(net.file)){
    download.tissue.net(tissue.type, organism = "mouse", top.edges.only = TRUE, 
    project.dir = here("Data"))
    }
```

```{r read_net, echo = FALSE}
#Read in the downloaded network.
all.var <- ls()
net.loaded <- as.logical(length(which(all.var == "tissue.net")))
if(!net.loaded){
    tissue.net <- readRDS(net.file)
}
```

## Setup Positive-Labeled Gene Features

Get the connection weights of the positive-labeled genes to each other
in the tissue network. Positive-labeled genes that are not connected 
to any other positive-labeled genes are removed from the analysis.


```{r pick_genes, echo = FALSE}
tissue.adj <- tissue.adj.mat(tissue.net, entrezgene[,"target"], inc.all.genes = FALSE)
```

After identifying all Entrezgene IDs and building the positive-labeled network,
we have `r nrow(tissue.adj)` positive-labeled genes for training.

## Train SVM
We used this positive-labeled network as features to train 100 SVMs to classify
TB- and not TB-related genes. In each of the 100 SVMs, we selected a balanced
set of unlabeled genes for training. We write each of the trained models to a 
file for further analysis.

```{r train_models, message = FALSE, warning = FALSE, error = FALSE, eval = TRUE}
generate.triage.models(path = results.dir, project.name = project.name, 
trait.genes = entrezgene[,"target"], fgn = tissue.net, n.trials = 100, 
cluster.modules = FALSE, cluster.threshold = 700, max.cluster.size = 600, 
min.cluster.size = 10, use.SVD = FALSE, verbose = TRUE, n.cores = n.cores)
```

## ROC Curves

We calculated ROC curves for each SVM, as well as the overal AUC for
the group. The plot below shows the ROC curves for all 100 models
along with the average AUC.

```{r roc, fig.height = 5, fig.width = 5}
all.fptp <- svm.ROC(results.dir, n.cores = n.cores, plot.results = TRUE)
all.auc <- sapply(all.fptp, function(x) smooth.auc(Reduce("rbind", x), plot = FALSE))
```

## Score all genes

We then used the trained models to classify genes that are encoded
in the QTL for `r trait.name` and expressed in `r tissue.name`.


```{r score_genes}
chr.locale <- which(gene.table$chr == qtl.chr)
mb.locale <- intersect(which(as.numeric(gene.table$start)*10^6 >= qtl.start), 
            which(as.numeric(gene.table$end)*10^6 <= qtl.end))
candidate.locale <- intersect(chr.locale, mb.locale)
candidate.id <- gene.table$gene.id[candidate.locale]
candidate.entrez <- gconvert(candidate.id, organism = "mmusculus", target = "ENTREZGENE_ACC")

score.candidates(results.dir, 
    candidate.genes = as.numeric(candidate.entrez[,"target"]),
    verbose = TRUE, plot.results = FALSE)

entrez.idx <- match(candidate.entrez[,"input"], gene.table$gene.id)
gene.info.mat <- as.matrix(gene.table[entrez.idx,])
#head(cbind(gene.info.mat[,1], candidate.entrez[c("input", "name")]))
candidate.entrez.id <- candidate.entrez[,"target",drop=FALSE]
colnames(candidate.entrez.id) <- "entrezgene_id"
gene.info.mat <- cbind(gene.info.mat, candidate.entrez.id)

merge.svm.gene.info(results.dir, gene.info.table = gene.info.mat,
    entrezgene.column = "entrezgene_id", gene.start.column = "start",
	gene.end.column = "end", gene.name.column = "symbol")
```

The following plot shows the mean SVM score for expressed genes
across the trait QTL.

```{r svm_fig, results = "asis"}
svm.image.path <- file.path(results.dir, project.name, "Module1", "Candidate.Gene.SVM.Results.jpg")
image.line <- paste0("![Mean SVM Scores](", svm.image.path, ")")
cat(image.line, "\n")
```

The following image shows the mean false positive rate across 
all expressed genes in the trait QTL. This may differ from the
mean SVM score shown above because both are means taken independently
and vary across SVM runs.

```{r get_fp, error = FALSE, warning = FALSE, message = FALSE, fig.width = 10, fig.height = 5}
fp.mat <- get.all.fp(results.dir, gene.name.column = "symbol")
cand.pos <- gene.table$start[match(rownames(fp.mat), gene.table$symbol)]

layout(matrix(c(1,2), ncol = 2), widths = c(1, 0.2))
par(mar = c(4,4,4,0))
plot.new()
plot.window(xlim = c(min(cand.pos/1e6, na.rm = TRUE), max(cand.pos/1e6, na.rm = TRUE)), 
    ylim = c(min(-log10(fp.mat), na.rm = TRUE), max(-log10(fp.mat), na.rm = TRUE)))
for(i in 1:ncol(fp.mat)){
    points(cand.pos/1e6, -log10(fp.mat[,i]), pch = 16, col = i)
    text(cand.pos/1e6, -log10(fp.mat[,i]), rownames(fp.mat), pos = 2, col = i)
}
axis(1);axis(2)
mtext(side = 1, paste("Chr", qtl.chr, "position (Mb)"), line = 2)
mtext(side = 2, "Functional Score", line = 2)
abline(h = -log10(0.05))
par(mar = c(0,0,0,0))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))
par(xpd = NA)
legend(x = -1, y = 1, legend = colnames(fp.mat), col = 1:ncol(fp.mat), lty = 1, lwd = 2)
par(xpd = TRUE)
```



## Mediation

The following code can be run by hand to check whether 
a candidate gene is a mediator of either the trans band
or the trait.

```{r check_gene, eval = FALSE}

gene.name = "Heatr6"
gene.name = "Ccdc92b"


gene.idx <- which(gene.table$symbol == gene.name)
gene.id <- gene.table$gene.id[gene.idx]

plot.with.model(adj.pheno[,trait.name], adj.expr[,gene.id], xlab = gene.name,
    ylab = trait.name)

nearest.marker <- gene.table$nearest.marker.id[gene.idx]
nearest.geno <- genoprobs[[11]][rownames(adj.expr),,nearest.marker]


trait_med <- bmediatR(
    y = adj.pheno[,trait.name,drop=FALSE], 
    M = adj.expr[,gene.id,drop=FALSE], 
    X = cbind(rep(1, nrow(nearest.geno)), nearest.geno),
    ln_prior_c = "reactive",
    options_X = list(sum_to_zero = TRUE, center = FALSE, scale = FALSE))

plot_posterior_bar(trait_med, mediator_id = gene.id, relabel_x = gene.name, 
    main = paste(gene.name, "mediating trait in", tissue.name), 
    med_var = "transcript.id")

trans.pc <- trans.decomp$u
rownames(trans.pc) <- rownames(matched.mats$X)
colnames(trans.pc) <- paste0("PC", 1:ncol(trans.pc))

trans_med <- bmediatR(
    y = trans.pc[,1,drop=FALSE], 
    M = adj.expr[,gene.id,drop=FALSE], 
    X = cbind(rep(1, nrow(nearest.geno)), nearest.geno),
    ln_prior_c = "reactive",
    options_X = list(sum_to_zero = TRUE, center = FALSE, scale = FALSE))

plot_posterior_bar(trans_med, mediator_id = gene.id, relabel_x = gene.name, 
    main = paste(gene.name, "Mediating trans band in", tissue.name), 
    med_var = "transcript.id")

#does the trans band mediate the effect of the peak marker on the trait?

nearest.marker <- find_marker(map, chr = peak.table[1,"chr"], pos = peak.table[1,"pos"]) 
nearest.geno <- genoprobs[[11]][rownames(adj.expr),,nearest.marker]

pc = 1
common.ind <- Reduce("intersect", list(rownames(adj.pheno), rownames(trans.pc), rownames(genoprobs[[1]])))

plot.with.model(trans.pc[common.ind,pc], adj.pheno[common.ind, trait.name])
adj.pc <- adjust(trans.pc[,1,drop=FALSE], nearest.geno)
adj.trait <- adjust(adj.pheno[,trait.name,drop=FALSE], nearest.geno)
plot.with.model(adj.pc[common.ind,], adj.trait[common.ind,])

trans_trait_med <- bmediatR(
    y = adj.pheno[common.ind,trait.name,drop=FALSE], 
    M = trans.pc[common.ind,1,drop=FALSE],
    X = nearest.geno[common.ind,],
    ln_prior_c = "reactive",
    options_X = list(sum_to_zero = TRUE, center = FALSE, scale = FALSE))

plot_posterior_bar(trans_trait_med, mediator_id = paste0("PC", pc), 
    relabel_x = paste("Trans band PC", pc), 
    main = "Trans Band Mediation of Peak Marker on Trait")

#post <- get_posterior(trans_trait_med, mediator_id = paste0("PC", pc), 
#    relabel_x = paste("Trans band PC", pc), 
#    main = "Trans Band Mediation of Peak Marker on Trait")
#par(mar = c(10, 4, 4, 4))
#barplot(post[,"post_p"], names = post[,"model"], las = 2)
```

```{r bulk_med}

med <- function(y, M, X, model.type = "reactive"){

    test_med <- bmediatR(y = y, M = M, X = X, ln_prior_c = model.type,
        options_X = list(sum_to_zero = TRUE, center = FALSE, scale = FALSE))

    post <- get_posterior(test_med)
    post.prob <- post[,"post_p"]
    names(post.prob) <- post[,"model"]
    return(post.prob)
}

sink(file.path(results.dir, "mediator_log.txt"))

trans.pc <- trans.decomp$u
rownames(trans.pc) <- rownames(matched.mats$X)
colnames(trans.pc) <- paste0("PC", 1:ncol(trans.pc))

common.ind <- Reduce("intersect", list(rownames(trans.pc), 
    rownames(genoprobs[[1]]), rownames(adj.expr)))

#mediate the trans band with each of the cis transcripts using bmediatR
cis.names <- gene.table$symbol[match(cis.transcripts, gene.table$gene.id)]
all.cis.trans.med <- matrix(NA, ncol = 6, nrow = length(cis.transcripts))
rownames(all.cis.trans.med) <- cis.names
for(i in 1:length(cis.transcripts)){
    cis.idx <- which(gene.table$gene.id == cis.transcripts[i])
    cis.expr <- adj.expr[,cis.transcripts[i],drop=FALSE]
    nearest.marker <- gene.table$nearest.marker.id[cis.idx]
    nearest.geno <- genoprobs[[11]][,,nearest.marker]
    med.post <- med(trans.pc[common.ind,1], cis.expr[common.ind,1],
        nearest.geno[common.ind,], "reactive")
    all.cis.trans.med[i,] <- med.post
}
colnames(all.cis.trans.med) <- names(med.post)
#pheatmap(all.cis.trans.med, cluster_cols = FALSE, show_rownames = FALSE)

#comp.trans.med <- which(all.cis.trans.med[,1] >= 0.8)
#cat(names(comp.med), sep = "\n")
#comp.trans.react <- which(all.cis.trans.med[,4] >= 0.8)
#cat(names(comp.react), sep = "\n")

#mediate the trait with each of the cis transcripts using bmediatR
all.cis.trait.med <- matrix(NA, ncol = 6, nrow = length(cis.transcripts))
rownames(all.cis.trait.med) <- cis.names
for(i in 1:length(cis.transcripts)){
    cis.idx <- which(gene.table$gene.id == cis.transcripts[i])
    cis.expr <- adj.expr[,cis.transcripts[i],drop=FALSE]
    nearest.marker <- gene.table$nearest.marker.id[cis.idx]
    nearest.geno <- genoprobs[[11]][,,nearest.marker]
    med.post <- med(adj.pheno[common.ind,trait.name], cis.expr[common.ind,1],
        nearest.geno[common.ind,], "reactive")
    all.cis.trait.med[i,] <- med.post
}
colnames(all.cis.trait.med) <- names(med.post)
#pheatmap(all.cis.trait.med, cluster_cols = FALSE)
sink()


#comp.trait.med <- which(all.cis.trait.med[,1] >= 0.8)
#cat(names(comp.med), sep = "\n")
#comp.trait.react <- which(all.cis.trait.med[,4] >= 0.8)
#cat(names(comp.react), sep = "\n")

med.ranks <- rank.2D(cbind(all.cis.trans.med[,1,drop=FALSE], all.cis.trait.med[,1,drop=FALSE]))
ordered.med <- med.ranks[order(med.ranks[,1]),1,drop=FALSE]
```

The following plot shows the posterior probabilites of each local 
gene mediating the trait plotted against the posterior probability 
of each local gene mediating the transcript. The top ranked genes
are labeled.


```{r med_against}
top.genes <- rownames(ordered.med)[1:25]
plot(all.cis.trans.med[,1], all.cis.trait.med[,1], xlim = c(0, 1), ylim = c(0, 1.05),
    xlab = "Post. Prob. of Mediating Trans Band", ylab = "Post. Prob. of mediating Trait")
text(all.cis.trans.med[top.genes,1], all.cis.trait.med[top.genes,1], labels = top.genes, pos = 3)
```

The following plots shows the posterior probabilities of mediating either
the trait or the trans bands as a function of the position in the locus. 
The peak trait locus is marked with a vertical line. A posterior probability
of 0.8 is marked with a horizontal line.

```{r trait_by_pos, fig.width = 10, fig.height = 6}
gene.pos <- gene.table$start[match(cis.names, gene.table$symbol)]

plot(gene.pos, all.cis.trans.med[,1], main = "Tran-band mediators", 
    ylab = "Post. Prob. of Complete Mediation")
text(gene.pos, all.cis.trans.med[,1], cis.names, cex = 0.5, pos = 4)
abline(v = peak.table[1,"pos"], h = 0.8)

plot(gene.pos, all.cis.trait.med[,1], main = "Trait mediators",
    ylab = "Post. Prob. of Complete Mediation")
text(gene.pos, all.cis.trait.med[,1], cis.names, cex = 0.5, pos = 4)
abline(v = peak.table[1,"pos"], h = 0.8)

```