---
title: "Clustering transcripts with CCA"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow explores the possibility of using CCA to transcript clusters
that correlate with specific traits. We will be playing around a lot with 
different trait inputs. In the first code chunk, set the traits analyzed
along with an experiment name for keeping results from different runs 
separate.


```{r get_args}
args <- commandArgs(trailingOnly=T)
exp.name = args[1]
delete_previous <- as.logical(args[2])

if(is.na(exp.name)){
    #exp.name <- "imputed_full"
    exp.name <- "imputed_local"
    #exp.name = "all_traits"
    #exp.name <- "weight_adjusted"
    #delete_previous <- TRUE
    delete_previous <- FALSE
}

#cca parameters
nperms = 100 #number of permutations to do in penalized CCA to determine optimal penalties
n.bootstraps = 100 #number of bootstraps to perform to stabilize CCA estimates
pval.thresh = 0.05 #maximum p value for selecting useful penalty combinations
cor.diff.thresh = 0.4 #minimum difference in canonical correlation between data and null for selecting useful penalty combinations

#qtl overlap parameters
lodthresh = 5.5 #Minimum LOD score for a QTL we will examine
peak.dist <- 2 #maximum distance in MB for overlapping QTL
perc.drop.thresh = 0.75 #fraction of full LOD score mediated LOD score needs to be to be investigated further

use.imputed <- as.logical(length(grep("imputed", exp.name)))
```

The results shown here pertain to `r exp.name`.

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "CCA_Clusters", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "cape", "PMA", "abind", "cluster",
"RColorBrewer", "igraph", "corpcor", "easyPubMed", "knitr", "kableExtra",
"ape", "wordcloud", "wordcloud2")
run.simplify.enrichment = FALSE
#library("simplifyEnrichment");run.simplify.enrichment = TRUE
load_libraries(all.packages, personal.library = TRUE)
data(CCcolors)
```

Read in pre-filtered and pre-adjusted transcript data from 
adjust_transcripts_traits.Rmd

```{r read_data}
pheno.file <- here("Data", "Adjusted_Phenotypes.RDS")
cca.pheno <- readRDS(pheno.file)
cca.pheno <- adjust(cca.pheno[,2:ncol(cca.pheno)], cca.pheno[,1,drop=FALSE]) #regress out diet days
#rankZ normalize
cca.pheno <- apply(cca.pheno, 2, rankZ)
num.components <- ncol(cca.pheno)

if(use.imputed){
    tissue.adj.expr <- readRDS(here("Data", "imputed", paste0("Adjusted_Expression_", exp.name, ".RDS")))
}else{   
    tissue.adj.expr <- readRDS(here("Data", paste0("Adjusted_Expression_", exp.name, ".RDS")))
}
names(tissue.adj.expr) <- c("Adipose", "Islet", "Liver", "SkeletalMuscle")
tissue.names <- names(tissue.adj.expr)

tissue.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
data.set.names <- lapply(1:length(tissue.names), 
function(x) paste0("dataset.DO.Cube.", tissue.names[x]))
gene.table <- as.matrix(unique(Reduce("rbind", lapply(data.set.names, 
    function(x) get(x)$annot.mrna))))
```


## Trait Correlation

The following heatmap shows the correlations between pairs of traits
after adjusting for covariates, and any specified traits, such as 
weight. The traits were also scaled prior to calculating correlations.

```{r pheno_cor, fig.height = 6, fig.width = 6}
trait.order <- hclust(dist(t(cca.pheno)))$order
layout(matrix(c(1,2), ncol = 2), widths = c(0.8, 0.2))
par(mar = c(8, 8, 2, 2))

pheatmap(cor(cca.pheno, use = "pairwise.complete.obs")[trait.order, trait.order],
cluster_rows = FALSE, cluster_cols = FALSE)
```

## Trait Partial Correlation

We also looked at the partial correlation of all pairs of variables.
To do this, we used pcor.shrink from corpcor.

The heat map below shows the full partial correlation matrix. It is
dominated by the ex vivo insulin traits. WPIC is basically perfectly
correlated with both insulin per islet and the number, as you might
imagine. Insulin per islet is perfectly negatively correlated with 
number of islets. So as there are fewer islets, each one secretes 
more insulin.

```{r par_cor, fig.height = 6, fig.width = 6}
test.decomp <- plot.decomp(cca.pheno, plot.results = FALSE)
not.num.islet <- which(colnames(cca.pheno) != "WPIC")
par.cor <- pcor.shrink(cca.pheno[test.decomp$rows.used,not.num.islet]) #take out WPIC, which is derived from num_islets and Ins_per_islet

trait.order <- hclust(dist(par.cor))$order
imageWithText(round(par.cor[trait.order,trait.order], 2), split.at.vals = TRUE, 
col.scale = c("blue", "brown"),grad.dir = "ends")
```

The heat map below shows the partial correlation traits with the
ex vivo traits removed so we can better see the other correlations.

This shows some potentially interesting patterns. 
Glu_tAUC and Ins_tAUC are negatively correlated. That is, the larger
your insulin response, the faster your glucose goes down. And the smaller 
your insulin response, the more slowly your glucose goes down. This is how 
it should be, I think. 

HOMA_IR, insulin resistance, is positively correlated with Glu_tAUC,
which makes sense. The more resistant you are, the slower your glucose
will go down. 

The plots below show the difference between the correlation and the
partial correlation for these two traits. They are positively correlated
in the trait matrix, but their partial correlation is negative.

```{r, cor_comp, fig.width = 8, fig.height = 4}
compare_corr <- function(trait1, trait2){
    trait1.idx <- which(colnames(cca.pheno) == trait1)
    trait2.idx <- which(colnames(cca.pheno) == trait2)

    if(is.interactive){quartz(width = 8, height = 4)}
    par(mfrow = c(1,2), xpd = FALSE)
    plot.with.model(cca.pheno[,trait1.idx], cca.pheno[,trait2.idx], 
        xlab = trait1, ylab = trait2, report = "cor.test", main = "Correlation")
    plot.par.cor(cca.pheno, trait1.idx, trait2.idx, main = "Partial Correlation")
}

compare_corr("Glu_tAUC", "Ins_tAUC")
```

HOMA_B, beta cell function, is negatively correlated with Glu_tAUC.
The worse your beta cell function, the less insulin you produce, and
the more slowly your glucose goes down.

```{r, cor_comp2, fig.width = 8, fig.height = 4}
compare_corr("HOMA_B_0min", "Glu_tAUC")
```

However, HOMA_IR and HOMA_B are still positively correlated. So beta 
cell function is still compensating for insulin resistance in this 
population.

```{r, cor_comp3, fig.width = 8, fig.height = 4}
compare_corr("HOMA_B_0min", "HOMA_IR_0min")
#compare_corr("HOMA_B_0min", "Glu_tAUC")
```

Weight at different times has different correlations with insulin.
There could be interesting causal relationships here in both directions.
But it's complicated.

Food intake is negatively correlated with insulin at 10 weeks, and
positively correlated with weight at 10 weeks. So more food is 
increasing weight, but potentially reducing islet function, and
reducing insulin production.

```{r par_cor_trimmed, fig.height = 7, fig.width = 7}
col.order <- hclust(dist(par.cor))$order
trimmed.par.cor <- par.cor
diag(trimmed.par.cor) <- NA
if(length(which(trimmed.par.cor < 0)) > 0 && length(which(trimmed.par.cor > 0)) > 0){
    imageWithText(trimmed.par.cor[col.order, col.order], split.at.vals = TRUE,
    col.scale = c("blue", "brown"), grad.dir = "ends", sig.digs = 2, col.text.shift = -1,
    row.text.shift = -1)
}else{
    imageWithText(trimmed.par.cor[col.order, col.order], split.at.vals = FALSE,
    sig.digs = 2, col.scale = "blue", cex = 1)
}
```

## Identify covariation in transcripts and traits using CCA

This is an experimental process. I want to see if we can use CCA 
to identify composite transcripts that are correlated with composite 
traits.

Get the X and Z matrices for putting into PMA.
X is the transcript matrix for the appropriate tissue, 
and Z is the trait matrix (traits, or ETs).

The function get.xz aligns the two matrices by individual.
If pheno_type is set to traits, use the trait matrix, if it is
set to eigentraits, use the eigentrait matrix.

We want to use a LASSO penalty to sparsify the transcriptome in each
tissue for ease of interpretation.

```{r tissue_xz}
matched.mats <- lapply(1:length(tissue.adj.expr), 
    function(x) get.xz(tissue.adj.expr[[x]], cca.pheno))
file.text <- "trait"
names(matched.mats) <- tissue.names
#saveRDS(matched.mats, file.path(results.dir, "Trait.Expression.Matched.RDS"))
```

```{r test_cor, eval = FALSE}
all.tissue.cor <- vector(mode = "list", length = length(matched.mats))
names(all.tissue.cor) <- names(matched.mats)
for(tx in 1:length(matched.mats)){
    cat(names(matched.mats)[tx], "\n")
    tissue.cor <- matrix(NA, ncol = ncol(matched.mats[[tx]]$Z), nrow = ncol(matched.mats[[tx]]$X))
    colnames(tissue.cor) <- colnames(cca.pheno)
    rownames(tissue.cor) <- colnames(matched.mats[[tx]]$X)
    for(tr in 1:ncol(matched.mats[[tx]]$Z)){
        report.progress(tr, ncol(matched.mats[[tx]]$Z))
        #tissue.cor[,tr] <- apply(matched.mats[[tx]]$X, 2, function(x) summary(lm(matched.mats[[tx]]$Z[,tr]~x))$r.squared)
        tissue.cor[,tr] <- apply(matched.mats[[tx]]$X, 2, function(x) cor(matched.mats[[tx]]$Z[,tr], x))
    }
all.tissue.cor[[tx]] <- tissue.cor
    cat("\n")
}

for(tx in 1:length(all.tissue.cor)){
    if(is.interactive){quartz(width = 10, height = 6)}
    boxplot(all.tissue.cor[[tx]], las = 2, main = names(all.tissue.cor)[tx])
}

pos.cor <- TRUE
trait.idx <- c(1,2,3)

for(tx in 1:length(all.tissue.cor)){
    comp.trait <- plot.decomp(matched.mats[[tx]]$Z[,trait.idx], plot.results = FALSE)$u[,1]
    cor.trans <- apply(matched.mats[[tx]]$X, 2, function(x) cor(x, comp.trait))

    test.seq <- seq(10, 2000, 10)
    all.cor <- matrix(NA, nrow = length(test.seq), ncol = 2)
    for(ts in 1:length(test.seq)){
        report.progress(ts, length(test.seq))
        pos.trans <- names(cor.trans)[order(abs(cor.trans), decreasing = TRUE)][1:test.seq[ts]]
        tr.decomp <- plot.decomp(matched.mats[[tx]]$X[,pos.trans], plot.results = FALSE)
        #plot.with.model(matched.mats[[tx]]$Z[,tr], matched.mats[[tx]]$X[,neg.trans[1]])
        all.cor[ts,1] <- summary(lm(tr.decomp$u[,1]~comp.trait))$r.squared
        all.cor[ts,2] <- summary(lm(tr.decomp$u[,2]~comp.trait))$r.squared
    }
    plot(test.seq, all.cor[,1], type = "l", ylim = c(min(all.cor), max(all.cor)))
    points(test.seq, all.cor[,2], type = "l", col = "blue")

    max.idx <- test.seq[which.max(all.cor[,1])]
    test.trans <- names(cor.trans)[order(abs(cor.trans), decreasing = TRUE)][1:max.idx]
    trait.col <- colors.from.values(matched.mats[[tx]]$Z[,tr], use.pheatmap.colors = TRUE)
    test.decomp <- plot.decomp(matched.mats[[tx]]$X[,test.trans], cols = trait.col)
    test.pc <- test.decomp$u
    rownames(test.pc) <- rownames(matched.mats[[tx]]$Z)
    test.scan <- scan1(genoprobs, test.pc)
    #trans.scan <- scan1(genoprobs, matched.mats[[tx]]$X[,test.trans], cores = 4)
    #plot.cistrans(trans.scan, map = map, gene.info = gene.table, id.col = "gene.id", chr.column = "chr", pos.column = "start", lod.threshold = 10)

    par(mfrow = c(2,1))
    plot(test.scan, map = map, lodcol = 1, main = "PC1")
    plot(test.scan, map = map, lodcol = 2, main = "PC2")

    test.enrich <- gost(test.trans, organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME"))        
    par(mfrow = c(1,1))
    plot.enrichment(test.enrich, num.terms = 30)
    pos.info <- gene.info[[tx]][match(test.trans, gene.info[[tx]][,1]),]

    par(mfrow = c(1,2))
    plot.with.model(test.pc[,1], matched.mats[[tx]]$Z[,tr], report = "cor.test",
        xlab = "Imputed Transcript PC1", ylab = colnames(cca.pheno)[tr])
    plot.with.model(test.pc[,2], matched.mats[[tx]]$Z[,tr], report = "cor.test",
        xlab = "Imputed Transcript PC2", ylab = colnames(cca.pheno)[tr])

}


```

## Penalty Optimization {.tabset .tabset-fade .tabset-pills}

In the code below we do a sweep over a grid of penalties to look for 
penalty combinations that maximize the correlation between latent
transcripts and latent traits.

```{r opt_by_can_cor}
get_trait_description <- function(tissue.mats, tissue.results, short_version = FALSE){
    if(short_version){
        trait.description <- paste0("Composite_Trait", 1:ncol(tissue.mats$Z))
    }else{
        trait.names <- apply(tissue.results$v, 2, function(x) colnames(tissue.mats$Z)[which(x != 0)])
        trait.vals <- apply(tissue.results$v, 2, function(x) x[which(x != 0)])
        trait.order <- lapply(trait.vals, function(x) order(abs(x)))
        trait.description <- unlist(lapply(1:length(trait.names), function(x) paste(trait.names[[x]][trait.order[[x]]], collapse = "-")))
    }
    return(trait.description)
}

#get latent variables and variance explained for each pair
get_latent_var <- function(tissue.mats, tissue.results){
    latent.trans <- apply(tissue.results$u, 2, function(x) tissue.mats$X %*% x)
    latent.traits <- apply(tissue.results$v, 2, function(x) tissue.mats$Z %*% x)
    colnames(latent.trans) <- paste0("Composite_Transcript", 1:ncol(latent.trans))
    colnames(latent.traits) <- paste0("Composite_Trait", 1:ncol(latent.trans))
    rownames(latent.trans) <- rownames(latent.traits) <- rownames(tissue.mats$X)
    r2 <- sapply(1:ncol(latent.trans), function(x) summary(lm(latent.traits[,x]~latent.trans[,x]))$adj.r.squared)
    names(r2) <- paste0("Composite_Cor", 1:length(r2))
    result <- list("Composite_Traits" = latent.traits, 
    "Composite_Transcripts" = latent.trans,
    "adj.r.squared" = r2)
    return(result) 
}

```

For each set of transcripts, we performed sparse CCA over a series of penalties
to identify the penalty combinations that simultaneously yielded a significant
correlation and maximized the canonical correlation coefficient.

```{r penalty_opt, fig.width = 8, fig.height = 8, results = "asis"}
perm.components = FALSE
tissue.trait.penalty <- vector(mode = "list", length = length(matched.mats))
names(tissue.trait.penalty) <- tissue.names
for(i in 1:length(matched.mats)){
    cat("###", tissue.names[i], "\n")
    #run permutations over the grid
    perm.file <- file.path(results.dir, paste0(tissue.names[i], ".", file.text, ".perm.RDS"))

    if(!perm.components){
        tissue.perm <- CCA_permute_grid(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
        filename = perm.file, search_grid = TRUE, nperms = nperms, 
        x_penalty = seq(0, 1, 0.1), z_penalty = seq(0, 1, 0.1))
    }else{
        #do permutations for all components
        tissue.perm <- CCA_permute_components(
        X = matched.mats[[i]]$X[,ordered.transcripts[[i]]], 
        Z = matched.mats[[i]]$Z, filename = perm.file,
        search_grid = TRUE, nperms = nperms,
        x_penalty = seq(0, 1, 0.1), z_penalty = seq(0, 1, 0.1),
        verbose = TRUE, plot.results = TRUE)
    }


    perm.results <- get_perm_grid(tissue.perm)
    if(is.interactive){quartz()}
    tissue.trait.penalty[[i]] <- perm_best_results(perm.results, 
        use.score = "cor", pval.thresh = pval.thresh, col.text.shift = 0.1, 
        row.text.shift = 0.1, return.top.only = TRUE,
        skew.toward.x = 0.5, skew.toward.z = 0.5)
    cat("\n\n")
}

#par(mar = c(2,2,2,2));imageWithTextColorbar(matrix(seq(0, 0.8, 0.01), nrow = 1), col.scale = "blue", axis.line = 0, cex = 1, global.color.scale = TRUE, global.min = 0, global.max = 0.8)
```


## Selected Penalties

The penalties identified for each trait are the following:

```{r final_penalties}
penalty.table <- Reduce("rbind", tissue.trait.penalty)
rownames(penalty.table) <- tissue.names
colnames(penalty.table) <- c("Transcript_Penalty", "Trait_Penalty")
kable(data.frame(penalty.table), format = "html", table.attr = "style='width:30%;'")
```


## CCA on all tissues

We then ran CCA on each tissue transcriptome-trait pair with the optimized 
penalties from above.

```{r run_CCA}
tissue.CCA.results <- vector(mode = "list", length = length(tissue.names))
names(tissue.CCA.results) <- tissue.names

for(i in 1:length(tissue.names)){
    num.components = ncol(matched.mats[[i]]$Z)
    penaltyx <- as.numeric(tissue.trait.penalty[[i]]$x)
    penaltyz <- as.numeric(tissue.trait.penalty[[i]]$z)
    if(length(tissue.trait.penalty[[i]]) > 1 && length(penaltyx) > 0 && length(penaltyz) > 0){
        CCA.file <- file.path(results.dir, paste0(tissue.names[i], 
        ".", file.text, ".CCA.RDS"))
        if(!file.exists(CCA.file) || delete_previous){    
            cca.results <- CCA(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
            typex = "standard", typez = "standard", K = num.components, 
            penaltyx = penaltyx, penaltyz = penaltyz, trace = FALSE)
            saveRDS(cca.results, CCA.file)
        }else{
            cca.results <- readRDS(CCA.file)
        }
    }else{
        cca.results <- NA
    }
    tissue.CCA.results[[i]] <- cca.results
}
```

## Bootstrap Loadings

The loadings estimated above are from a single run of LASSO-penalized
CCA. Despite correlated traits and transcripts, the loadings on these
variables will not be smooth because of the nature of the LASSO penalty.

We like sparsification because it helps improve interpretability of the
results, but we also do not want to select one of a handful of relevant,
correlated genes because of the nature of LASSO.

To help smooth the loadings, we will use bootstrap aggregation to 
estimate loadings. We sampled the individuals with replacement, 
re-ran the penalized CCA, and collected the results. After the specified 
number of bootstraps, we kept only the transcripts whose estimates were 
always positive, or always negative. 

```{r bootstrap_loadings}
boot.trans.file <- file.path(results.dir, "Bootstrapped.Transcript.Loadings.RDS")
boot.trait.file <- file.path(results.dir, "Bootstrapped.Trait.Loadings.RDS")

if(!file.exists(boot.trans.file) || delete_previous){
    tissue.transcript.boots <- tissue.trait.boots <- vector(mode = "list", length = length(tissue.names))
    names(tissue.transcript.boots) <- names(tissue.trait.boots) <- tissue.names

    for(i in 1:length(tissue.names)){
        penalties <- unlist(tissue.trait.penalty[[i]])
        if(length(penalties) > 0){
            all.transcript.loadings <- vector(mode = "list", length = n.bootstraps)
            all.trait.loadings <- vector(mode = "list", length = n.bootstraps)
            for(b in 1:n.bootstraps){
                sample.set <- sample(1:nrow(matched.mats[[i]]$X), replace = TRUE)
                cca.results.train <- CCA(matched.mats[[i]]$X[sample.set,], 
                matched.mats[[i]]$Z[sample.set,], 
                typex = "standard", typez = "standard", 
                K = num.components, 
                penaltyx = penalties[1], penaltyz = penalties[2], 
                trace = FALSE)
                all.transcript.loadings[[b]] <- cca.results.train$u
                all.trait.loadings[[b]] <- cca.results.train$v
            }
            tissue.transcript.boots[[i]] <- all.transcript.loadings
            tissue.trait.boots[[i]] <- all.trait.loadings
        }
    }
    saveRDS(tissue.transcript.boots, boot.trans.file)
    saveRDS(tissue.trait.boots, boot.trait.file)
}else{
    tissue.transcript.boots  <- readRDS(boot.trans.file)
    tissue.trait.boots  <- readRDS(boot.trait.file)
}
```

```{r agg_fun}
all_one_side <- function(estimate.mat){
    all.pos <- which(apply(estimate.mat, 1, function(x) all(x > 0)))
    all.neg <- which(apply(estimate.mat, 1, function(x) all(x < 0)))
    consistent.estimates <- sort(c(all.pos, all.neg))
    #example.sample <- c(sample(all.pos, 10), sample(all.neg, 10), sample(1:nrow(estimate.mat), 10))
    #boxplot(t(estimate.mat[example.sample,]), ylim = c(-0.2, 0.2), axes = FALSE, 
    #    col = rep(c("#7fc97f", "#beaed4", "#fdc086"), each = 10));abline(h = 0);axis(2)
    
    estimate.means <- rep(0, nrow(estimate.mat))
    if(length(consistent.estimates) > 0){
        estimate.means[consistent.estimates] <- rowMeans(estimate.mat[consistent.estimates,,drop=FALSE])
    }
    return(estimate.means)
}

#this is an alternative function that looks for transcripts with
#loading distributions significantly different from 0.
sig_loadings <- function(estimate.mat, fdr = 0.05, plot.sample = FALSE){ 
    has.vals <- which(rowSums(estimate.mat) != 0)
    
    all.p <- apply(estimate.mat[has.vals,,drop=FALSE], 1, function(x) try(t.test(x, mu = 0)$p.value, silent = TRUE))
    all.p[which(is.na(as.numeric(all.p)))] <- 0
    adj.p <- p.adjust(all.p, "fdr")
    sig.tests <- which(adj.p <= fdr)
    
    estimate.means <- rep(0, nrow(estimate.mat))
    if(length(sig.tests) > 0){
        estimate.means[has.vals[sig.tests]] <- rowMeans(estimate.mat[has.vals[sig.tests],,drop=FALSE])
    }

    if(plot.sample){
        non.zero.sample <- sample(has.vals[sig.tests], num.components)
        zero.sample  <- sample(setdiff(1:nrow(estimate.mat), has.vals[sig.tests]), num.components)
        mean.order <- order(estimate.means[non.zero.sample])
        all.example.idx <- c(non.zero.sample[mean.order], zero.sample)
        boxplot(t(estimate.mat[all.example.idx,]), ylim = c(-0.2, 0.2), axes = FALSE);abline(h = 0);axis(2)
    }

    return(estimate.means)

}

get_agg_loadings <- function(tissue.boot.results, tissue.results, trait.or.trans = "trans", fdr = 0.05){

    tissue.loadings <- lapply(1:ncol(tissue.boot.results[[1]]), 
    function(tr) sapply(tissue.boot.results, function(x) x[,tr]))

    #orient all loadings with the original CCA
    if(trait.or.trans == "trans"){
        orig.cca <- tissue.results$u
    }else{
        orig.cca <- tissue.results$v
    }
    cor.loadings <- sapply(1:length(tissue.loadings), function(x) cor(orig.cca[,x], tissue.loadings[[x]][,1]))
    neg.locale <- which(cor.loadings < 0)
    if(length(neg.locale) > 0){
        for(n in neg.locale){
            tissue.loadings[[n]] <- tissue.loadings[[n]] * -1
        }
    }

    oriented.loadings <- vector(mode = "list", length = length(tissue.loadings))
    cor.loadings <- lapply(tissue.loadings, cor)
    for(f in 1:length(cor.loadings)){
        flip.which <- which(cor.loadings[[f]][1,] < 0)
        flipped.loadings <- tissue.loadings[[f]]
        flipped.loadings[,flip.which] <- flipped.loadings[,flip.which] * -1
        oriented.loadings[[f]] <- flipped.loadings
        #pheatmap(cor(flipped.loadings))
    }

    #aggregate over the bootstraps by taking the mean estimate
    #tissue.boot.agg <- sapply(oriented.loadings, rowMeans)

    #aggregate the boostraps by taking only estimates that were 
    #consistently on the same side of 0.
    #tissue.boot.agg <- sapply(oriented.loadings, all_one_side)
    tissue.boot.agg <- sapply(oriented.loadings, function(x) sig_loadings(x, fdr = fdr))

    return(tissue.boot.agg)
}
```

```{r aggregate_bootstrapped_loadings}
aggregate.results <- file.path(results.dir, "Aggregate.Results.RDS")
if(!file.exists(aggregate.results) || delete_previous){
    #create a new CCA results object with the bootstrapped loadings
    boot.CCA.results <- tissue.CCA.results
    for(i in 1:length(tissue.names)){
        boot.CCA.results[[i]]$u <- get_agg_loadings(tissue.boot.results = tissue.transcript.boots[[i]], 
            tissue.results = tissue.CCA.results[[i]], trait.or.trans = "trans", fdr = 1e-6)
        boot.CCA.results[[i]]$v <- get_agg_loadings(tissue.boot.results = tissue.trait.boots[[i]], 
            tissue.results = tissue.CCA.results[[i]], trait.or.trans = "trait", fdr = 1e-6)
    }
    saveRDS(boot.CCA.results, aggregate.results)
}else{
    boot.CCA.results <- readRDS(aggregate.results)
}
```

## Compare Original CCA and Bootsrapped Results {.tabset .tabset-fade .tabset-pills}

### Number of Transcripts {.tabset .tabset-fade .tabset-pills}

The following plots show the number of transcripts with non-zero
loadings for the two methods. Bootstrapping with the harsh selection
criterion of only selecting transcripts that never cross 0, severely
reduced the number of transcripts selected. There were only a handful
selected for the first composite transcript, and none selected for
subsequent transcripts. We could relax this criterion to get more
composite trait-transcript pairs.

Adipose and islet had the largest number of transcripts selected,
and liver and skeletal muscle had the fewest.

```{r boot_comp, fig.width = 7, fig.height = 5, results = "asis"}
bar.cols <- c("#b2df8a", "#33a02c", "#a6cee3", "#1f78b4")
tissue.pos.neg <- vector(mode = "list", length = length(tissue.names))
names(tissue.pos.neg) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("####", tissue.names[i], "\n")
    trans.loadings  <- tissue.CCA.results[[i]]$u
    trait.loadings  <- tissue.CCA.results[[i]]$v
    trans.boot  <- boot.CCA.results[[i]]$u
    trait.boot  <- boot.CCA.results[[i]]$v

    num.neg <- apply(trans.loadings, 2, function(x) length(which(x < 0)))
    num.pos <- apply(trans.loadings, 2, function(x) length(which(x > 0)))
    num.neg.boot <- apply(trans.boot, 2, function(x) length(which(x < 0)))
    num.pos.boot <- apply(trans.boot, 2, function(x) length(which(x > 0)))

    #zero.cca <- apply(trans.loadings, 2, function(x) length(which(x == 0)))
    #zero.boot <- apply(trans.boot, 2, function(x) length(which(x == 0)))

    count.mat <- rbind(num.pos, num.neg, num.pos.boot, num.neg.boot)
    tissue.pos.neg[[i]] <- count.mat

    if(is.interactive){quartz(width = 9, height = 5)}
    barplot(count.mat, beside = TRUE,
    names = paste("CT", 1:ncol(trans.loadings)), las = 2, main = tissue.names[i],
    col = bar.cols, ylab = "Number of Transcripts")
    legend("topleft", legend = c("CCA Positive", "CCA Negative", 
    "Boot Positive", "Boot Negative"), fill = bar.cols)
    cat("\n\n")
}
```

The following boxplots show the distributions of transcript numbers
across all CT pairs for all tissues. Adipose and Islet picked up
transcripts while liver and skeletal muscle dropped some.

```{r transcript_numbers_combined, results = "asis"}
cat("### Combined Results\n")
plot.grouped.boxes(lapply(tissue.pos.neg, t), type = "matrix")
cat("\n\n")
```

### Canonical Correlations {.tabset .tabset-fade .tabset-pills}

The following plots show the canonical correlations for the original CCA
and the bootstrap-aggregaged CCA. It's a mixed bag. Sometimes the correlation
from the bootstrapping is better and sometimes it's worse. Can we assume
that if the correlation is worse, the original CCA was overfitting?

```{r cancor, results = "asis"}
all.cancor <- vector(mode = "list", length = length(tissue.names))
names(all.cancor) <- tissue.names
for(i in 1:length(tissue.names)){
    if(is.interactive){quartz()}
    cat("####", tissue.names[i], "\n")
    cca.var <- get_latent_var(tissue.mats = matched.mats[[i]], tissue.results = tissue.CCA.results[[i]])
    boot.var <- get_latent_var(matched.mats[[i]], boot.CCA.results[[i]])

    cancor.mat <- rbind("CCA" = cca.var[[3]], "Boot" = boot.var[[3]])
    barplot(cancor.mat, beside = TRUE, las = 2, 
    names = paste("CT", 1:ncol(trans.loadings)), col = bar.cols[c(1,3)],
    main = tissue.names[i], ylab = "CTrait-CTranscript R2")

    all.cancor[[i]] <- cancor.mat
    cat("\n\n")
}

cat("#### Combined Results\n")

all.cca.cancor <- sapply(all.cancor, function(x) x[1,])
all.boot.cancor <- sapply(all.cancor, function(x) x[2,])

tissue.cols <- c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3")
pt.col <- sapply(1:ncol(all.cca.cancor), function(x) rep(tissue.cols[x], nrow(all.cca.cancor)))
if(is.interactive){quartz(width = 7, height = 5)}
par(mar = c(4,4,4,8))
plot(unlist(all.cca.cancor), unlist(all.boot.cancor), col = unlist(pt.col), pch = 16,
xlab = "CCA Canonical Correlation", ylab = "Bootstrapped Canonical Correlation")
abline(0,1)
par(xpd = NA)
legend(max(unlist(all.cca.cancor)*1.05, na.rm = TRUE), max(unlist(all.boot.cancor), na.rm = TRUE), 
legend = colnames(all.cca.cancor), pch = 16, col = pt.col[1,])
par(xpd = TRUE)

cat("\n\n")
```

### Comparison of Trait Loadings {.tabset .tabset-fade .tabset-pills}

```{r trait_comp, fig.height = 5, fig.width = 9}
for(i in 1:length(tissue.names)){
    cat("####", tissue.names[i], "\n")
    cca.traits <- tissue.CCA.results[[i]]$v
    boot.traits <- boot.CCA.results[[i]]$v

    rownames(cca.traits) <- rownames(boot.traits) <- colnames(matched.mats[[i]]$Z)
    colnames(cca.traits) <- colnames(boot.traits) <- paste0("CT", 1:ncol(cca.traits))

    if(is.interactive){quartz(width = 9, height = 5)}
    box.groups <- list("CCA" = cca.traits, "Boot" = boot.traits)
    plot.grouped.boxes(lapply(box.groups, function(x) t(abs(x))), type = "matrix", 
    main = tissue.names[i], label.srt = 90, print.vals = NA)
    cat("\n\n")
}

```

For the remainder of the analysis, we focus on the bootstrap-aggregated
results.

## Transcripts and Traits by Tissue {.tabset .tabset-fade .tabset-pills}

The following plot summarize information from the results for 
each tissue. 

The first heatmap shows the loadings of each raw trait
on each composite trait. They are quite different between the tissues.

The boxplot shows summaries for the contributions of each trait
to get an overall idea of which traits contributed.

The barplot shows how many transcripts had non-zero loadings on each 
composite trait. The negative and positive loadings are shown separately.

The next two heatmaps shows the correlation matrix between transcript
loading patterns for the traits, and the jaccard index matrix for the
transcripts assigned to each trait respectively.
 
```{r transcript_num, fig.width = 7, fig.height = 6}

describe_results <- function(tissue.mats, tissue.results, filename = NULL){
    
    if(!is.null(filename)){pdf(filename)}

    if(is.null(tissue.results)){
        plot.text("No involvement in this tissue.")
    }else{

        trait.loadings <- tissue.results$v
        transcript.loadings <- tissue.results$u
        trait.description <- get_trait_description(tissue.mats, tissue.results, 
        short_version = TRUE)
        cat("\n\n")
        
        cat("#### Trait Contributions to Composite Trait\n")
        rownames(trait.loadings) <- colnames(tissue.mats$Z)
        colnames(trait.loadings) <- trait.description
        pheatmap(t(trait.loadings), cluster_rows = FALSE, cluster_cols = FALSE)
        cat("\n\n")

        cat("#### Trait Contributions Clustered\n")
        pheatmap(trait.loadings)
        cat("\n\n")

        cat("#### Summary of Trait Contributions\n")
        par(mar = c(10, 4, 4, 4))
        boxplot(t(trait.loadings), las = 2, 
        main = "Summary of Trait Contributions Across All Composite Traits")
        trait.list <- lapply(1:nrow(trait.loadings), function(x) trait.loadings[x,])
        names(trait.list) <- trait.description
        stripchart(trait.list, vertical = TRUE, method = "jitter", pch = 16, las = 2,
        add = TRUE)

        trait.specific <- which(apply(tissue.results$u, 1, function(x) length(which(x != 0))) == 1)
        pos.trans <- apply(tissue.results$u, 2, function(x) length(which(x > 0)))
        neg.trans <- apply(tissue.results$u, 2, function(x) length(which(x < 0)))
        cat("\n\n")

        cat("#### Transcript Counts\n")
        cols <- brewer.pal(8, "Accent")
        par(mar = c(4,8, 4, 4))
        barplot(t(cbind(pos.trans, neg.trans)), beside = TRUE, 
        names = trait.description, las = 2, cex.names = 0.8, 
        col = cols[1:2], main = "Number of Transcripts Associated with Each Composite Trait")
        legend("topleft", c("Positive", "Negative"), fill = cols[1:2])
        cat("\n\n")

        cat("#### Transcript Specificity\n")
        num.traits  <- apply(tissue.results$u, 1, function(x) length(which(x != 0)))
        num.totals <- table(num.traits)
        #num.totals <- c(num.totals, sum(num.totals[2:length(num.totals)]))
        #names(num.totals)[length(num.totals)] <- "Total"
        a <- barplot(num.totals, ylim = c(0, max(num.totals)*1.1),
        main = "Number of Transcripts Associated with Different Numbers of Traits")
        text(a[,1], (num.totals+(max(num.totals)*0.02)), labels = num.totals)
        cat("\n\n")

        #This plot shows how similar the composite transcripts are
        cat("#### Heatmap of correlations between transcript loadings for pairs of traits\n")
        has.loading <- which(rowSums(tissue.results$u) != 0)
        has.trait <- which(colSums(tissue.results$u) != 0)
        effect.mat <- tissue.results$u[has.loading,has.trait]
        if(sum(dim(effect.mat)) > 2){
            cor.effect <- cor(effect.mat)
            rownames(cor.effect) <- colnames(cor.effect) <- gsub("Trait", "Transcript", trait.description[has.trait])
            diag(cor.effect) <- 0
            if(length(unique(cor.effect[upper.tri(cor.effect, diag = FALSE)])) > 1){
                pheatmap(cor.effect)
            }else{
            print("Too few correlations to show.")
            }
        }else{
            print("No correlations to show.")
        }

        trans.list <- apply(tissue.results$u, 2, function(x) colnames(tissue.mats$X)[which(x != 0)])
        names(trans.list) <- gsub("Trait", "Transcript", trait.description)
        
        #network of traits based on similarity transcript contributions
        trait.by.transcript <- trait.loadings[,has.trait] %*% t(effect.mat)
        #take out traits without contributions from transcripts
        has.transcript <- which(colSums(t(trait.by.transcript)) > 0)
        if(length(has.transcript) > 1){
            trait.transcript.cor <- cor(t(trait.by.transcript[has.transcript,,drop=FALSE]))
            diag(trait.transcript.cor) <- 0
            #pheatmap(trait.transcript.cor)
            trait_graph <- graph_from_adjacency_matrix(trait.transcript.cor, 
            weighted = TRUE, mode = "undirected")
            edge_sign <- sign(E(trait_graph)$weight)
            edge_weight <- E(trait_graph)$weight
            E(trait_graph)$weight <- abs(edge_weight)
            if(length(unique(E(trait_graph)$weight)) > 2){
                e.col <- colors.from.values(edge_weight, use.pheatmap.colors = TRUE)
            }else{
                e.col = "gray"
            }
            cat("\n\n")

            cat("#### Trait Network\n")
            layout(matrix(c(1,1,2,0), ncol = 2, byrow = FALSE), widths = c(1, 0.3))
            plot(trait_graph, edge.color = e.col, layout = layout_nicely, 
            main = "Trait Relatedness By Associated Transcripts", 
            edge.width = E(trait_graph)$weight*3)
            par(mar = c(0,0,1,1))
            imageWithTextColorbar(matrix(E(trait_graph)$weight*edge_sign, ncol = 1), 
                use.pheatmap.colors = TRUE, cex = 1)
            cat("\n\n")
        }
        
        #I tried making a network of transcripts based on similarity trait contributions
        #but it is much too big to plot
        #we will get at this question in other ways.


    }
    if(!is.null(filename)){dev.off()}
}
```

```{r plot_agg, results = "asis"}
for(i in 1:length(tissue.names)){
    #cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    filename = file.path(results.dir, paste0("Boot.Results.", tissue.names[i], ".pdf"))
    describe_results(tissue.mats = matched.mats[[i]], tissue.results = boot.CCA.results[[i]], 
    filename = filename)
}
```

## Transcript Group Enrichment {.tabset .tabset-fade .tabset-pills}

We then looked for functional enrichment associated with each set of genes.
We sorted each by the magnitude of its association with the trait, and used
an ordered query in gprofiler.

```{r enrichment_fun}

get_transcript_list <- function(tissue.mats, tissue.results){
    if(length(tissue.results) == 1){
        return(NA)
    }
    trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.up.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] > 0))
    trait.down.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] < 0))
    names(trait.up.transcripts) <- names(trait.down.transcripts) <- trait.description
    #cbind(trait.description, sapply(trait.up.transcripts, length), sapply(trait.down.transcripts, length))
    tissue.nets <- vector(mode = "list", length = length(trait.up.transcripts))
    has.vals <- which(colSums(tissue.results$u) != 0)
    for(tr in has.vals){
        trait.up.genes <- colnames(tissue.mats$X)[trait.up.transcripts[[tr]]]
        trait.up.vals <- tissue.results$u[trait.up.transcripts[[tr]],tr]
        names(trait.up.vals) <- trait.up.genes

        trait.down.genes <- colnames(tissue.mats$X)[trait.down.transcripts[[tr]]]
        trait.down.vals <- tissue.results$u[trait.down.transcripts[[tr]],tr]
        names(trait.down.vals) <- trait.down.genes

        trait.gene.groups <- list(sort(trait.up.vals, decreasing = TRUE), 
        sort(trait.down.vals, decreasing = FALSE))
        names(trait.gene.groups) <- paste0("Transcript", tr, c("_up", "_down"))
        tissue.nets[[tr]] <- trait.gene.groups
    }

    tissue.genes <- unlist(tissue.nets, recursive = FALSE)
    return(tissue.genes)
}

gprofiler_enrichment <- function(tissue.gene.list, ordered_query = FALSE, filename){
    if(!file.exists(filename) || delete_previous){
        tissue.enrich <- lapply(tissue.gene.list, 
        function(x) if(length(x) >= 5){gost(names(x), 
        organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME"), 
        ordered_query = ordered_query, evcodes = TRUE)}else{NULL})
        saveRDS(tissue.enrich, filename)
    }else{
        tissue.enrich <- readRDS(filename)
    }
    result <- list("Tissue_Transcripts" = tissue.gene.list, "Enrichments" = tissue.enrich)
    return(result)
}

get_enrichment_plus <- function(tissue.mats, tissue.results, ct){
    gene.vals <- tissue.results$u[,ct]
    neg.idx <- which(gene.vals < 0)
    pos.idx <- which(gene.vals > 0)
    neg.order <- order(gene.vals[neg.idx])
    pos.order <- order(gene.vals[pos.idx], decreasing = TRUE)
    ordered.pos <- colnames(tissue.mats$X)[pos.idx[pos.order]]
    ordered.neg <- colnames(tissue.mats$X)[neg.idx[neg.order]]
    #plot(gene.vals[pos.idx[pos.order]])
    #plot(gene.vals[neg.idx[neg.order]])
    pos.enrich <- gost(ordered.pos, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    #plot.enrichment(pos.enrich, max.term.size = 2000)
    neg.enrich <- gost(ordered.neg, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    result <- list("positive_enrichment" = pos.enrich, 
    "negative_enrichment" = neg.enrich)
    return(result)
}

enrichment_plus_genes <- function(enrichment.plus, search.terms){
    results.table <- enrichment.plus$result
    term.position <- unique(unlist(lapply(search.terms, function(x) grep(x, results.table[,"term_name"], ignore.case = TRUE))))
    if(length(term.position) > 0){
        sub.results <- results.table[term.position,]
    }else{
        sub.results <- "Terms not found"
    }
    return(sub.results)
}
```


```{r tissue_enrich, warning = FALSE, error = FALSE, message = FALSE}

tissue.enrich <- gene.info <- vector(mode = "list", length = length(tissue.names))
names(tissue.enrich) <- names(gene.info) <- tissue.names

for(i in 1:length(tissue.names)){
    #get lists of non-zero transcripts
    #and sort by magnitude of loading
    tissue.gene.list <- get_transcript_list(tissue.mats = matched.mats[[i]], 
    tissue.results = boot.CCA.results[[i]])
    assoc.transcripts <- unique(names(Reduce("c", tissue.gene.list)))
    assoc.transcript.table <- gene.table[match(assoc.transcripts, gene.table[,1]),,drop=FALSE]
    write.table(assoc.transcript.table, 
        file.path(results.dir, paste0("Transcripts.Associated.", tissue.names[i], ".csv")),
        quote = FALSE, sep = ",", row.names = FALSE)
    tissue.enrich[[i]] <- gprofiler_enrichment(tissue.gene.list, ordered_query = TRUE,
    filename = file.path(results.dir, 
    paste0(tissue.names[i], ".Composite.Transcript.Enrichments.RDS")))
    gene.info[[i]] <- assoc.transcript.table
}

```

The following figures show the functional enrichments for the 
transcripts with positive and negative loadings on each trait 
for each tissue.

We present this in several different types of figures.

For each trait we show a table of the significant enrichments for the 
transcripts with positive loadings and the transcripts with negative 
loadings side by side.

We then combined these into one heatmap plot to show all the traits 
and their enrichments together.

Finally, we took the top 10 enriched terms from each trait, and constructed
a bipartite graph between traits and enriched terms. We projected this network
onto the traits and the terms. Rather amazingly, the terms for each tissue
cluster into beautiful functional clusters

```{r plot_enrichment}
plot_tissue_enrich <- function(tissue.mats, tissue.results, enrichment.results, 
max.term.size = 2000, num.terms = 30){
    if(length(tissue.results) == 1){
        plot.text("No involvement of this tissue.")
        plot.text("No involvement of this tissue.")
        return(NULL)
    }
    #trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.description <- paste0("Composite_Transcript", 1:ncol(tissue.mats$Z))
    tissue.enrich.results <- enrichment.results[[2]]
    has.enrich <- which(sapply(tissue.enrich.results, length) > 0)
    enriched.transcripts <- unique(sapply(strsplit(names(has.enrich), "_"), function(x) x[1]))

    if(length(has.enrich) == 0){
        cat("#### No Erichments\n")
    }else{
        idx <- 1
        for(i in 1:length(enriched.transcripts)){
            cat("####", trait.description[i], "\n")
            #quartz(width = 12, height = 7)
            par(mfrow = c(1,2))
            for(dir in 1:2){
                plot.enrichment.wordcloud(tissue.enrich.results[[idx]], num.terms = num.terms, 
                plot.label = names(tissue.enrich.results)[idx], 
                max.term.size = max.term.size)
                idx = idx + 1
            }
            #mtext(trait.description[i], outer = TRUE, side = 3, line = -2.5)
            cat("\n\n")
        }
    }
cat("\n\n")
}


#This function covers specified nodes in a network with
#white boxes, similar to how we would in Keynote to erase
#something.
cover_nodes <- function(bip.net, label.term = "Transcript", 
search.name = c("partial", "full"), rad = 0.1, border.col = "white",
fill.col = "white"){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        circ.coord <- get_circle(rad, center_x = mid.x, center_y = mid.y, dens = 0.05)
        polygon(circ.coord$x, circ.coord$y, col = fill.col, border = border.col)
    }
}

add_picture_nodes <- function(bip.net, val.mat, label.term = "Transcript", 
search.name = c("partial", "full"), rect.width = 0.1, rect.height = 0.1, lwd = 0.5){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        min.x <- mid.x - (rect.width/2)
        max.x <- mid.x + (rect.width/2)
        min.y <- mid.y - (rect.height/2)
        max.y <- mid.y + (rect.height/2)
        
        x.pts <- scale.between.vals(1:nrow(val.mat), min.x, max.x)
        y.vals <- scale.between.vals(val.mat[,i], min.y, max.y)
        pt.col <- colors.from.values(val.mat[,i], use.pheatmap.colors = TRUE,
        global.color.scale = TRUE, global.min = min(val.mat), global.max = max(val.mat))
        #barplot(val.mat[,i], col = pt.col, las = 2)
        #barplot(1:length(pt.col), col = pt.col)
        #plot.new()
        #plot.window(xlim = c(min.x, max.x), ylim = c(min.y, max.y))
        segments(x0 = x.pts, y0 = min.y, y1 = max.y, col = pt.col, lwd = lwd)
    }
}

#This function plots a bipartite network and replaces the transcript
#nodes with pictures of the effects of that transcript on the traits.
#Because the up and down transcript effects are separated, we multiply
#the down-transcripts by -1 to reverse the trait effects. 

plot_decorated_bip <- function(tissue.full.bip, tissue.mats, tissue.results, 
filename, fig.width = 20, fig.height = 20){
    
    tissue.bip <- tissue.full.bip$Network
    term.proj <- tissue.full.bip$Projections[[1]]

    pdf(filename, width = fig.width, height = fig.height)
    on.exit(dev.off())
    if(is.null(tissue.bip)){
        plot.text("No Bipartite Graph to Show")
        return(NULL)
    }

    trait.loadings <- tissue.results$v
    rownames(trait.loadings) <- colnames(tissue.mats$Z)
    colnames(trait.loadings) <- paste("Composite_Trait", 1:ncol(trait.loadings))
    #pheatmap(trait.loadings)
    exp.trait.mat <- Reduce("cbind", lapply(1:nrow(trait.loadings), 
    function(x) cbind(trait.loadings[,x,drop=FALSE], trait.loadings[,x,drop=FALSE]*-1)))
    trait.clust <- hclust(dist(exp.trait.mat))
    #plot(trait.clust)
    trait.order <- trait.clust$order
    pheatmap(t(exp.trait.mat[trait.order,seq(1,ncol(exp.trait.mat), 2)]), cex = 2)

    cl.cols <- c(categorical_pal(8), brewer.pal(8, "Set1"))
    #barplot(rep(1, length(cl.cols)), col = cl.cols)

    cluster.mem <- cluster_walktrap(tissue.bip)$membership

    #plot network of terms only
    plot(term.proj, vertex.size = 5, layout = layout_with_kk,
        vertex.label.dist = 0.7, vertex.label.adj = 1, 
        vertex.color = cl.cols[cluster.mem])

    #plot network of terms as they relate to composite traits
    node.color <- rep("lightgray", vcount(tissue.bip))
    #node.cluster <- sapply(V(tissue.bip)$name, function(x) grep(gsub("...", "", x, fixed = TRUE), V(term.proj)$name, fixed = TRUE)) 
    node.cluster <- sapply(V(tissue.bip)$name, function(x) which(V(term.proj)$name == x))

    one.color <- sapply(node.cluster, function(x) if(length(x) == 1){cluster.mem[x]}else{0})
    no.color <- sapply(node.cluster, function(x) if(length(x) == 0){max(cluster.mem)+1}else{0})
    multi.color <- sapply(1:length(node.cluster), function(x) if(length(node.cluster[[x]]) > 1){cluster.mem[which(V(term.proj)$name == V(tissue.bip)$name[x])]}else{0})
    cl.color <- rowSums(cbind(one.color, no.color, multi.color))

    clustered.terms <- lapply(sort(unique(cl.color)), function(x) V(tissue.bip)$name[which(cl.color == x)])
    layout.mat <- get.layout.mat((length(clustered.terms)-1))
    
    layout(layout.mat)
    for(cl in 1:(length(clustered.terms)-1)){
        par(mar = c(0,0,0,0))
        word.bag <- unlist(strsplit(clustered.terms[[cl]], " ")) 
        wordcloud(word.bag, scale = c(1, 0.1), min.freq = 0.05,
            col = cl.cols[cl], rot.per = 0, max.words = 30)
    }

    layout(matrix(1, ncol = 1))
    par(mar = c(4,4,4,4))

    plot(tissue.bip, vertex.size = 5, layout = layout_with_kk,
    vertex.label.dist = 0.7, vertex.label.adj = 1, vertex.color = cl.cols[cluster.mem])
    cover_nodes(tissue.bip, label.term = "Transcript", 
    search.name = c("partial", "full"), rad = 0.03)
    add_picture_nodes(tissue.bip, exp.trait.mat[trait.order,], 
    label.term = "Transcript", search.name = "partial", rect.width = 0.06, 
    rect.height = 0.04, lwd = 2)

    par(xpd = TRUE)
    text.x <- segment.region(-1, -0.5, nrow(exp.trait.mat))
    text.y <- rep(-0.9, nrow(exp.trait.mat))
    text(text.x, text.y, rownames(exp.trait.mat)[trait.order], srt = 270, adj = 1)
    text(x = -0.75, y = -0.95, "Trait Order in Figure")
    par(xpd = FALSE)
}
```


## Individual Composite Trait Enrichments {.tabset .tabset-fade .tabset-pills}

```{r plot_enrich, results = "asis", fig.width = 12, fig.height = 10}
max.term.size = 2000
num.terms = 10
p_val_thresh = 1e-3

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(is.interactive){quartz(width = 10, height = 7)}
    plot_tissue_enrich(tissue.mats = matched.mats[[i]], 
    tissue.results = boot.CCA.results[[i]], 
    enrichment.results = tissue.enrich[[i]], 
    max.term.size = max.term.size, num.terms = num.terms)
    cat("\n\n")
}
```


## Composite Trait Enrichment Heatmaps {.tabset .tabset-fade .tabset-pills}

```{r all_enrichment_heatmaps, fig.height = 15, fig.width = 7, results = "asis"}

enrich.mats <- vector(mode = "list", length = length(tissue.names))
names(enrich.mats) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(is.interactive){pdf(file.path(results.dir, paste0("Enrichment.mat.", 
    tissue.names[i], ".pdf")), height = 40, width = 9)}
    if(length(tissue.enrich[[i]]) > 1 && sum(sapply(tissue.enrich[[i]][[2]], length)) > 0){
        enrich.mats[[i]] <- plot.enrichment.group(enrichment.list = tissue.enrich[[i]][[2]], max.char = Inf)
    }else{
        plot.text("No Enrichment")
    }
    if(is.interactive){dev.off()}
    cat("\n\n")
}
#dev.off()
```

## Simplified Enrichment
Attempting to simplify GO term enrichments using the R package 
simplifyEnrichment.

```{r simpEnrich, message = FALSE, error = FALSE, warning = FALSE}
#I'm turning this off so I can run on sumner for now. For some 
#reason I can get simplifyEnrichment to install.
if(run.simplify.enrichment){
    library("simplifyEnrichment")
    go.domains <- c("BP")
    cluster.col <- brewer.pal(12, "Paired")
    #go.domains = c("BP", "MF", "CC")
    #make an object to hold enrichment summaries
    go.summaries <- go.groupings <- vector(mode = "list", length = length(tissue.names))
    names(go.summaries) <- names(go.groupings) <- tissue.names
    for(i in 1:length(tissue.names)){

        all.trans.enrich <- tissue.enrich[[i]]$Enrichments
        #threshold by specified p value
        
        thresh.enrich <- lapply(all.trans.enrich, function(x) x$result[which(x$result[,"p_value"] <= p_val_thresh),]) 
        all.enrich.terms <- lapply(thresh.enrich, function(x) x[grep("GO:BP", x[,"source"]),"term_id"])
        u_terms <- Reduce("union", all.enrich.terms)    

        if(length(u_terms) > 0){
            pdf(file.path(results.dir, paste0("Enrichment_Simplified_", tissue.names[i], ".pdf")), width = 11, height = 7)
            #mf.mat = GO_similarity(u_terms, ont = "MF", db = "org.Mm.eg.db")
            #cc.mat = GO_similarity(u_terms, ont = "CC", db = "org.Mm.eg.db")
            bp.mat = GO_similarity(u_terms, ont = "BP", db = "org.Mm.eg.db")
            #mf.df = simplifyGO(mf.mat)
            #cc.df <- simplifyGO(cc.mat)
            bp.df <- simplifyGO(bp.mat)
            write.table(bp.df, file.path(results.dir, 
                paste0("GO_Term_Clusters_", tissue.names[i], ".txt")), 
                sep = "\t", quote = FALSE, row.names = FALSE)
            dev.off()

            #keep the assignments for each GO term
            go.groupings[[i]] <- bp.df

            #look through the composite transcripts and make a matrix
            #to specify the cluster membership of each transcript
            c.table <- table(bp.df[,"cluster"])
            big.c <- c.table[which(c.table >= 5)]
            mem.mat <- matrix(0, nrow = length(big.c), ncol = length(all.trans.enrich))
            colnames(mem.mat) <- names(all.trans.enrich)
            cl.names <- rep(NA, length(big.c))
            if(length(big.c) > 0){
                for(cl in 1:length(big.c)){
                    cl.locale <- which(bp.df[,"cluster"] == names(big.c)[cl])
                    cl.terms <- bp.df[cl.locale,]

                    #name the cluster
                    sorted.cl <- sort(table(unlist(strsplit(cl.terms[,"term"], " "))), decreasing = TRUE)
                    cl.names[cl] <- paste(names(head(sorted.cl, 10)), collapse = "_")
            
                    #calculate the 
                    cl.idx <- lapply(all.trans.enrich, function(x) which(x$result[,"term_id"] %in% cl.terms[,1]))
                    cl.nlp <- lapply(1:length(cl.idx), 
                        function(x) if(length(cl.idx[[x]]) > 0){-log10(all.trans.enrich[[x]]$result[cl.idx[[x]],"p_value"])}else{0})
                    names(cl.nlp) <- names(cl.idx)
                    mean.nlp <- sapply(cl.nlp, mean)
                    cl.p.locale <- match(names(mean.nlp), colnames(mem.mat))
                    mem.mat[cl,cl.p.locale] <- mean.nlp
                }
                rownames(mem.mat) <- cl.names
                pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
                tissue.names[i], "_Transcript_Clusters.pdf")), width = 20, height = 7)
                pheatmap(mem.mat, cluster_rows = FALSE, cluster_cols = FALSE)
                dev.off()
                go.summaries[[i]] <- mem.mat
            }

            #make a matrix of p values for each transcript and each
            #GO term. Sort by cluster and plot.
            term.mat <- matrix(0, nrow = nrow(bp.mat), ncol = length(all.trans.enrich))
            colnames(term.mat) <- names(all.trans.enrich)
            rownames(term.mat) <- colnames(bp.mat)
            for(tr in 1:length(all.trans.enrich)){
                trans.go <- all.trans.enrich[[tr]]$result[,"term_id"]
                if(length(trans.go) > 0){
                    trans.p <- all.trans.enrich[[tr]]$result[,"p_value"]
                    common.terms <- intersect(colnames(bp.mat), trans.go)
                    common.table.locale <- match(common.terms, trans.go)
                    common.mat.locale <- match(common.terms, rownames(bp.mat))
                    term.mat[common.mat.locale,tr] <- -log10(trans.p[common.table.locale])
                }
            }

            if(length(big.c) > 0){
                #put the term matrix in order of big clusters
                #put all the small clusters at the end
                cl.list <- cl.df <- vector(mode = "list", length = length(big.c)+1)
                for(cl in 1:length(big.c)){
                    cl.go <- bp.df[which(bp.df[,3] == names(big.c)[cl]),1]
                    cl.list[[cl]] <- match(cl.go, rownames(term.mat))
                    cl.df[[cl]] <- rep(cl, length(cl.go))
                }
                cl = cl + 1
                misc.clust <- setdiff(1:nrow(term.mat), unlist(cl.list))
                cl.go <- rownames(term.mat)[misc.clust]
                cl.list[[cl]] <- match(cl.go, rownames(term.mat))
                cl.df[[cl]] <- rep(cl, length(cl.go))

                cl.order <- unlist(cl.list)
                cluster <- data.frame(as.factor(unlist(cl.df)))
                rownames(cluster) <- rownames(term.mat)[cl.order]

                pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
                tissue.names[i], "_Transcript_Membership.pdf")), width = 7, height = 7)    
                par(mar = c(6, 20, 2, 2))
                imageWithText(term.mat[cl.order,], use.pheatmap.colors = TRUE, show.text = FALSE,
                row.names = NULL, col.text.cex = 0.5)
                #draw boxes around clusters
                top.y <- nrow(term.mat)
                min.x <- 0
                max.x <- ncol(term.mat)+1
                key.width <- (max.x - min.x)/20
                for(cl in 1:length(cl.list)){
                    bottom.y <- top.y - length(cl.list[[cl]])
                    draw.rectangle(min.x, max.x, top.y, bottom.y, border.col = "white", fill = NA)
                    draw.rectangle(min.x-key.width, min.x, top.y, bottom.y, 
                    border.col = "white", fill = cluster.col[(cl%%length(cluster.col)+1)])
                    if(cl < length(cl.list)){cl.label = cl.names[cl]}else{cl.label = "Other"}
                    text(x = min.x - (1.5*key.width), y = mean(c(top.y, bottom.y)), 
                    labels = cl.label, cex = 0.5, adj = 1)
                    top.y <- bottom.y
                }
                dev.off()

                plot.network = FALSE
                if(plot.network){
                    pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
                    tissue.names[i], "_Network.pdf")), width = 10, height = 10)    
                    in.big.cl <- bp.df[which(bp.df[,3] %in% names(big.c)),]
                    big.go <- in.big.cl[,1]
                    go.adj <- bp.mat[match(big.go, rownames(bp.mat)), match(big.go, colnames(bp.mat))]
                    diag(go.adj) <- 0
                    #hist(go.adj^4, breaks = 100)
                    go.adj[which(go.adj^1 < 0.05)] <- 0
                    go.net <- graph_from_adjacency_matrix(go.adj, weighted = TRUE, mode = "undirected")
                    V(go.net)$name = in.big.cl[,2]
                    go.deg <- degree(go.net)
                    to.remove <- which(go.deg == 0)
                    to.keep <- setdiff(1:length(go.deg), to.remove)
                    if(length(to.remove) > 0){
                        go.net <- delete_vertices(go.net, to.remove)
                    }
                    e.col <- colors.from.values(E(go.net)$weight, use.pheatmap.colors = TRUE)

                    mods <- mod.col <- in.big.cl[to.keep,3]
                    u_mods <- unique(mods)
                    for(m in 1:length(u_mods)){mod.col[which(mods == u_mods[m])] <- cluster.col[m+1]}
                    plot(go.net, layout = layout_nicely, vertex.color = mod.col, 
                    vertex.size = 5, vertex.label = NA, edge.width = E(go.net)$weight,
                    edge.color = e.col)
                    dev.off()
                }
            }
        } #end case for having enrichment
    } #end looping through tissues
}
```

## Traits and Terms Networks

Here we visualize the enrichments in a different way. We want to see
how the traits and terms are associated with processes. The following
code plots networks to pdfs with the prefix Bip. These figures show
the trait contributions to each composite trait as well as a large 
network that shows how the composite transcripts relate to the original
traits as well as to biological processes. The nodes representing 
GO term enrichments are 

```{r trait_term, warning = FALSE, message = FALSE}
#I'm having trouble with pheatmap devices staying open 
#and making unfinished pdfs. This code is here and at 
#the bottom of the loop to make sure we close pdfs
#from this and previous runs.

any.open <- dev.list()
while(length(any.open) > 0){
    dev.off()
    any.open <- dev.list()
}

enrich.bips <- vector(mode = "list", length = length(tissue.names))
names(enrich.bips) <- tissue.names

for(i in 1:length(tissue.names)){

    if(class(enrich.mats[[i]])[1] == "matrix"){
        enrich.bips[[i]] <- enrich_bipartite_proj(enrich.mat = enrich.mats[[i]], 
        vertex.col = "gray", label.vertex = NULL, label.col = "lightblue", 
        search.name = "partial")


        plot_decorated_bip(tissue.full.bip = enrich.bips[[i]], 
        tissue.mats = matched.mats[[i]], tissue.results = boot.CCA.results[[i]],
        file.path(results.dir, paste0("Bip_", tissue.names[i], ".", file.text, ".pdf")),
        fig.width = 30, fig.height = 30)
    }
}

any.open <- dev.list()
while(length(any.open) > 0){
    dev.off()
    any.open <- dev.list()
}

```




## QTL mapping composite transcripts {.tabset .tabset-fade .tabset-pills}

We used qtl2 to map each of the composite traits and 
each of the composite transcripts.

```{r map_transcripts, results = "asis", fig.height = 7, fig.width = 7}
qtl.results <- vector(mode = "list", length = length(tissue.names))
names(qtl.results) <- tissue.names

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(boot.CCA.results[[i]]) > 1){

        trait.trans <- get_latent_var(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]])

        has.vals <- intersect(which(colSums(trait.trans$Composite_Transcripts) != 0),
            which(colSums(trait.trans$Composite_Traits) != 0))

        pheno.trans.cor <- sapply(has.vals, 
        function(x) apply(matched.mats[[i]]$Z, 2, 
        function(y) cor(trait.trans$Composite_Transcripts[,x], y)))
        colnames(pheno.trans.cor) <- colnames(trait.trans$Composite_Transcripts)[has.vals]

        if(length(has.vals) > 1){
            pheatmap(pheno.trans.cor, main = "Correlations Between Composite 
            Transcripts and Physiological Traits", display_numbers = TRUE,cluster_cols = FALSE)
        }

        pheno.trait.cor <- sapply(has.vals, 
        function(x) apply(matched.mats[[i]]$Z, 2, function(y) cor(trait.trans$Composite_Traits[,x], y)))
        colnames(pheno.trait.cor) <- colnames(trait.trans$Composite_Traits)[has.vals]
    
        if(length(has.vals) > 1){
            pheatmap(pheno.trait.cor, main = "Correlations Between Composite 
            Traits and Physiological Traits", display_numbers = TRUE, cluster_cols = FALSE)
        }

        if(length(has.vals) == 1){
            pheatmap(cbind(pheno.trans.cor, pheno.trait.cor), main = "Correlations Between CTs and Phenotypes")
        }

        qtl.file <- file.path(results.dir, paste0("QTL.", tissue.names[i], ".", file.text, ".RDS"))
        if(!file.exists(qtl.file) || delete_previous){
            tissue.ctranscript.qtl <- scan1(genoprobs, 
                trait.trans$Composite_Transcripts[,has.vals,drop=FALSE], kinship = K)
            tissue.ctrait.qtl <- scan1(genoprobs, 
                trait.trans$Composite_Traits[,has.vals,drop=FALSE], kinship = K)
            tissue.qtl <- list("CTranscript_QTL" = tissue.ctranscript.qtl, 
            "CTrait_QTL" = tissue.ctrait.qtl)
            qtl.results[[i]] <- tissue.qtl
            saveRDS(tissue.qtl, qtl.file)
        }else{
            qtl.results[[i]] <- readRDS(qtl.file)
        }



        for(j in 1:ncol(qtl.results[[i]][[1]])){
            if(j == 1){cat("\n\n")}
            cat("#### Composite Transcript", j, "\n")
            if(is.interactive){quartz(width = 8, height = 8)}
            par(mfrow = c(2,1))
            plot(qtl.results[[i]][[1]], j, map = map, main = paste("Composite Transcript", j))
            plot(qtl.results[[i]][[2]], j, map = map, main = paste("Composite Trait", j))
            cat("\n\n")
        } 

    }
cat("\n\n")
}
```


## Composite Transcript LOD Score Heatmaps {.tabset .tabset-fade .tabset-pills}

The following figures show heatmaps comparing the LOD score 
traces of the composite transcripts and composite traits.

I'm still working on getting something for this...

```{r lodheat, fig.width = 11, fig.height = 6, results = "asis"}
chr.table <- matrix(NA, ncol = 2, nrow = length(map))
start.pos = 1
for(i in 1:length(map)){
    chr.table[i,1] <- start.pos
    chr.table[i,2] <- start.pos + length(map[[i]]) - 1
    start.pos <- start.pos + length(map[[i]])
}

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(qtl.results[[i]][[1]]) > 0){
        #if(is.interactive){quartz(width = 10, height = 5)}
        
        trait.trans.qtl <- lapply(qtl.results[[i]], t)
        for(j in 1:nrow(trait.trans.qtl[[1]])){
            cat("#### CT", j, "\n")
            if(is.interactive){quartz(width = 11, height = 6)}
            one.comp <- cbind(qtl.results[[i]][[1]][,j], qtl.results[[i]][[2]][,j])

            par(mfrow = c(2,1))
            par(mar = c(0,2,2,2))
            ylim <- c(0, max(one.comp))
            plot(one.comp[,1], type = "h", axes = FALSE, ylim = ylim, xlab = "", 
            cex = 0.7, main = paste("Composite Trait and Transcript", j))
            abline(v = chr.table[,2], col = "gray")
            abline(h = 6, col = "gray", lty = 2)
            mtext(side = 4, text = paste("Composite Transcript", j), line = -1.5)
            axis(2)
            
            par(mar = c(4,2,0,2))
            plot(one.comp[,2], type = "h", ylim = ylim, axes = FALSE, xlab = "",
            cex = 0.7)
            abline(v = chr.table[,2], col = "gray")
            abline(h = 6, col = "gray", lty = 2)
            mtext(side = 4, text = paste("Composite Trait", j), line = -1.5)
            axis(2)

            par(xpd = TRUE)
            text(y = rep(-0.5, nrow(chr.table)), x = rowMeans(chr.table), 
            labels = 1:nrow(chr.table))
            par(xpd = FALSE)
            cat("\n\n")
        }    
    }
    cat("\n\n")
}

```


```{r all_lod}

all.transcript.qtl.names <- unlist(lapply(1:length(tissue.names), 
    function(x) paste0(tissue.names[x], colnames(qtl.results[[x]][[1]]))))
all.trait.qtl.names <- unlist(lapply(1:length(tissue.names), 
    function(x) paste0(tissue.names[x], colnames(qtl.results[[x]][[2]]))))
all.qtl.transcripts <- Reduce("cbind", lapply(qtl.results, function(x) x[[1]]))
all.qtl.traits <- Reduce("cbind", lapply(qtl.results, function(x) x[[2]]))
colnames(all.qtl.transcripts) <- all.transcript.qtl.names
colnames(all.qtl.traits) <- all.trait.qtl.names
rownames(all.qtl.transcripts) <- rownames(all.qtl.traits) <- rownames(qtl.results[[1]][[1]])

#find the trait-transcript pairs where both in the pair were mapped
common.pairs <- intersect(gsub("Trait", "", colnames(all.qtl.traits)), gsub("Transcript", "", colnames(all.qtl.transcripts)))
common.trait.idx <- match(common.pairs, gsub("Trait", "", colnames(all.qtl.traits)))
common.transcript.idx <- match(common.pairs, gsub("Transcript", "", colnames(all.qtl.transcripts)))

max.lod <- 8

transcript.lod.file <- file.path(results.dir, "all_qtl.transcripts.pdf")
if(!file.exists(transcript.lod.file) || delete_previous){
    qtl.transcripts <- all.qtl.transcripts[,common.transcript.idx]
    qtl.transcripts[which(qtl.transcripts > max.lod)] <- max.lod
    pdf(transcript.lod.file, width = 12, height = 5)
    multilod.plot(qtl.transcripts, map, lod.thresh = 0, chr.label.y = 0, 
        chr.label.cex = 1, row.names = colnames(all.qtl.transcripts)[common.transcript.idx],
        mar = c(2, 12, 2, 0), global.color.scale = TRUE, global.min = 4, 
        global.max = max.lod)
    dev.off()
}

trait.lod.file <- file.path(results.dir, "all_qtl.traits.pdf")
if(!file.exists(trait.lod.file) || delete_previous){
    qtl.traits <- all.qtl.traits[,common.transcript.idx]
    qtl.traits[which(qtl.traits > max.lod)] <- max.lod

    pdf(trait.lod.file, width = 12, height = 5)
    multilod.plot(qtl.traits, map, lod.thresh = 0, chr.label.y = 0, 
        chr.label.cex = 1, row.names = colnames(all.qtl.traits)[common.trait.idx],
        mar = c(2, 12, 2, 0),global.color.scale = TRUE, global.min = 4, 
        global.max = max.lod)
    dev.off()
}

#imageWithTextColorbar(matrix(1:max.lod,ncol=1), global.color.scale = TRUE, global.min = 4, global.max = max.lod, col.scale = "blue", cex = 1, axis.line = 0, orientation = "h")
```

## Allele Coefficients for Matched QTL {.tabset .tabset-fade .tabset-pills}

We are most interested in trait-transcript pairs that have shared QTL.
Here we go through each pair and identify overlapping peaks above
a given threshold. We then perform a mediation analysis to test 
whether the allele effects match. We 
We then plot the allele effects of the two to see
if they match.

```{r allele_plots}
shared.peaks <- vector(mode = "list", length = length(tissue.names))
names(shared.peaks) <- tissue.names

for(i in 1:length(tissue.names)){
    
    if(length(qtl.results[[i]][[1]]) > 0){
        shared.tissue.peaks <- NULL

        transcript.peak.table <- find_peaks(qtl.results[[i]][[1]], 
        map = map, threshold = lodthresh, prob = 0.95)
        trait.peak.table <- find_peaks(qtl.results[[i]][[2]], 
        map = map, threshold = lodthresh, drop = 0.95)

        shared.traits <- intersect(transcript.peak.table[,"lodindex"], trait.peak.table[,"lodindex"])
        
        #identify peaks within the Mb limit
        for(tr in 1:length(shared.traits)){
            tr.trait <- transcript.peak.table[which(transcript.peak.table[,"lodindex"] == shared.traits[tr]),]
            tr.transcript <- trait.peak.table[which(trait.peak.table[,"lodindex"] == shared.traits[tr]),]
            tr.pairs <- cbind(rep(1:nrow(tr.trait), nrow(tr.transcript)), rep(1:nrow(tr.transcript), each = nrow(tr.trait)))
            for(p in 1:nrow(tr.pairs)){
                trait.pair <- tr.pairs[p,1]
                trans.pair <- tr.pairs[p,2]
                if(tr.trait[trait.pair,"chr"] == tr.transcript[trans.pair,"chr"]){
                    peak1.mb <- tr.trait[trait.pair,"pos"]
                    peak2.mb <- tr.transcript[trans.pair,"pos"]
                    peaks.overlap <- (abs(peak1.mb - peak2.mb) <= peak.dist)
                    if(peaks.overlap){
                        shared.info <- matrix(c(unlist(tr.transcript[trans.pair,]), 
                        unlist(tr.trait[trait.pair,])), nrow = 1)
                        shared.tissue.peaks <- rbind(shared.tissue.peaks, shared.info)
                    } #end case when peaks overlap within Mb limit
                } #end case for when peaks are on same chromosome
            }#end looping through tr pairs
        }#end looping through shared traits
    shared.peaks[[i]] <- shared.tissue.peaks
    #plot(as.numeric(shared.tissue.peaks[,5]), as.numeric(shared.tissue.peaks[,12]))
    }
}
```


```{r plot_shared, results = "asis", fig.height = 9, fig.width = 11}
all.lod.drop <- vector(mode = "list", length = length(tissue.names))
names(all.lod.drop) <- tissue.names
for(i in 1:length(shared.peaks)){
    if(is.interactive){pdf(file.path(results.dir, 
    paste0("Overlapping.Peaks.", tissue.names[i], ".pdf")), width = 10, height = 6)}
    if(length(shared.peaks[[i]]) > 0){
        cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
        lod.drop.table <- matrix(NA, nrow = nrow(shared.peaks[[i]]), ncol = 5)
        colnames(lod.drop.table) <- c("chr", "pos", "original", "mediated", "percent_drop")
        rownames(lod.drop.table) <- shared.peaks[[i]][,2]
        
        for(tr in 1:nrow(shared.peaks[[i]])){

            trait.trans <- get_latent_var(tissue.mats = matched.mats[[i]], 
                tissue.results = boot.CCA.results[[i]])

            CT = as.numeric(gsub("Composite_Trait", "", shared.peaks[[i]][tr,2]))
            chr = as.numeric(shared.peaks[[i]][tr,3])
            pos.trait.qtl <- as.numeric(shared.peaks[[i]][tr,4])
            trait.qtl.lod <- as.numeric(shared.peaks[[i]][tr,5])
            peak.marker <- get.nearest.pt(map[[chr]], pos.trait.qtl)
            pos.transcript.qtl <- as.numeric(shared.peaks[[i]][tr,11])
            if(chr == 20){chr = "X"}

            trans <- trait.trans$Composite_Transcripts[,CT,drop=FALSE]
            ctrait <- trait.trans$Composite_Traits[,CT,drop=FALSE]

            mediation.scan.file <- file.path(results.dir, 
                paste0("Mediation.QTL.", tissue.names[i], ".", shared.peaks[[i]][tr,2], 
                ".Chr.", shared.peaks[[i]][tr,3], ".RDS"))

            if(!file.exists(mediation.scan.file) || delete_previous){
                #scan to see if the transcript mediates the trait QTL
                adj.trait <- adjust(ctrait, trans)
                adj.scan <- scan1(genoprobs[,chr], adj.trait, kinship = K[[chr]])
                saveRDS(adj.scan, mediation.scan.file)
            }else{
                adj.scan <- readRDS(mediation.scan.file)
            }

            med.lod <- adj.scan[peak.marker,1]
            perc.drop <- (trait.qtl.lod-med.lod)/trait.qtl.lod
            lod.drop.table[tr,] <- c(as.numeric(shared.peaks[[i]][tr,3:4]), trait.qtl.lod, med.lod, perc.drop)

            #if the percent drop is greater than the threshold run the blups to visualize the 
            #allele effects
            if(perc.drop > perc.drop.thresh){
                cat("####", shared.peaks[[i]][tr,2], ", Chr", shared.peaks[[i]][tr,3], "\n")

                individual.scan.file <- file.path(results.dir, 
                    paste0("Individual.QTL.", tissue.names[i], ".", shared.peaks[[i]][tr,2], 
                    ".Chr.", shared.peaks[[i]][tr,3], ".RDS"))

                if(!file.exists(individual.scan.file) || delete_previous){
                
                    #map the transcript
                    transcript.lod <- scan1(genoprobs[,chr], trans, kinship = K[[chr]])
                    #find_peaks(transcript.lod, map = map, threshold = 5, prob = 0.95)
                    #transcript.coef <- scan1coef(genoprobs[,chr], trans, kinship = K[[chr]])
                    transcript.coef <- scan1blup(genoprobs[,chr], trans, kinship = K[[chr]])
            
                    #map the trait too
                    trait.lod <- scan1(genoprobs[,chr], ctrait, kinship = K[[chr]])
                    #find_peaks(trait.lod, map = map, threshold = 5, prob = 0.95)
                    #trait.coef <- scan1coef(genoprobs[,chr], ctrait)
                    trait.coef <- scan1blup(genoprobs[,chr], ctrait, kinship = K[[chr]])
                
                    result <- list("Transcript_LOD" = transcript.lod, 
                    "Transcript_Coef" = transcript.coef, 
                    "Trait_LOD" = trait.lod, 
                    "Trait_Coef" = trait.coef)

                    saveRDS(result, individual.scan.file)
                }else{
                    result <- readRDS(individual.scan.file)
                    transcript.lod = result$Transcript_LOD
                    transcript.coef <- result$Transcript_Coef
                    trait.lod <- result$Trait_LOD
                    trait.coef <- result$Trait_Coef
                }
            
           
                #plot the results
                layout.mat <- matrix(c(1,1,2,2,3,3,4,4,5,0,0,0), nrow = 3, byrow = TRUE)
                layout(layout.mat)
                par(mar = c(2,2,2,2))
                plot(transcript.lod, map = map, main = paste("Transcript QTL"))
                abline(v = pos.transcript.qtl)
                
                plot_coefCC(transcript.coef, map = map)
                abline(v = pos.transcript.qtl)
                mtext(paste("CTranscript", CT, "Chr", chr), side = 3, outer = TRUE, line = -2)
                #cat("\n\n")

                plot(trait.lod, map = map, main = "Trait QTL")
                abline(v = pos.trait.qtl)
                plot_coefCC(trait.coef, map = map)
                abline(v = pos.trait.qtl)
                #mtext(paste0("CTrait: ", trait, ", Chr: ", chr), side = 3, 
                #outer = TRUE, line = -2)

                #compare allele coefficients for the trait and transcript
                chr.pos.trait <- as.numeric(sapply(strsplit(rownames(trait.coef), "_"), function(x) x[2]))
                nearest.trait.marker <- get.nearest.pt(chr.pos.trait, pos.trait.qtl*1e6)
                trait.allele <- trait.coef[nearest.trait.marker,LETTERS[1:8]]
                
                chr.pos.trans <- as.numeric(sapply(strsplit(rownames(transcript.coef), "_"), function(x) x[2]))
                nearest.trans.marker <- get.nearest.pt(chr.pos.trans, pos.transcript.qtl*1e6)
                transcript.allele <- transcript.coef[nearest.trans.marker,LETTERS[1:8]]
                plot.with.model(trait.allele, transcript.allele, pch = 16, col = CCcolors,
                xlab = "Trait Coefficients", ylab = "Transcript Coefficients", cex = 2)
        
                cat("\n\n")
            }#end case for passing lod drop threshold
        } #end looping through shared peaks for the tissue
    all.lod.drop[[i]] <- lod.drop.table
    }  #end looping through tissues
    if(is.interactive){dev.off()}
}
```


## All Together {.tabset .tabset-fade .tabset-pills}

In this analysis we care about the confluence of good QTL, good functional 
enrichments, and good trait contributions. So far we don't have a way of 
really showing those all together. The following code attempts to put all
this information into a single page. The results are saved to pdfs in the
appropriate results folder. They are called All.Together.TissueName.pdf.

```{r all_together_fun}
plot.all.together <- function(tissue.mats, tissue.results, tissue.enrich.summary,
    tissue.qtl, tissue.gene.list, tissue.expr, tissue.info){

    trait.loadings <- tissue.results$v
    transcript.loadings <- tissue.results$u
    trait.description <- get_trait_description(tissue.mats, tissue.results, 
    short_version = TRUE)
    rownames(trait.loadings) <- colnames(tissue.mats$Z)
    colnames(trait.loadings) <- trait.description
    has.vals <- intersect(which(colSums(transcript.loadings) != 0), which(colSums(trait.loadings) != 0))

    latent_trait_trans <- get_latent_var(tissue.mats, tissue.results)

    for(ct in has.vals){
        cat("#### CT", ct, "\n")
        
        layout.mat <- matrix(c(1,7,2,3,5,5,5,4,6,6,6,4), nrow = 3, byrow = TRUE)
        layout(layout.mat, heights = c(1, 0.7, 0.7), widths = c(0.7, 1, 1))
        
        #1 - plot trait contributions to composite trait
        par(mar = c(4, 8, 4, 2))
        have.contributions <- which(trait.loadings[,ct] != 0)
        loading.order <- order(trait.loadings[have.contributions,ct])
        barplot(t(trait.loadings[have.contributions[loading.order],ct,drop=FALSE]), 
        las = 2, main = paste("CT", ct, "Trait Contributions"), horiz = TRUE, 
        col = "gray", cex.names = 0.7)

        #2 and 3 - plot enrichment wordclouds
        par(mar = c(2, 2, 2, 2))
        if(length(tissue.enrich.summary[[2]]) > 0){
            up.down.colors <- colors.from.values(c(-1, 0, 1), col.scale = c("blue", "brown"), 
                split.at.vals = TRUE, split.points = 0, grad.dir = "ends")
            #barplot(1:length(up.down.colors), col = up.down.colors)
            ct.up.locale <- which(names(tissue.enrich.summary[[2]]) == paste0("Transcript", ct, "_up"))
            ct.down.locale <- which(names(tissue.enrich.summary[[2]]) == paste0("Transcript", ct, "_down"))
            plot.enrichment.wordcloud(tissue.enrich.summary[[2]][[ct.up.locale]], 
                plot.label = names(tissue.enrich.summary[[2]])[ct.up.locale], 
                just.wordcloud = TRUE, colors = up.down.colors[3])
            plot.enrichment.wordcloud(tissue.enrich.summary[[2]][[ct.down.locale]], 
                plot.label = names(tissue.enrich.summary[[2]])[ct.down.locale], 
                just.wordcloud = TRUE, colors = up.down.colors[1])
        }

        #4 - plot expression decomposition
        gene.idx <- which(transcript.loadings[,ct] != 0)
        gene.id <- colnames(tissue.mats$X)[gene.idx]
        gene.names <- tissue.info[match(gene.id, tissue.info[,1]),"symbol"]
        ct.loadings <- transcript.loadings[gene.idx,ct]
        names(ct.loadings) <- gene.names

        gene.expr <- tissue.expr[,gene.idx,drop=FALSE]
        colnames(gene.expr) <- gene.names
        #pheatmap(t(gene.expr), show_colnames = FALSE)
        #pheatmap(t(gene.expr[,which(ct.loadings < 0)]), show_colnames = FALSE)
        #pheatmap(t(gene.expr[,which(ct.loadings > 0)]), show_colnames = FALSE)
        #pheatmap(cor(gene.expr))
        #pheatmap(cor(gene.expr[,which(ct.loadings < 0)]))
        #pheatmap(cor(gene.expr[,which(ct.loadings > 0)]))
        #plot.decomp(t(gene.expr[,which(ct.loadings < 0)]), label.points = TRUE)
        #plot.decomp(t(gene.expr[,which(ct.loadings > 0)]), label.points = TRUE)
        #plot.decomp(cor(gene.expr[,which(ct.loadings < 0)]), label.points = TRUE)
        #plot.decomp(cor(t(gene.expr[,which(ct.loadings > 0)])), label.points = TRUE)
        #plot.decomp(cor(t(gene.expr[,which(ct.loadings > 0)])), label.points = TRUE)


        if(ncol(gene.expr) <= 5){        
            plot.text(paste(paste(gene.names, collapse = "\n")))
        }

        if(ncol(gene.expr) > 5 && ncol(gene.expr) <= 50){
            expr.cor <- cor(gene.expr)
            col.order <- hclust(dist(expr.cor))$order
            par(mar = c(4, 2, 2, 0))
            if(all(sign(expr.cor) == 1) || all(sign(expr.cor) == -1)){
                imageWithText(expr.cor[col.order,col.order], split.at.vals = FALSE, 
                col.scale = "blue", show.text = FALSE, grad.dir = "high",
                col.text.shift = 1, row.text.shift = 1, row.text.cex = 0.6, col.text.cex = 0.6)
            }else{
                imageWithText(expr.cor[col.order,col.order], split.at.vals = TRUE, 
                col.scale = c("blue", "red"), show.text = FALSE, grad.dir = "ends",
                col.text.shift = 1, row.text.shift = 1, row.text.cex = 0.6, col.text.cex = 0.6)
            }
            par(xpd = FALSE)
        }
        #plot the decomposition of the gene expression matrix. 
        #color based on loadings, and label the genes with the five
        #largest magnitudes in both directions.
        if(ncol(gene.expr) > 50){

            expr.col <- colors.from.values(transcript.loadings[gene.idx,ct], split.at.vals = TRUE,
                split.points = 0, col.scale = c("blue", "brown"), grad.dir = "ends")

            par(mar = c(4,4,4,1))
            ct.decomp <- plot.decomp(t(gene.expr), cols = expr.col, main = "Transcript PCs")

            top.high <- which(ct.loadings >= sort(ct.loadings, decreasing = TRUE)[5]) 
            top.low <- which(ct.loadings <= sort(ct.loadings, decreasing = FALSE)[5]) 
            text(x = ct.decomp$u[top.high,1], y = ct.decomp$u[top.high,2], 
                labels = names(ct.loadings)[top.high], pos = 4, offset = 0.1)
            text(x = ct.decomp$u[top.low,1], y = ct.decomp$u[top.low,2], 
                labels = names(ct.loadings)[top.low], pos = 4, offset = 0.1)


            #I tried mapping the first two PCs of the expression matrix
            #it doesn't look very interesting. The first PC looks essentially
            #identical to the map of the CTranscript. The second is similar,
            #but a little messier.
            #expr.decomp <- plot.decomp(gene.expr)
            #expr.pc <- expr.decomp$u
            #rownames(expr.pc) <- names(expr.decomp$rows.used)
            #colnames(expr.pc) <- c("PC1", "PC2")
            #expr.scan <- scan1(genoprobs, expr.pc, kinship = K)
            #quartz();plot(expr.scan, map = map, lodcol = 1, main = "Expr PC1")
            #quartz();plot(expr.scan, map = map, lodcol = 2, main = "Expr PC2")

        }

        #5-6 transcript and trait mapping
        lod.mat <- cbind(tissue.qtl[[2]][,colnames(latent_trait_trans[[1]])[ct]], 
            tissue.qtl[[1]][,colnames(latent_trait_trans[[2]])[ct]])
        mark.locale <- Reduce("intersect", apply(lod.mat, 2, function(x) which(x > lodthresh)))
        par(mar = c(4,4,2,4))
        plot(tissue.qtl[[2]], map = map, lodcol = colnames(latent_trait_trans[[1]])[ct], 
            main = "Composite Trait QTL")
        plot.dim <- par("usr")
        points((mark.locale/nrow(lod.mat))*plot.dim[2], lod.mat[mark.locale,1], 
            pch = 16, col = "red", cex = 0.5)
        plot(tissue.qtl[[1]], map = map, lodcol = colnames(latent_trait_trans[[2]])[ct], 
            main = "Composite Transcript QTL")
        plot.dim <- par("usr")
        points((mark.locale/nrow(lod.mat))*plot.dim[2], lod.mat[mark.locale,2], pch = 16, 
            col = "red", cex = )


        


        #7 plot latent transcript-latent trait correlation
        plot.with.model(latent_trait_trans[[2]][,ct], latent_trait_trans[[1]][,ct],
        xlab = paste("Latent Transcript", ct), ylab = paste("Latent Trait", ct),
        report = "cor.test")
        cat("\n\n")
    }
}

```

```{r plot_all}
for(i in 1:length(tissue.names)){
    pdf(file.path(results.dir, paste0("All.together.", tissue.names[i], ".pdf")), width = 12, height = 7)
    tissue.gene.list <- get_transcript_list(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]])
    plot.all.together(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]], 
        tissue.enrich.summary = tissue.enrich[[i]],
        tissue.qtl = qtl.results[[i]], tissue.gene.list = tissue.gene.list, 
        tissue.expr = tissue.adj.expr[[i]], tissue.info = gene.info[[i]])
        dev.off()
}
```

## All together trait loadings

```{r tissue_trait_comparison, fig.height = 11, fig.width = 7}
all.loadings <- lapply(boot.CCA.results, function(x) x$v)
for(i in 1:length(all.loadings)){
    rownames(all.loadings[[i]]) <- colnames(matched.mats[[i]]$Z)
    colnames(all.loadings[[i]]) <- paste0(tissue.names[i], "_Trait", 1:ncol(all.loadings[[i]]))
}
loading.mat <- Reduce("cbind", all.loadings)

tissue.col <- data.frame(sapply(strsplit(colnames(loading.mat), "_"), function(x) x[1]))
colnames(tissue.col) <- "Tissue"
rownames(tissue.col) <- colnames(loading.mat)

row.order <- order(rownames(loading.mat))
#pdf("~/Desktop/loading_mat.pdf", width = 7, height = 11)
pheatmap(t(loading.mat), annotation_row = tissue.col)
pheatmap(t(loading.mat), annotation_row = tissue.col, cluster_rows = FALSE)
#dev.off()

#pheatmap(cor(loading.mat))
#has.vals <- which(rowSums(loading.mat) != 0)
#pheatmap(cor(t(loading.mat[has.vals,])))
```


```{r ind_cor, eval = FALSE}
#Compare canonical correlations to correlations between individual transcripts and traits.
#Does combining transcripts into composite transcripts improve the correlation with traits?
#this takes a little while to calculate, and I don't want to save the results, so 
#I'm setting eval = FALSE, only run if you need a figure for this.

straight.cor <- vector(mode = "list", length = length(tissue.names))
names(straight.cor) <- tissue.names
for(i in 1:length(matched.mats)){
    cat(tissue.names[i], "\n")
    trait.mat <- matched.mats[[i]]$Z
    expr.mat <- matched.mats[[i]]$X
    all.trait.cor <- lapply(1:ncol(trait.mat), function(x) apply(expr.mat, 2, function(y) cor(y, trait.mat[,x])))
    straight.cor[[i]] <- abs(unlist(all.trait.cor))
}

can.cors <- lapply(all.cancor, function(x) x["CCA",which(x["CCA",] > 0)])
boot.cors <- lapply(all.cancor, function(x) x["Boot",which(x["Boot",] > 0)])

plot.grouped.boxes(list("Canonical Correlations" = can.cors,
    "Bootstrapped Correlations" = boot.cors,
    "Transcript-Trait Correlations" = straight.cor), 
    legend.x = 10, legend.y = 0.9)

```



```{r check_eqtl, eval = FALSE}
gene.name = "Lep"
gene.name = "Fkbp11"
gene.id <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "gene.id"])
gene.chr <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "chr"])
gene.pos <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "start"])
gene.locale <- lapply(matched.mats, function(x) which(colnames(x$X) == unlist(gene.id)))
gene.eqtl <- lapply(1:length(gene.locale), 
    function(x) if(length(gene.locale[[x]] > 0)){scan1(genoprobs, 
    matched.mats[[x]]$X[,gene.locale[[x]]])}else{NA})
for(i in 1:length(gene.eqtl)){
    if(length(gene.eqtl[[i]]) > 1){
        if(is.interactive){quartz(width = 11, height = 7)}
        par(mfrow = c(2,1))
        plot(gene.eqtl[[i]], map = map, main = paste0(tissue.names[i], ": ", gene.name))
        chr.locale <- which(names(map) == gene.chr)
        allele.coef <- scan1coef(genoprobs[,chr.locale], matched.mats[[i]]$X[,gene.locale[[i]]])
        plot_coefCC(allele.coef, map = map)
        abline(v = as.numeric(gene.pos))
    }
}
```

## Some notes:

The composite transcripts are diverse in their makeup.
Some have just a single transcript, some have a few.
Some have many all with similarly high loadings. Others
have many transcripts, but only a few have large loadings.

Fkbp11 (chr 15) is the dominant gene in *islet* tissue. It appears in 
every composite transcript, sometimes all by itself.
Fkbp11 has a cis eQTL on Chr 15 in adipose tissue and skeletal muscle, 
but not in the other two tissues. In islet, it co-maps with the paired 
traits to Chr 13. 

Leptin (chr 6) is the dominant gene in *skeletal muscle*, opposing Cfd, 
and appearing with Slc5a7 (chr 17). There is only one trait-transcript 
pair that co-maps in skeletal muscle, but the allele effects don't match 
at all. 

Igfbp2 (chr 1, 72 Mbp) is the dominant gene in *liver*, opposing Mogat1 
(chr 1, 78 Mbp). The transcripts in the liver are mapping to Chr 11
around 100 Mb. (But the traits map to 83 Mb).
The transcripts also map to Chrs 4 and 1. 

Dominant genes in *adipose tissue* are Aldh2 (chr 5), Fam13a (Chr 6),
Itgax (Chr 7), Cfd (Chr 10), Slc43a1 (Chr 2) and Ubd (Chr 17).


## Mediation {.tabset .tabset-fade .tabset-pills}

In an attempt to identify QTGs in some of the overlapping QTLs, I am 
starting to develop a pipeline for looking at gene lists and mediation
of trait QTLs. 

We focus on QTLs for which the composite trait and composite 
transcript have LOD scores greater than `r lodthresh`, and the
composite transcript mediates the composite trait QTL by at least
`r perc.drop.thresh*100` percent.

```{r mediation, results = "asis", fig.width = 10, fig.height = 7}

for(i in 1:length(all.lod.drop)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    tissue.name <- tissue.names[i]
    if(length(all.lod.drop[[i]]) > 0){
        for(tr in 1:nrow(all.lod.drop[[i]])){
            CT <- as.numeric(gsub("Composite_Trait", "", rownames(all.lod.drop[[i]])[tr]))
            chr.num <- all.lod.drop[[i]][tr,"chr"]
            lod.cut <- all.lod.drop[[i]][tr,"percent_drop"]

            if(!is.na(lod.cut) && lod.cut > perc.drop.thresh){
                cat("####", rownames(all.lod.drop[[i]])[tr], "Chr", chr.num, "{.tabset .tabset-fade .tabset-pills}\n")
                #get data for specified tissue
                tissue.locale <- which(tissue.names == tissue.name)
                trait.trans <- get_latent_var(tissue.mats = matched.mats[[tissue.locale]], 
                    tissue.results = boot.CCA.results[[tissue.locale]])

                #scan specified CT on specified chromosome to find overlapping peaks
                if(chr.num == 20){
                    Chr <- "X"
                    }else{
                     Chr <- chr.num
                }

                trait.qtl <- scan1(genoprobs[,Chr], trait.trans$Composite_Traits[,CT,drop=FALSE], 
                    kinship = K[[chr.num]])
                transcript.qtl <- scan1(genoprobs[,Chr], 
                    trait.trans$Composite_Transcripts[,CT,drop=FALSE], kinship = K[[chr.num]])
                peak.pos <- all.lod.drop[[i]][tr,"pos"]
                nearest.marker <- get.nearest.pt(peak.pos, map[[chr.num]])

                #quartz(width = 10, height = 6)
                cat("##### Transcript and Trait Scans\n")
                par(mfrow = c(2,1))
                plot(trait.qtl, map = map, main = "CTrait")
                abline(v = peak.pos)
                plot(transcript.qtl, map = map, main = "CTranscript")
                abline(v = peak.pos)

                trait.peak.lod <- trait.qtl[nearest.marker,1]
                trait.peak.pos <- peak.pos
                transcript.peak.lod <- transcript.qtl[nearest.marker,1]
                transcript.peak.pos <- peak.pos

                #see if transcript mediates trait qtl
                adj.trait <- adjust(trait.trans$Composite_Traits[,CT,drop=FALSE], trait.trans$Composite_Transcripts[,CT,drop=FALSE])
                med.qtl <- scan1(genoprobs[,Chr], adj.trait, kinship = K[[chr.num]])

                cat("\n\n")
                #quartz(width = 10, height = 6)
                cat("##### Mediation Scan\n")
                layout(matrix(c(1,0), ncol = 1))
                #plot(transcript.qtl, map = map)

                med.ylim <- c(0, max(c(trait.qtl[,1], med.qtl[,1])))
                plot(trait.qtl, map = map, ylim = med.ylim)
                plot(med.qtl, map = map, add = TRUE, col = "red")
                segments(x0 = peak.pos, y0 = 0, y1 = 6, col = "blue", lwd = 2)

                #Identify transcripts with non-zero loadings
                non.zero.loadings <- which(boot.CCA.results[[tissue.locale]]$u[,CT] != 0)
                transcripts <- colnames(matched.mats[[tissue.locale]]$X)[non.zero.loadings]
                transcript.names <- gene.info[[tissue.locale]][match(transcripts, gene.info[[tissue.locale]][,1]),"symbol"]

                full.table <- cbind(transcript.names, transcripts, boot.CCA.results[[tissue.locale]]$u[non.zero.loadings,CT])
                loading.order <- order(as.numeric(full.table[,3]))

                chr.locale <- which(gene.info[[tissue.name]][,"chr"] == Chr)
                mb.locale <- intersect(which(as.numeric(gene.info[[tissue.name]][,"start"]) >= 40),
                                which(as.numeric(gene.info[[tissue.name]][,"end"]) <= 50))
                locus.genes <- gene.info[[tissue.name]][intersect(mb.locale, chr.locale),,drop=FALSE]

                #Mediate on all gene in the locus. 
                #Color genes that are also in the transcript red.
                #Intersect the lists to find any transcripts encoded in QTL
                #If there are some. Export the list and try using mediation
                #to identify which are most likely to be causal.
                #or use all as candidates

                locus.gene.name <- locus.genes[,"symbol"]
                overlap.genes <- intersect(transcript.names, locus.gene.name)
                gene.col <- rep("darkgray", length = length(locus.gene.name))
                if(length(overlap.genes) > 0){
                    gene.col[match(overlap.genes, locus.gene.name)] <- "red"
                }

                if(length(locus.gene.name) > 0){
                    #use the expression of each gene individually to mediate the effect of the locus on the trait
                    gene.id <- gene.info[[tissue.locale]][match(locus.gene.name, gene.info[[tissue.locale]][,"symbol"]),1]
                    gene.id <- gene.id[which(!is.na(gene.id))]
                    #gene.id <- transcripts #use all transcript IDs
                    gene.names <- gene.info[[tissue.locale]][match(gene.id, gene.info[[tissue.locale]][,1]),"symbol"]
                    gene.locale <- match(gene.id, colnames(matched.mats[[tissue.locale]]$X))
                    gene.pos <- as.numeric(gene.info[[tissue.locale]][match(gene.names, gene.info[[tissue.locale]][,"symbol"]), "start"])

                    mediated.lod <- matrix(NA, nrow = length(gene.locale), ncol = 2)
                    rownames(mediated.lod) <- gene.names
                    colnames(mediated.lod) <- c("CTrait", "CTranscript")
                    for(g in 1:length(gene.locale)){
                        if(is.interactive){cat(g, gene.names[g], "\n")}
                        adj.trait <- adjust(trait.trans$Composite_Traits[,CT,drop=FALSE], 
                            matched.mats[[tissue.locale]]$X[,gene.locale[g],drop=FALSE])
                        adj.transcript <- adjust(trait.trans$Composite_Transcripts[,CT,drop=FALSE],
                            matched.mats[[tissue.locale]]$X[,gene.locale[g],drop=FALSE])
                    
                        med.trait <- scan1(genoprobs[,Chr], adj.trait, kinship = K[[chr.num]])
                        mediated.lod[g,1] <- get_LOD(med.trait, map = map, chr = Chr, pos = trait.peak.pos)

                        med.transcript <- scan1(genoprobs[,Chr], adj.transcript, kinship = K[[chr.num]])
                        mediated.lod[g,2] <- get_LOD(med.transcript, map = map, chr = Chr, pos = transcript.peak.pos)

                        #plot(trait.qtl, map = map, ylim = c(0, max(c(unlist(trait.qtl), unlist(med.trait)))));plot(med.trait, map = map, add = TRUE, col = "red");abline(v = trait.peak.pos)
                        #plot(transcript.qtl, map = map, ylim = c(0, max(c(unlist(transcript.qtl), unlist(med.transcript)))));plot(med.transcript, map = map, add = TRUE, col = "red");abline(v = trait.peak.pos)
                    }

                    cat("\n\n")
                    cat("##### LOD Score Drops\n")
                    par(mfrow = c(2,1))
                    ylim = c(0, max(c(round(mediated.lod[,1], 2), trait.peak.lod, transcript.peak.lod)))
                    trait.med.order <- order(round(mediated.lod[,1], 2))
                    barplot_with_num(round(mediated.lod[trait.med.order,1]), 
                        main = "Mediated Trait Peaks", las = 2, text.gap = 0.2,
                        text.shift = 0.12, ylim = ylim, col = gene.col[trait.med.order])
                    abline(h = trait.peak.lod)
                    transcript.med.order <- order(round(mediated.lod[,2], 2))
                    barplot_with_num(round(mediated.lod[transcript.med.order,2], 2), 
                        main = "Mediated Transcript Peaks", las = 2, text.gap = 0.2,
                        text.shift = 0.12, ylim = ylim, col = gene.col[transcript.med.order])
                    abline(h = transcript.peak.lod)

                    cat("\n\n")
                    cat("##### Transcript vs. Trait LOD Drops\n")
                    plot(mediated.lod, pch = 16,
                        xlab = "Trait Mediated LOD", ylab = "Transcript Mediated LOD",
                        xlim = c(min(mediated.lod[,1]), ylim[2]), 
                        ylim = c(min(mediated.lod[,2]), ylim[2]), col = gene.col)
                    text(mediated.lod[,1], mediated.lod[,2], labels = gene.names, pos = 4)
                    abline(v = trait.peak.lod, h = transcript.peak.lod)             

                    #show heatmap of individual gene expression along with trait values
                    ct.expr <- matched.mats[[tissue.locale]]$X[,non.zero.loadings,drop=FALSE]
                    colnames(ct.expr) <- gene.info[[tissue.name]][match(colnames(ct.expr), gene.info[[tissue.name]][,1]),"symbol"]
                
                    ind.order <- order(trait.trans$Composite_Traits[,CT,drop=FALSE], decreasing = TRUE)

                    #scale expression across transcripts
                    scaled.expr <- apply(ct.expr, 2, rankZ)
                    #trans.order <- hclust(dist(t(scaled.expr)))$order
                    if(ncol(scaled.expr) > 1){
                        trans.order <- order(plot.decomp(t(scaled.expr), plot.results = FALSE)$u[,1])
                    }else{
                        trans.order <- 1
                    }

                    #plot without dendrogram
                    #png("~/Desktop/CT_transcripts_expression.png", width = 10, height = 4, units = "in", res = 200)
                    cat("\n\n")
                    cat("##### Transcripts by Trait\n")
                    layout(matrix(c(1,2), nrow = 1), widths = c(1,0.2))
                    par(mar = c(2,2,2,2))
                    imageWithText(scaled.expr[ind.order, trans.order,drop=FALSE], 
                        show.text = FALSE, use.pheatmap.colors = TRUE, col.names = NULL,
                        row.names = NULL)
                    par(mar = c(2,2,2,4))
                    imageWithText(trait.trans$Composite_Traits[ind.order,CT,drop=FALSE], 
                        show.text = FALSE, use.pheatmap.colors = TRUE, row.names = NULL)
                                

                    #look for eQTL among positional candidates
                    eqtl.lod <- rep(NA, length(gene.names))
                    names(eqtl.lod) <- gene.names
                    for(g in 1:length(gene.names)){
                        #cat(g, gene.names[g], "\n")
                        eqtl <- scan1(genoprobs[,Chr], matched.mats[[tissue.locale]]$X[,gene.locale[g],drop=FALSE], 
                            kinship = K[[chr.num]])
                        eqtl.lod[g] <- get_LOD(eqtl, map = map, chr = Chr, pos = gene.pos[g])
                        #plot(eqtl, map = map);abline(v = gene.pos[g])
                    }
                    cat("\n\n")
                    cat("##### Local eQTL LOD Scores\n")
                    layout(matrix(c(1,0), ncol = 1))
                    par(mar = c(8,4,2,2))
                    eqtl.order <- order(round(eqtl.lod, 2))
                    barplot_with_num(round(eqtl.lod, 2)[eqtl.order], las = 2, col = gene.col[eqtl.order])

                    #trait.peak.lod <- get_LOD(trait.qtl, map = map, chr = Chr, pos = trait.peak.pos)

                    cat("\n\n")
                } #end case for when there are genes to mediate on

            } #end case for when there is good mediation by the composite transcript
            cat("\n\n")
        } #end looping through rows of overlapping peaks
    cat("\n\n")
    } #end case for when there are overlapping peaks for the tissue
    cat("\n\n")
} #end looping through tissues.

```

```{r test, eval = FALSE}
#check best individual candidates for matching allele effects
#don't do too many here because blups take forever
check.alleles <- c("Sash3")
allele.check.id <- gene.info[[tissue.locale]][match(check.alleles, gene.info[[tissue.locale]][,"symbol"]),1]
allele.check.locale <- match(allele.check.id, colnames(matched.mats[[tissue.locale]]$X))
allele.check.start <- as.numeric(gene.info[[tissue.locale]][match(allele.check.id, gene.info[[tissue.locale]][,1]),"start"])

trait.blups <- scan1blup(genoprobs[,Chr], trait.trans$Composite_Traits[,CT,drop=FALSE], kinship = K[[chr.num]])

for(g in 1:length(check.alleles)){
    eqtl.lod <- scan1(genoprobs[,Chr], 
        matched.mats[[tissue.locale]]$X[,allele.check.locale[g],drop=FALSE], kinship = K[[chr.num]])
    eqtl.blups <- scan1blup(genoprobs[,Chr], 
        matched.mats[[tissue.locale]]$X[,allele.check.locale[g],drop=FALSE], kinship = K[[chr.num]])
   
    layout.mat <- matrix(c(1,1,2,2,3,3,4,0), nrow = 4, byrow = TRUE)
    layout(layout.mat)
    par(mar = c(1,1,1,1))
    plot(eqtl.lod, map = map)
    abline(v = allele.check.start[g])
    plot_coefCC(trait.blups, map = map)
    abline(v = allele.check.start[g])
    plot_coefCC(eqtl.blups, map = map)
    abline(v = allele.check.start[g])

    trait.allele.effects <- trait.blups[names(trait.peak.lod),][1:8]
    eqtl.allele.effects <- eqtl.blups[names(trait.peak.lod),][1:8]
    plot.with.model(trait.allele.effects, eqtl.allele.effects, col = CCcolors, 
        cex = 2, report = "cor.test")
}

#testing bulk mediation
#i=1;ct = 1;chr=20
#i=2;ct = 6;chr=20

#trait.trans <- get_latent_var(tissue.mats = matched.mats[[i]], tissue.results = boot.CCA.results[[i]])

#test.qtl <- scan1(genoprobs[,"X"], trait.trans$Composite_Traits[,ct,drop=FALSE], kinship = K[[chr]])
#gene.locale <- which(boot.CCA.results[[i]]$u[,ct] != 0) 
#gene.name <- gene.info[[i]][match(colnames(matched.mats[[i]]$X)[gene.locale], gene.info[[i]][,1]),"symbol"]
#adj.trait <- adjust(trait.trans$Composite_Traits[,ct,drop=FALSE], matched.mats[[i]]$X[,gene.locale,drop=FALSE])
#test.med <- scan1(genoprobs[,"X"], adj.trait, kinship = K[[chr]])
#par(mfrow = c(2,1))
#plot(test.qtl, map = map, main = "Original Scan", ylim = c(0, max(test.qtl)))
#plot(test.med, map = map, main = paste("Mediated by", length(gene.locale), "genes"), ylim = c(0, max(test.qtl)))

#play around with genes from FNTM
#I plugged Sash3 into the FNTM adipose network and pulled
#down the resulting related network of 50 genes.
fntm.genes <- read.csv("~/Downloads/network_weights.csv", stringsAsFactors = FALSE)
u_fntm <- unique(c(fntm.genes[,1], fntm.genes[,2]))
fntm.id <- gene.info[[tissue.locale]][match(u_fntm, gene.info[[tissue.locale]][,"symbol"]),1]
fntm.id <- fntm.id[which(!is.na(fntm.id))]
gene.id <- fntm.id

plotVenn(list("FNTM" = u_fntm, "Transcripts" = transcript.names))
```

Now I'm going to see if I can build the case for Sash3 from the bottom up.

```{r bottom_up, eval = FALSE}
#Is Sash3 expression correlated with any traits?
#gene.name = "Elf4"
gene.name = c("Sash3")
gene.id <- gene.info[[tissue.locale]][match(gene.name, gene.info[[tissue.locale]][,"symbol"]),1]
gene.idx <- match(gene.id, colnames(matched.mats[[tissue.locale]]$X))
gene.expr <- matched.mats[[tissue.locale]]$X[,gene.idx,drop=FALSE]

par(mfrow = c(1,2))
plot.with.model(gene.expr, trait.trans$Composite_Transcript[,CT,drop=FALSE], 
    xlab = paste(gene.name, "expression"), ylab = "Composite Transcript")

plot.with.model(gene.expr, trait.trans$Composite_Traits[,CT,drop=FALSE], 
    xlab = paste(gene.name, "expression"), ylab = "Composite Trait")

pdf("~/Desktop/Sash3.pdf", width = 5, height = 3.5)

layout(matrix(c(1,2), ncol = 2), widths = c(1, 0.2))
expr.color <- colors.from.values(gene.expr, use.pheatmap.colors = TRUE)

par(mar = c(4,4,4,4))

plot.with.model(trait.trans$Composite_Transcript[,CT,drop=FALSE], 
    trait.trans$Composite_Traits[,CT,drop=FALSE], col = "black",
    xlab = "Composite Transcript", ylab = "Composite Trait", 
    main = paste("Colored by", gene.name, "expression"), report = "cor.test")

par(mar = c(0,0,0,0))
plot.text("")

par(mar = c(4,4,4,4))
plot.with.model(trait.trans$Composite_Transcript[,CT,drop=FALSE], 
    trait.trans$Composite_Traits[,CT,drop=FALSE], col = expr.color,
    xlab = "Composite Transcript", ylab = "Composite Trait", 
    main = paste("Colored by", gene.name, "expression"), report = "cor.test")

#par(mar = c(15,2,4,2.5))
#par(mar = c(5,2,2,2.5))
par(mar = c(9,1,2,2))
imageWithTextColorbar(matrix(seq(-4, 4, 0.01), ncol = 1),
    use.pheatmap.colors = TRUE, axis.line = 0, cex = 0.7)
dev.off()


#get genotypes at peak QTL
marker.loc <- which(map[[Chr]] == transcript.peak.pos)
genotypes <- genoprobs[[Chr]][,,marker.loc]
common.ind <- intersect(rownames(gene.expr), rownames(genotypes))
genotype.locale <- match(common.ind, rownames(genotypes))
expr.ind.locale <- match(common.ind, rownames(gene.expr))
comp.ind.locale <- match(common.ind, rownames(trait.trans$Composite_Transcript[,CT,drop=FALSE]))

high.alleles <- c("D")
low.alleles <- c("F")
total.effect <- rowSums(genotypes[genotype.locale,low.alleles,drop=FALSE]*-1) + rowSums(genotypes[genotype.locale,high.alleles,drop=FALSE])

cast.col <- colors.from.values(genotypes[genotype.locale,"F"], col.scale = "green", grad.dir = "high")
nod.col <- colors.from.values(genotypes[genotype.locale,"D"], col.scale = "blue", grad.dir = "high")
aj.col <- colors.from.values(genotypes[genotype.locale,"A"], col.scale = "yellow", grad.dir = "high")
total.col <- colors.from.values(total.effect, use.pheatmap.colors = TRUE)

par(mfrow = c(1,3))
plot.with.model(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE], 
    trait.trans$Composite_Traits[comp.ind.locale,CT,drop=FALSE], col = cast.col,
    xlab = "Composite Transcript", ylab = "Composite Trait", main = "Colored by CAST allele",
    report = "cor.test")
boxplot(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"F"], 2),
    xlab = "CAST genotype", ylab = "Composite Transcript", main = "Transcript")
boxplot(trait.trans$Composite_Trait[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"F"], 2),
    xlab = "CAST genotype", ylab = "Composite Trait", main = "Trait")

par(mfrow = c(1,3))
plot.with.model(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE], 
    trait.trans$Composite_Traits[comp.ind.locale,CT,drop=FALSE], col = nod.col,
    xlab = "Composite Transcript", ylab = "Composite Trait", main = "Colored by NOD allele")
boxplot(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"D"], 1),
    xlab = "NOD genotype", ylab = "Composite Transcript", main = "Transcript")
boxplot(trait.trans$Composite_Trait[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"D"], 1),
    xlab = "NOD genotype", ylab = "Composite Trait", main = "Trait")

par(mfrow = c(1,3))
plot.with.model(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE], 
    trait.trans$Composite_Traits[comp.ind.locale,CT,drop=FALSE], col = aj.col,
    xlab = "Composite Transcript", ylab = "Composite Trait", main = "Colored by A/J allele")
boxplot(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"A"], 1),
    xlab = "A/J genotype", ylab = "Composite Transcript", main = "Transcript")
boxplot(trait.trans$Composite_Trait[comp.ind.locale,CT,drop=FALSE]~round(genotypes[genotype.locale,"A"], 1),
    xlab = "A/J genotype", ylab = "Composite Trait", main = "Trait")

par(mfrow = c(1,3))
plot.with.model(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE], 
    trait.trans$Composite_Traits[comp.ind.locale,CT,drop=FALSE], col = total.col,
    xlab = "Composite Transcript", ylab = "Composite Trait", main = "Colored by total allele effect")
boxplot(trait.trans$Composite_Transcript[comp.ind.locale,CT,drop=FALSE]~round(total.effect, 1),
    xlab = "total allele effect", ylab = "Composite Transcript", main = "Transcript")
boxplot(trait.trans$Composite_Trait[comp.ind.locale,CT,drop=FALSE]~round(total.effect, 1),
    xlab = "total allele effect", ylab = "Composite Trait", main = "Trait")



if(ncol(gene.expr) > 1){
    expr.decomp <- plot.decomp(gene.expr)
    expr.pc <- expr.decomp$u[,1, drop=FALSE]
    rownames(expr.pc) <- names(expr.decomp$rows.used)
}else{
    expr.pc <- gene.expr
}

trait.cor <- apply(matched.mats[[tissue.locale]]$Z, 2, function(x) cor(x, expr.pc))
barplot(sort(trait.cor), las = 2)

trait.name = "HOMA_IR_0min"
plot.with.model(expr.pc, matched.mats[[tissue.locale]]$Z[,trait.name], ylab = trait.name,
xlab = gene.name, report = "cor.test")

trait.scan <- scan1(genoprobs, matched.mats[[tissue.locale]]$Z[,trait.name,drop=FALSE], kinship = K)
plot(trait.scan, map = map, main = trait.name)

adj.trait <- adjust(matched.mats[[tissue.locale]]$Z[,trait.name,drop=FALSE], expr.pc)
adj.scan <- scan1(genoprobs, adj.trait, kinship = K)
plot(adj.scan, map = map, add = TRUE, col = "red")

#Sash3 partially mediates the Chr X LOD score for weight_6wks, and HOMA_IR_0min
#you wouldn't notice this unless we had concentrated the signals in a particular 
#way. The effect it weak but consistent.
```

## Loading by LOD {.tabset .tabset-fade .tabset-pills}

The following plots show imputed transcript loadings plotted
agains their eQTL LOD score in the DO. 

```{r eqtl, results = "asis"}
get_cis_lod <- function(transcript.id, eqtl.table, marker.chr, marker.pos, 
    bp.buffer = 4e6){

    trans.idx <- which(gene.table[,1] == transcript.id)[1]
    #gene.table[trans.idx,]
    trans.chr <- gene.table[trans.idx,"chr"]
    trans.start <- as.numeric(gene.table[trans.idx,"start"])
    trans.end <- as.numeric(gene.table[trans.idx,"end"])
    id.locale <- which(eqtl.table[,1] == transcript.id)
    #eqtl.table[id.locale,]
    on.chr <- which(marker.chr == trans.chr)
    above.min <- which(marker.pos >= (trans.start*1e6-bp.buffer))
    below.max <- which(marker.pos <= (trans.end*1e6+bp.buffer))
    cis.locale <- Reduce("intersect", list(id.locale, on.chr, above.min, below.max))
    if(length(cis.locale) == 1){
        cis.lod <- unlist(eqtl.table[cis.locale,"lod"])
    }else{
        cis.lod <- NA
    }
    return(cis.lod)
}

cis.lod.file <- here("Results", "CCA_clusters", exp.name, "cis.lod.scores.RDS")
if(!file.exists(cis.lod.file)){
    all.cis.lod <- vector(mode = "list", length = length(matched.mats))
    names(all.cis.lod) <- names(matched.mats)
    for(tx in 1:length(matched.mats)){
        tissue.name <- tissue.names[tx]
        if(is.interactive){cat(tissue.name, "\n")}
        tissue.eqtl <- get(paste0("dataset.DO.Cube.", tissue.name))$lod.peaks$additive
        split.lod.markers <- strsplit(unlist(tissue.eqtl[,"marker.id"]), "_")
        lod.marker.chr <- sapply(split.lod.markers, function(x) x[1])
        lod.marker.pos <- as.numeric(sapply(split.lod.markers, function(x) x[2]))
        all.cis.lod[[tx]] <- sapply(colnames(matched.mats[[tx]]$X), 
            function(x) get_cis_lod(x, eqtl.table = tissue.eqtl, 
            marker.chr = lod.marker.chr, 
            marker.pos = lod.marker.pos, bp.buffer = 4e6))
    }
    saveRDS(all.cis.lod, cis.lod.file)
}else{
    all.cis.lod  <- readRDS(cis.lod.file)
}

#plot the cis lod score for each transcript against its imputed transcript loading
for(tx in 1:length(matched.mats)){
    cat("###", names(matched.mats)[tx], "{.tabset .tabset-fade .tabset-pills}\n")
    lod.scores <- all.cis.lod[[tx]]
    lod.scores[which(is.na(lod.scores))] <- 3
    transcript.loadings <- boot.CCA.results[[tx]]$u
    for(ct in 1:ncol(transcript.loadings)){
        non.zero.idx <- which(transcript.loadings[,ct] != 0)
        if(length(non.zero.idx) > 0){
            cat("#### CT", ct, "\n")
            plot(lod.scores[non.zero.idx], transcript.loadings[non.zero.idx,ct], 
            xlab = "LOD Score", ylab = "Transcript CCA Loading", main = paste("CT", ct))
            abline(h = 0)
            gene.names <- gene.table[match(colnames(matched.mats[[tx]]$X)[non.zero.idx], gene.table[,1]),"symbol"]
            text(x = lod.scores[non.zero.idx], y = transcript.loadings[non.zero.idx,ct],
            labels = gene.names, pos = 3, cex = 0.7, offset = 0.2)
            cat("\n\n")
        }
    cat("\n\n")
    }
    #mtext(names(matched.mats)[tx], side = 3, outer = TRUE, line = -1.5)
}
```

## Loading by Position {.tabset .tabset-fade .tabset-pills}

The plots below show where the transcripts selected by CCA are positioned
in the genome.

```{r imputed_marker_position, fig.width = 10, fig.height = 5, results = "asis"}
for(tx in 1:length(matched.mats)){
    tissue.name <- tissue.names[tx]
    cat("###", tissue.name, "{.tabset .tabset-fade .tabset-pills}\n")
    transcript.loadings <- boot.CCA.results[[tx]]$u
    ymin <- min(transcript.loadings)
    ymax <- max(transcript.loadings)
    yheight <- ymax - ymin
    ylim = c(ymin-(yheight*0.1), ymax+(yheight*0.1))

    for(u in 1:ncol(transcript.loadings)){
        t.loading <- transcript.loadings[,u]
        non.zero <- which(t.loading != 0)
        if(length(non.zero) == 0){next()}
        cat("#### CT", u, "\n")
        if(is.interactive){quartz(width = 12, height = 5)}
        transcript.id <- colnames(matched.mats[[tx]]$X)[non.zero]
        transcript.idx <- match(transcript.id, gene.table[,1])
        transcript.chr <- gene.table[transcript.idx,"chr"]
        transcript.pos <- as.numeric(gene.table[transcript.idx,"start"])
            
        layout(matrix(1:19, nrow = 1))
        for(ch in 1:19){
            if(ch == 1){par(mar = c(4,2,4,0))}else{par(mar = c(4,1,4,0))}
            chr.transcripts <- which(transcript.chr == ch)
            transcript.names <- gene.table[match(transcript.id[chr.transcripts], gene.table[,1]),"symbol"]
            if(length(chr.transcripts) > 0){
                ch.pos <- transcript.pos[chr.transcripts]
                min.pos <- min(ch.pos)
                max.pos <- max(ch.pos)
                pos.width <- max.pos - min.pos
                xlim <- c(min.pos-(pos.width*0.1), max.pos+(pos.width*0.1))
                plot(transcript.pos[chr.transcripts], t.loading[non.zero[chr.transcripts]], 
                type = "h", axes = FALSE, xlab = ch, ylim = ylim, xlim = xlim, cex.lab = 2)
                neg.load <- which(t.loading[non.zero[chr.transcripts]] < 0)
                pos.load <- which(t.loading[non.zero[chr.transcripts]] > 0)
                if(length(neg.load) > 0){
                    text(transcript.pos[chr.transcripts[neg.load]], 
                        t.loading[non.zero[chr.transcripts[neg.load]]],
                        labels = transcript.names[neg.load], srt = 90, adj = 1)
                }
                if(length(pos.load) > 0){
                    text(transcript.pos[chr.transcripts[pos.load]], 
                        t.loading[non.zero[chr.transcripts[pos.load]]],
                        labels = transcript.names[pos.load], srt = 90, adj = 0)
                }
                if(ch == 1){axis(2)}
                #axis(1)
                abline(h = 0)
            }else{
                plot(1:10, rep(0, 10), cex.lab = 2,
                type = "h", axes = FALSE, xlab = ch, ylim = ylim)
                if(ch == 1){axis(2)}
                abline(h = 0)
            }
        }
    mtext(paste(tissue.name, "CT", u), side = 3, outer = TRUE, line = -1.5)
    cat("\n\n")
    }
    cat("\n\n")
}

```

## Checking

```{r check_one, eval = FALSE}
#look at correlation between individual transcripts and 
#composite traits - this is a way to test the correlation
#of measured transcript versions of transcripts identified 
#in the imputed set.

#gene.name <- "Gusb" #adipose
#gene.name <- "Aldh2" #adipose
#gene.name <- "Lep" #adipose
#gene.name <- "Mdfic" #adipose
#gene.name <- "Prrx1"
#gene.name <- "Igfbp2"

#gene.idx <- which(gene.table[,"symbol"] == gene.name)
#gene.id <- gene.table[gene.idx,"gene.id"][1]

#randomly sample a transcript with a loading of 0
#i = 2; gene.id <- colnames(matched.mats[[i]]$X)[sample(which(boot.CCA.results[[i]]$u[,1] == 0), 1)]
#gene.name <- gene.table[which(gene.table[,"gene.id"] == gene.id),"symbol"]
#gene.idx <- which(gene.table[,"symbol"] == gene.name)

plot.results = FALSE
all.trans.stats <- vector(mode = "list", length = length(matched.mats))
names(all.trans.stats) <- tissue.names
for(i in 1:length(matched.mats)){
    tissue.name <- tissue.names[i]
    tissue.expr <- get(paste0("dataset.DO.Cube.", tissue.name))$data$norm

    adj.do.expr <- adjust(tissue.expr, get(paste0("dataset.DO.Cube.", tissue.name))$covar.matrix)
    adj.imp.expr <- matched.mats[[i]]$X

    trait.trans <- get_latent_var(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]])
    non.zero <- which(rowSums(boot.CCA.results[[i]]$u) != 0)

    stat.mat <- matrix(NA, nrow = length(non.zero), ncol = 5)
    colnames(stat.mat) <- c("R2_measured_imputed", "cis_LOD_score", "cis_LOD_drop", "measured_cor", "adjusted_cor")
    rownames(stat.mat)  <- colnames(matched.mats[[i]]$X)[non.zero]

    for(tr in 1:length(non.zero)){
        if(is.interactive){report.progress(tr, ncol(adj.do.expr))}
        gene.id <- rownames(stat.mat)[tr]
        gene.name <- gene.table[which(gene.table[,"gene.id"] == gene.id),"symbol"]
        trans.expr <- adj.do.expr[,gene.id]
        imp.expr <- adj.imp.expr[,gene.id]
        trans.chr <- gene.table[gene.idx,"chr"]
        one.matched.expr <- get.xz(x.mat = as.matrix(trans.expr), z.mat = as.matrix(imp.expr))
        r2 <- plot.with.model(one.matched.expr[[1]], one.matched.expr[[2]], 
            xlab = "Measured Expression", ylab = "Imputed Expression", 
            main = gene.name, plot.results = plot.results)

        gene.idx <- which(gene.table[,1] == gene.id)
        cis.marker <- find_marker(map, trans.chr, as.numeric(gene.table[gene.idx,"start"]))
        #scan measured transcript expression
        measured.qtl <- scan1(genoprobs[,trans.chr], trans.expr, kinship = K[[trans.chr]]) 
        imp.qtl <- scan1(genoprobs[,trans.chr], imp.expr, kinship = K[[trans.chr]])
        med.qtl.expr <- scan1(genoprobs[,trans.chr], trans.expr, addcovar = imp.expr, kinship = K[[trans.chr]])
        med.qtl.marker <- scan1(genoprobs[,trans.chr], trans.expr, addcovar = genoprobs[[trans.chr]][,,cis.marker], kinship = K[[trans.chr]])
        measured.lod <- measured.qtl[cis.marker,]
        med.lod <- med.qtl.marker[cis.marker,]
        lod.drop <- measured.lod - med.lod

        if(plot.results){
            par(mfrow = c(2,1))
            plot(measured.qtl, map = map);abline(v = as.numeric(gene.table[gene.idx,"start"]))
            plot(med.qtl.expr, map = map, col = "red", add = TRUE)
            plot(med.qtl.marker, map = map, col = "gray60", add = TRUE)
            plot(imp.qtl, map = map, col = "red");abline(v = as.numeric(gene.table[gene.idx,"start"]))
            plot(imp.qtl[,1], measured.qtl[,1]);abline(0,1)
            barplot(c(measured.qtl[cis.marker,], med.qtl.expr[cis.marker,], 
                med.qtl.marker[cis.marker,]), names = c("measured", "med expr", 
                "med marker"), ylab = "LOD", main = gene.name)
        }

        matched.var <- get.xz(as.matrix(trans.expr), trait.trans$Composite_Traits)
        trait.trans.cor <- apply(matched.var[[2]], 2, 
            function(x) cor(matched.var[[1]], x))
    
        #correlation after accounting for imputed transcript/genotype
        adj.traits <- adjust(matched.var[[2]], as.matrix(imp.expr))
        post.cor <- apply(adj.traits, 2, function(x) cor(matched.var[[1]], x))
        
        if(plot.results){
            boxplot(list(abs(trait.trans.cor), abs(post.cor)), 
            names = c("Correlation to Latent Traits", 
            "Correlation After Removing Imputed Transcript"), 
            main = gene.name, ylim = c(0,0.75))
        }

        stat.mat[tr,] <- c(r2[1], measured.lod, lod.drop, 
            mean(abs(trait.trans.cor)), mean(abs(post.cor)))
    }

    all.trans.stats[[i]] <- stat.mat
}

boxplot(lapply(all.trait.trans.cor, abs), main = gene.name)

eqtl.pos <- strsplit(tissue.eqtl[[2]], "_")
chr.locale <- which(sapply(eqtl.pos, function(x) x[1]) == Chr)
mb.locale <- intersect(which(as.numeric(sapply(eqtl.pos, function(x) x[2])) >=  40e6),
                which(as.numeric(sapply(eqtl.pos, function(x) x[2])) <=  50e6))
eqtl.locale <- intersect(chr.locale, mb.locale)
pos.eqtl <- tissue.eqtl[eqtl.locale,]
u_trans <- unique(pos.eqtl[[1]])

#there are length(u_trans) genes with eQTLs in the locus
trans.info <- gene.info[[tissue.name]][which(gene.info[[tissue.name]][,1] %in% u_trans),]

#some of these are in the composite transcript
ct.genes <- colnames(matched.mats[[tissue.name]]$X)[which(boot.CCA.results[[tissue.name]]$u[,CT] != 0)]
plotVenn(list("Transcripts_with_eQTL" = u_trans, "CT_genes" = ct.genes))
overlap = intersect(u_trans, ct.genes)
overlap.info <- gene.info[[tissue.name]][which(gene.info[[tissue.name]][,1] %in% overlap),]

#none of the eqtls have large LOD scores.
overlap.eqtl <- as.matrix(pos.eqtl[match(overlap, pos.eqtl[[1]]),])
cat(overlap.eqtl[,1], sep = "\n")
```
look at Sash3 expression correlation with composite transcript
    it is very highly correlated to the composite transcript
    it is significantly but weakly correlated to the composite trait

color trait-transcript cor plot by Sash3 expression and by individual genotype at locus
    the only allele that seems to have an effect is the CAST allele
    it is weak

Yi sees the same chr X QTL - can compare my gene list with hers 

association mapping

look for any eQTL in the region, cis or trans
    do genes in the composite transcript have eQTLs in this region?
    yes, there are length(u_trans) transcript that have eQTL in this locus
    length(overlap) genes of these are in the composite transcript
    none of these have very strong LOD scores the max is 8-something.

