---
title: "SOM DO mice"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

The purpose of this workflow is examine the use of self-organizing maps 
to analyze transcriptome data for DO mice.

```{r get_args}
args <- commandArgs(trailingOnly = T)
tissue.name <- args[1]
delete_previous <- as.logical(args[2])

if(is.na(tissue.name)){
  tissue.name <- "Islet"
  delete_previous <- FALSE
}
  is.interactive <- FALSE
  #is.interactive <- TRUE
```

## SOM Results for `r tissue.name`

```{r source_code}
library("here")
all.fun <- list.files(here("Code"), pattern = ".R", full.names = TRUE)
for(j in 1:length(all.fun)){source(all.fun[j])}
```


```{r load_libraries,  warning = FALSE, message = FALSE, error = FALSE}
needed.packages <- c("oposSOM", "gProfileR", "pheatmap", "qtl2", "grid", "stringr", 
  "VennDiagram")
load_libraries(needed.packages, personal.library = TRUE)
```


Get the expression for the specified tissue.

```{r read_data}
vars <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
expr.name <- paste0("dataset.DO.Cube.", tissue.name)
expr.data <- get(expr.name)

#filter expression to transcripts that have at least a mean
#transcription level of 10
mean.lim <- 10
expr.count <- expr.data$data$raw
mean.expr <- colMeans(expr.count)
#hist(log10(mean.expr), breaks = 100)
high.trans <- which(mean.expr > 10)

expr <- expr.data$data$rz[,high.trans]
covar <- expr.data$covar.matrix

pheno <- as.matrix(read.csv(here("Data", "DO_clinical_phenotypes.csv"),
  stringsAsFactors = FALSE))
num.pheno <- apply(pheno[,11:(ncol(pheno)-1)], 2, as.numeric)
rownames(num.pheno) <- pheno[,1]
```

Adjust phenotypes and expression for covariates.

```{r adjust}
adj.pheno <- adjust(num.pheno, covar)
adj.expr <- adjust(expr, covar)
```

I'd like to try using the SOM to classify the expression differences
between animals separated by QTLs. I will start with the Ins_tAUC.
There is a large QTL on chromosome 11, and a 4-4 split in the haplotype
effects. We will try to split the animals along those effects, and 
classify the differences.

```{r map_traits}
#data(CCcolors)
#barplot(rep(1, length(CCcolors)), col = CCcolors, names = names(CCcolors))

trait.name <- "Ins_tAUC"; chr = 11
trait_map <- scan1(genoprobs, adj.pheno[,trait.name])
plot(trait_map, map = map, main = trait.name)
chr_map <- scan1coef(genoprobs[,chr], adj.pheno[,trait.name])
#quartz()
plot_coefCC(chr_map, map = map)
```

NOD (D), 129 (C), B6 (B), A/J (A) are all up.
PWK (G), CAST (F), WSB (H), NZO (E) are all down.
I want to divide the DO individuals into two groups, those with the down alleles,
and those with the up alleles. I'm not sure how possible this is, so we need to 
do some exploring.

Find the peak marker for the QTL.

```{r peak_qtl}
peak.table <- find_peaks(trait_map, map = map, threshold = 10, prob = 0.95)
qtl.markers <- intersect(which(map[[chr]] >= peak.table[,"ci_lo"]), which(map[[chr]] <= peak.table[,"ci_hi"]))
ind.locale <- match(rownames(adj.pheno), rownames(genoprobs[[1]]))
qtl.geno <- genoprobs[[chr]][ind.locale,,qtl.markers]
allele.effects <- chr_map[qtl.markers,]
```

For each marker in the QTL, check to see how well the up and down
alleles separate animals. We will weight the alleles at each marker
based on their allele effects.

1. We weight the alleles in each marker based on its effect on the trait
2. We sum across rows to give each individual a total genotype 
  score for the allele effects.
3. We bin each individual into one of two groups based on whether 
  is has predominantly negative effect alleles or positive effect alleles
4. We collect the bin assignment for each animal across all markers in the qtl
  and use the votes across all markers to determine the bin for the animal.

The following heatmap shows the bin assigned to each animal across all markers.
The binning clusters the animals into two clear groups with some less clear
assignments. Should we force these into one of the two groups, or put them
in a third group? For now let's use two groups.

```{r sep_geno}

#for each marker find the groups of animals that best split the
#up alleles from the down alleles. Minimize the number of animals
#in the middle group.

all.grouped.markers <- vector(mode = "list", length = length(qtl.markers))
for(i in 1:length(qtl.markers)){
  geno.groups <- vector(mode = "list", length = 2)
  names(geno.groups) <- c("up", "down")
  #weight the genotypes based on allele effects
  weighted.alleles <- sapply(1:ncol(qtl.geno), function(x) qtl.geno[,x,i]*allele.effects[i,x])
  weighted.effect <- rowSums(weighted.alleles)
  #barplot(sort(weighted.effect))  
  geno.groups[[1]] <- which(weighted.effect > 0)
  geno.groups[[2]] <- which(weighted.effect < 0)
  all.grouped.markers[[i]] <- geno.groups
}

#track the position of each animal over all markers
#use the rownames from the expression matrix now, 
#since we want to index the expression for the SOM
ind.groups <- lapply(rownames(adj.expr), 
  function(y) sapply(all.grouped.markers, function(x) grep(y, x)))
group.ind <- sapply(1:length(geno.groups), 
  function(y) sapply(ind.groups, function(x) length(which(x == y))))
colnames(group.ind) <- names(geno.groups)
#barplot(t(group.ind), col = c("red", "blue"))
pheatmap(group.ind)
```

We then use voting to assign each animal to a bin based on
its genotypes across all markers. 

This results in three distinct bins for the animals with no overlaps,
as shown below.

```{r bin_vote}
#put animals in groups by voting
assigned.groups <- apply(group.ind, 2, function(x) which(x >= length(qtl.markers)/2))
plotVenn(assigned.groups)

#index groups based on expression matrix
group.labels <- rep(NA, nrow(adj.expr))
for(i in 1:length(assigned.groups)){
  group.labels[assigned.groups[[i]]] <- names(geno.groups)[i]
}
#make sure everyone is assigned to a group
#which(is.na(group.labels))
```


```{r quick_test, eval = FALSE}

test <- apply(adj.expr, 2, function(x) t.test(x~as.factor(group.labels)))
all.p <- sapply(test, function(x) x$p.value)
qqunif.plot(all.p)

fdr <- p.adjust(all.p, "fdr")
sig.idx <- which(fdr <= 0.1)
#sig.idx <- which(all.p <= 0.005)
sig.genes <- names(fdr)[sig.idx]
length(sig.genes)

pheatmap(adj.expr[,sig.idx], show_rownames = FALSE, show_colnames = FALSE)
#plot.decomp(adj.expr[,sig.idx], main = "individuals by PC")
#plot.decomp(t(adj.expr[,sig.idx]), main = "genes by PC")

library(biomaRt)
mus <- useEnsembl(biomart = "ensembl", dataset = "mmusculus_gene_ensembl") 

test.info <- getBM(filters = "ensembl_gene_id", attributes = c("external_gene_name",
  "chromosome_name", "start_position", "end_position"), 
  values = sig.genes, mart = mus)
test.info

enrichment <- gost(sig.genes, organism = "mmusculus")
plot.enrichment(enrichment, num.terms = 30)
```

We will use these groups as classes in the SOM.

Run the SOM.

```{r som}
som.result.file <- here("Documents", "1.Setup_Data", paste0("DO_", tissue.name, ".RData"))

if(delete_previous){
  unlink(som.result.file)
}

if(!file.exists(som.result.file)){
  exp.name <- gsub(".RData", "", basename(som.result.file))
  env <- opossom.new(list(dataset.name = exp.name))
  env$indata <- t(adj.expr)
  env$group.labels <- group.labels
  opossom.run(env)
}

load(som.result.file)
```


## Look for phenotype variation among clusters of individuals

Look for trait differences based on grouping. This will be more 
interesting if unsupervised clustering is used. It will show 
more dramatic differences if supervised clustering is used.


```{r pheno_clusters}
groups <- env$group.labels
group.colors <- env$group.colors
u_groups <- unique(groups)
u_colors <- unique(group.colors)
ind.groups <- lapply(u_groups, function(x) names(groups)[which(groups == x)])
names(ind.groups) <- u_groups
```

The plots below show the distribution of phenotypes over each
group identified by the SOM based on transcriptional clustering.

```{r pheno_by_group, width = 12, height = 8}
pheno.ind <- lapply(ind.groups, function(x) which(rownames(adj.pheno) %in% x))
mean.pheno <- matrix(NA, nrow = length(pheno.ind), ncol = ncol(adj.pheno))
rownames(mean.pheno) <- names(pheno.ind)
colnames(mean.pheno) <- colnames(adj.pheno)

if(is.interactive){quartz(width = 8, height = 8)}
layout.mat <- get.layout.mat(9)
layout(layout.mat)
par(mar = c(4,2,2,2))
for(i in 1:ncol(adj.pheno)){  
  group.pheno <- lapply(pheno.ind, function(x) adj.pheno[x,i])
  med.order <- order(sapply(group.pheno, function(x) median(x, na.rm = TRUE)), 
  decreasing = FALSE)
  boxplot(group.pheno[med.order], main = colnames(adj.pheno)[i],
  col = u_colors[med.order], las = 2)
  mean.pheno[,i] <- sapply(group.pheno, function(x) mean(x, na.rm = TRUE))
}
```

The following heatmap shows the mean phenotype across groups and phenotypes.

```{r mean_pheno}
if(is.interactive){quartz()}
pheatmap(t(mean.pheno), scale = "row")
```

## Metagenes

The transcriptome is also clustered. The genes are clustered into a 
grid of metagenes. The distribution of genes per metagene is shown 
below. 

```{r genes_per_metagene}
metagene.assig <- env$som.result$feature.BMU
n.meta <- max(metagene.assig)
meta.genes <- lapply(1:n.meta, function(x) names(metagene.assig)[which(metagene.assig == x)])
n.genes <- sapply(meta.genes, length)

if(is.interactive){quartz()}
hist(n.genes, breaks = 100, main = "Number of Genes per Metagene",
xlab = "Number of Genes")
```

The following boxplot show the absolute value of the correlations
between phenotypes and metagenes.

```{r spot_cor}
kmeta <- env$spot.list.kmeans$spots
metagenes <- env$metadata
map.dim <- sqrt(nrow(metagenes))

pheno.metagene.cor <- vector(mode = "list", length = ncol(adj.pheno))
names(pheno.metagene.cor) <- colnames(adj.pheno)

common.ind <- intersect(colnames(metagenes), rownames(adj.pheno))
metagene.locale <- match(common.ind, colnames(metagenes))
pheno.locale <- match(common.ind, rownames(adj.pheno))
expr.locale <- match(common.ind, rownames(adj.expr))
#head(cbind(colnames(metagenes)[metagene.locale], rownames(adj.pheno)[pheno.locale]))

for(m in 1:ncol(adj.pheno)){
  metagene.cor <- apply(metagenes[,metagene.locale], 1, 
    function(x) cor(adj.pheno[pheno.locale,m], x, use = "pairwise.complete.obs"))
  pheno.metagene.cor[[m]] <- matrix(metagene.cor, nrow = map.dim, ncol = map.dim, byrow = FALSE)
  #pheatmap(pheno.metagene.cor[[m]], cluster_rows = FALSE, cluster_cols = FALSE,main = colnames(adj.pheno)[m])
}

if(is.interactive){quartz()}
boxplot(lapply(pheno.metagene.cor, abs), las = 2)
```

## Correlation Maps  {.tabset .tabset-fade .tabset-pills}

The following plots show maps of the correlations between traits and metagenes.
Each trait has roughly the same correlation pattern with the metagenes. 

In one tab we show the correlations all on the same scale to show that 
correlations with diet days, for example, are weaker than those for the
HOMAs.

The second tab shows each correlation plot on its own scale to better highligh
the overall patterns in the correlations. These plots show that the islet traits,
WPIC, Ins_per_islet, and num_islets, tend to have one correlation pattern with
the transcriptome, while the rest of the traits have a different pattern. 

Overall the patterns are strikingly similar. The correlations are on par with
those seen in WGCNA modules. However in this case, the number of genes in each 
metagene tends to be smaller than the number of genes in WGCNA modules. This is
neither good nor bad.

The correlations are much lower than I had thought they would be, and are
also much lower than what we saw with CCA. With CCA we maximize the correlation
between transcripts and traits. We were able to achive correlations from -0.6 
to 0.6 across all tissues. Here, when we cluster the transcripts without taking
the traits into account, we get much lower correlations. 

The following histogram shows the distribution of correlations between
all metagenes and all traits for `r tissue.name`.

```{r cor_dist}
if(is.interactive){quartz()}
hist(unlist(pheno.metagene.cor), main = "Trait-Metagene Correlations",
xlab = "Pearson Correlation", breaks = 100)
```

### Global Color Scale
```{r metagene_cor_maps, fig.width = 10, fig.height = 9}
min.cor <- min(unlist(pheno.metagene.cor))
max.cor <- max(unlist(pheno.metagene.cor))

layout.mat <- get.layout.mat((length(pheno.metagene.cor)+1))

layout(layout.mat)
par(mar = c(0,0,4,0))
for(m in 1:length(pheno.metagene.cor)){
  imageWithText(pheno.metagene.cor[[m]], use.pheatmap.colors = TRUE, 
  show.text = FALSE, global.color.scale = TRUE, global.min = min.cor, 
  global.max = max.cor, main = colnames(adj.pheno)[m])
}
par(mar = c(0,4,4,4))
imageWithTextColorbar(matrix(segment_region(min.cor, max.cor, 10), ncol = 1), 
  use.pheatmap.colors = TRUE, cex = 1)
```

### Individual Color Scale

```{r, ind_color_scale, fig.width = 10, fig.height = 9}
layout(layout.mat)
par(mar = c(0,0,4,0))
for(m in 1:length(pheno.metagene.cor)){
  imageWithText(pheno.metagene.cor[[m]], use.pheatmap.colors = TRUE, 
  show.text = FALSE, main = colnames(adj.pheno)[m])
}
```


## Gene Set Correlations {.tabset .tabset-fade .tabset-pills}

The following code looks for gene sets with maximal correlations with clinical
phenotypes. Here we plot the top and bottom 10 processes associated with each
trait.

```{r gsz_cor}
gsz <- env$samples.GSZ.scores

common.ind <- intersect(colnames(gsz), rownames(adj.pheno))
gsz.locale <- match(common.ind, colnames(gsz))
pheno.locale <- match(common.ind, rownames(adj.pheno))

gsz.cor.mat <- matrix(NA, nrow = nrow(gsz), ncol = ncol(adj.pheno))
rownames(gsz.cor.mat) <- rownames(gsz)
colnames(gsz.cor.mat) <- colnames(adj.pheno)

for(m in 1:ncol(adj.pheno)){
  gsz.cor.mat[,m] <- apply(gsz[,gsz.locale], 1, 
    function(x) cor(adj.pheno[pheno.locale,m], x, use = "pairwise.complete.obs"))
}
```

```{r top_assoc, results = "asis"}
all.top.cor <- vector(mode = "list", length = ncol(adj.pheno))
names(all.top.cor) <- colnames(adj.pheno)
for(ph in 1:ncol(gsz.cor.mat)){
  if(is.interactive){quartz()}
  cat("###", colnames(adj.pheno)[ph], "\n")
  sorted.cor <- sort(gsz.cor.mat[,ph])
  top.cor <- c(head(sorted.cor, 10), tail(sorted.cor, 10))
  all.top.cor[[ph]] <- top.cor
  par(mar = c(3, 18, 4, 2))
  barplot(top.cor, las = 2, horiz = TRUE, cex.names = 0.7, main = colnames(adj.pheno)[ph])
  cat("\n\n")
}
```

## Trait-Process Correlation Heatmap

The following heatmap shows the top processes associated with all traits.
A box plot of this matrix can be found in the SOM results folder. 

```{r process_cor, fig.height = 20, fig.width = 9}
u_processes <- unique(unlist(lapply(all.top.cor, function(x) names(x))))
process.locale <- match(u_processes, rownames(gsz.cor.mat))
pheatmap(gsz.cor.mat[process.locale,])

process.order <- order(rowMeans(gsz.cor.mat[process.locale,]))

pdf(here("Results", "SOM", paste0("Top_Processes_", tissue.name, ".pdf")), 
  width = 7, height = 20)
par(mar = c(4, 15, 2, 2))
boxplot(t(gsz.cor.mat[process.locale[process.order],]), horizontal = TRUE, las = 2,
cex.axis = 0.5, main = "Top Correlated Processes")
abline(v = 0)
dev.off()
```

From these groups, we can look at differential expression of individual
groups that have extreme phenotypes of interest. For example, Group D 
above has very low HOMA values and differentially expresses genes related 
to insulin response and chromatin remodeling. The top overexpressed genes
are Calm1 and insulin receptor. Group NQRS has very high HOMA values and 
is differentially expresses genes related to immune function and endocytosis.

## Clustered Metagenes

The SOM clusters metagenes into clusters using k-means clustering. 
Neighboring metagenes are very highly correlated with each other. 
The clustering of metagenes allows us to reduce the dimentionality 
even more. 

The barplot below shows the number of genes in each of the K-means 
clusters. They are remarkably even in size.

```{r metagenes, fig.width = 9, fig.height = 5}
kmeta <- env$spot.list.kmeans$spots
cluster.sizes <- sapply(kmeta, function(x) length(x$genes))
barplot(cluster.sizes)
```



## Metagene Cluster Trends

look at correlation matrices for clustered metagenes. Here we find all the 
metagenes in a single cluster and decompose the cluster using SVD. We then
use the first principle component of the metagene matrix as the clustered
metagene. We calculated the correlation of each of these clustered metagenes
to the clinical traits, and scanned each. 

The correlations with the traits are very comparable to WGCNA eigengene
correlations with traits. The mapping is also par with mapping of other 
gene modules. Maybe a little better.

```{r metagene_clusters}
kmeans <- env$spot.list.kmeans
kmap <- kmeans$overview.map
u_k <- sort(unique(as.vector(kmap)))

k.gene.cor <- matrix(NA, nrow = length(u_k), ncol = ncol(adj.pheno))
rownames(k.gene.cor) <- names(kmeans$spots)
colnames(k.gene.cor) <- colnames(adj.pheno)

k.gene.mat <- matrix(NA, nrow = nrow(adj.pheno), ncol = length(u_k))
colnames(k.gene.mat) <- names(kmeans$spots)
rownames(k.gene.mat) <- rownames(adj.pheno)

common.ind <- intersect(rownames(adj.pheno), colnames(metagenes))
pheno.locale <- match(common.ind, rownames(adj.pheno))
metagene.locale <- match(common.ind, colnames(metagenes))
expr.locale <- match(common.ind, rownames(adj.expr))

for(k in 1:length(u_k)){
  #k.locale <- which(kmap == u_k[k])
  #k.genes <- metagenes[k.locale,]
  #k.gene <- plot.decomp(t(k.genes), plot.results = FALSE)$u[,1]

  k.genes <- kmeta[[k]]$genes
  k.gene <- plot.decomp(adj.expr[,k.genes], plot.results = FALSE)$u[,1]

  k.gene.mat[,k] <- k.gene
  #k.cor <- apply(adj.pheno[pheno.locale,], 2, function(x) cor(x, k.gene[metagene.locale], use = "pairwise.complete.obs"))
  k.cor <- apply(adj.pheno[pheno.locale,], 2, function(x) cor(x, k.gene[expr.locale], use = "pairwise.complete.obs"))
  k.gene.cor[k,] <- k.cor
}

pheatmap(k.gene.cor, display_numbers = TRUE)
```

The following code runs genetic mapping on metagenes. I tried 
mapping the metagenes directly and got very strange mapping.
So instead I am mapping the first principle compoenent of the 
expression matrix defined by the metagene clusters.

```{r kgene_scan, fig.width = 12, fig.height = 6}
metagene.scan.file <- here("Results", "SOM", paste0("Metagene.Scan.", tissue.name, ".RDS"))

if(!file.exists(metagene.scan.file)){
  k.gene.scan <- scan1(genoprobs, k.gene.mat)
  saveRDS(k.gene.scan, metagene.scan.file)
}else{
  k.gene.scan <- readRDS(metagene.scan.file)
}

par(xpd = NA)
multilod.plot(k.gene.scan, map = map, lod.thresh = 4, row.names = colnames(k.gene.scan),
row.name.shift = -1000)
par(xpd = TRUE)
```

## LOD traces for clustered metagenes {.tabset .tabset-fade .tabset-pills}

The following plots show the LOD trace for each metagene along with its
cis-trans eQTL plot to help show where the metagene QTLs might be coming
from.

```{r eqtl_fun}
#get a table with eQTL chromosome, position,
#and lod score.
get_eqtl_table <- function(gene.ids){
    gene.locale <- match(gene.ids, lod.table[[1]])
    gene.locale <- gene.locale[which(!is.na(gene.locale))]
    sub.table <- as.matrix(lod.table[gene.locale,])
    split.qtl.pos <- strsplit(sub.table[,2], "_")
    qtl.chr <- sapply(split.qtl.pos, function(x) x[1])
    qtl.pos <- as.numeric(sapply(split.qtl.pos, function(x) x[2]))/1e6
    final.table <- cbind(sub.table[,1], qtl.chr, qtl.pos)
    return(final.table)
}

#get a table with transcript chromosome and
#position
get_transcript_table <- function(gene.ids){
    trans.locale <- match(gene.ids, gene.info[[1]])
    sub.table <- as.matrix(gene.info[trans.locale,])
    final.table <- sub.table[,c(1,4,5)]
    return(final.table)
}
```

```{r plot_ind, fig.width = 12, fig.height = 8, results = "asis"}
lod.table <- expr.data$lod$additive
gene.info <- expr.data$annot.mrna

all.marker.chr <- unlist(sapply(1:length(map), function(x) rep(names(map)[x], length(map[[x]]))))
all.marker.pos <- as.numeric(unlist(map))
rel.marker.pos <- get_relative_genomic_position(all.marker.chr, all.marker.pos, map)
chr.col <- rep("darkgray", length(all.marker.chr))
chr.col[which(as.numeric(all.marker.chr) %% 2 == 1)] <- "#1f78b4"

layout.mat <- matrix(c(1,2), ncol = 1)

for(i in 1:ncol(k.gene.scan)){
  if(is.interactive){quartz(width = 10, height = 6)}
  cat("###", colnames(k.gene.scan)[i], "\n")
  layout(layout.mat, heights = c(0.5, 1))

  par(mar = c(0,2,2,2))
  #plot(k.gene.scan, map = map, lodcol = i)
  #quartz()
  plot(rel.marker.pos, k.gene.scan[,i], col = chr.col, type = "h", 
    axes = FALSE, ylab = "LOD Score")
  axis(2);abline(h = 6)

  cluster.genes <- kmeta[[i]]$genes
  #mod.eig <- plot.decomp(adj.expr[,cluster.genes], plot.results = FALSE)$u[,1,drop=FALSE]
  #rownames(mod.eig) <- rownames(adj.pheno)
  #eig.scan <- scan1(genoprobs, mod.eig)
  #plot(rel.marker.pos, eig.scan[,1], col = chr.col, type = "h", 
  #  axes = FALSE, ylab = "LOD Score")
  #axis(2);abline(h = 6)
 
  eqtl.table <- get_eqtl_table(cluster.genes)
  transcript.pos.table <- get_transcript_table(cluster.genes)
  lod.col <- colors.from.values(sqrt(as.numeric(eqtl.table[,3])), 
  col.scale = "blue", light.dark = "d")
  par(mar = c(2,2,0,2))
  plot.cistrans.table(eqtl.table, transcript.pos.table, map = map,
    add = FALSE, cex = 0.5, col = lod.col, label.cex = 0.7)  
  
  mtext(side = 3, outer = TRUE, text = paste("Metagene", colnames(k.gene.scan)[i]),
  line = -2.5)
  cat("\n\n")
}
```

## Peak Allele Effects {.tabset .tabset-fade .tabset-pills}

```{r scan_allele_effects}
metagene.peak.scan.file <- here("Results", "SOM", 
  paste0("Metagene.LOD.Scores.", tissue.name, ".RDS"))
metagene.peak.allele.file <- here("Results", "SOM", 
  paste0("Metagene.Allele.Effects.", tissue.name, ".RDS"))

peak.table <- find_peaks(k.gene.scan, map = map, threshold = 6)

if(!file.exists(metagene.peak.scan.file)){
  metagene.peak.lod.scans <- metagene.peak.allele.scans <- vector(mode = "list", length = nrow(peak.table))
  scan.names <- apply(peak.table, 1, function(x) paste0(x[2], "_Chr", str_trim(x[3])))
  for(i in 1:nrow(peak.table)){
    peak.chr <- as.vector(peak.table[i,"chr"])
    if(peak.chr != "X"){
      peak.pos <- as.numeric(peak.table[i,"pos"])
      peak.trait <- peak.table[i,"lodcolumn"]
      chr.locale <- which(names(map) == peak.chr)
      lod.scan <- scan1(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      metagene.peak.lod.scans[[i]] <- lod.scan
      coef.scan <- scan1coef(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      #coef.scan <- scan1blup(genoprobs[,chr.locale], k.gene.mat[,peak.trait])
      metagene.peak.allele.scans[[i]] <- coef.scan
    }
  }
  saveRDS(metagene.peak.allele.scans, metagene.peak.allele.file)
  saveRDS(metagene.peak.lod.scans, metagene.peak.scan.file)
}else{
  metagene.peak.allele.scans <- readRDS(metagene.peak.allele.file)
  metagene.peak.lod.scans <- readRDS(metagene.peak.scan.file)
}
```

```{r plot_scans, results = "asis", fig.height = 8, fig.widdth = 12}
for(i in 1:length(metagene.peak.lod.scans)){
  peak.chr <- peak.table[i,"chr"]
  peak.pos <- as.numeric(peak.table[i,"pos"])
  if(peak.chr != "X"){
    cat("###", peak.table[i,"lodcolumn"], "Chr", peak.chr, "\n")
    par(mfrow = c(2,1), mar = c(2,2,2,2))
    plot(metagene.peak.lod.scans[[i]], map = map);abline(v = peak.pos)
    plot_coefCC(metagene.peak.allele.scans[[i]], map = map)
    abline(v = peak.pos)
    cat("\n\n")
  }
}
```


```{r cluster_analysis, eval = FALSE}
cluster.name = "L"
p.thresh <- 20
cluster.locale <- which(names(kmeta) == cluster.name)
cluster.enrich <- kmeta[[cluster.locale]]$Fisher.p
log.p <- -log10(cluster.enrich)
par(mar = c(4, 18, 2, 2))
barplot(sort(log.p[which(log.p > p.thresh)]), horiz = TRUE, las = 2, xlab = "-log10(p)",
main = paste("Metagene", cluster.name))

cl.names <- lapply(kmeta, function(x) tail(sort(-log10(x$Fisher.p)), 1))

barplot(unlist(cl.names), las = 2, horiz = TRUE)
```

## Cluster Enrichments {.tabset .tabset-fade .tabset-pills}

The following plots show the locations and top associated biological
processes of each metagene.

```{r cluster_enrichments, results = "asis", fig.width = 10, fig.height = 6}
layout.matrix <- matrix(c(1,2,0,2), byrow = TRUE, ncol = 2)
for(k in 1:length(kmeta)){
  cat("### Cluster", names(kmeta)[k], "\n")
  if(is.interactive){quartz(width = 10, height = 6)}
  layout(layout.matrix, widths = c(0.7, 1), heights = c(1,0.5))
  par(mar = c(0,2,2,0))
  plot_portrait(kmeta[[k]]$mask)
  enrich <- sort(-log10(kmeta[[k]]$Fisher.p))
  top.enrich <- tail(enrich, 20)
  par(mar = c(4, 18, 4, 4))
  barplot(top.enrich, horiz = TRUE, las = 2, main = paste("Metagene", names(kmeta)[k]))
  cat("\n\n")
}
```