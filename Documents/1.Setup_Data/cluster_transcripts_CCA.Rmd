---
title: "Clustering transcripts with CCA"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow explores the possibility of using CCA to transcript clusters
that correlate with specific traits. We will be playing around a lot with 
different trait inputs. In the first code chunk, set the traits analyzed
along with an experiment name for keeping results from different runs 
separate.


```{r get_args}
args <- commandArgs(trailingOnly=T)
pheno_type <- args[1]
delete_previous <- as.logical(args[2])

if(is.na(pheno_type)){
    #pheno_type <- "eigentraits"
    pheno_type <- "traits"
    #delete_previous <- TRUE
    delete_previous <- FALSE
}

#traits to analyze can either be full names, a pattern to search for, like "TG",
#or numeric values indicating the column numbers of the traits.
#the analysis results will be put in a folder named for exp.name
#adj.traits are full names, partial names, or column numbers of 
#traits to adjust out of the phenotype matrix. This could be weight,
#for example, or NULL to not adjust for anything

#exp.name = "TG"
#   keep.traits <- "TG" #Triglycerides only
#   adj.traits <- NULL

exp.name = "ex_vivo"
   keep.traits <- c("WPIC", "Ins_per_islet", "num_islets")
   adj.traits = NULL

#exp.name = "Homeostasis"    
#    keep.traits <- c("HOMA_IR_0min", "HOMA_B_0min", "Glu_tAUC", "Ins_tAUC")
#    adj.traits <- NULL

#exp.name = "all_traits"
#    keep.traits <- 1:20 #all traits;
#    adj.traits <- NULL #traits to adjust for, set to NULL to not adjust

#exp.name = "weight_adjusted"
#    keep.traits <- 1:20 #all traits;
#    adj.traits <- "weight" #traits to adjust for, set to NULL to not adjust

```

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "CCA_Clusters", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r delete_previous}
if(delete_previous){
    results.files <- list.files(results.dir, full.names = TRUE)
    unlink(results.files)
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "cape", "PMA", "abind", "cluster",
"RColorBrewer", "igraph", "biomaRt", "corpcor", "easyPubMed")
load_libraries(all.packages)

all.var <- ls()
if(length(which(all.var == "mus")) == 0){
    mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl")
}
```


```{r read_data}
all.var <- ls()
data.loaded <- as.logical(length(which(all.var == "dataset.clinical.phenotypes")))
if(!data.loaded){
  gen.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
  tissue.files <- list.files(here("Data", "RDS_datasets_tissues"), full.names = TRUE)
  tissue.names <- gsub(".RDS", "", basename(tissue.files))
  tissue.data <- lapply(tissue.files, readRDS)
  names(tissue.data) <- tissue.names
  tissue.counts <- lapply(tissue.data, function(x) x$data$raw)
  tissue.rz <- lapply(tissue.data, function(x) x$data$rz)
  tissue.covar <- lapply(tissue.data, function(x) x$covar.matrix)
  }
```

## Filter Expression
Filter the expression matrices to include only genes that have at least
a minimum amount of expression. 

Here we use the raw expression matrix to select transcripts from the rank Z
normalized expression matrix. 

```{r adjust_covar}
min.mean = 10

filter.expr <- function(count.mat, rz.mat, covar.mat, min.mean){
    trans <- which(colMeans(count.mat) > min.mean)
    expr <- rz.mat[,trans]
    adj.expr <- adjust(expr, covar.mat)
    return(adj.expr)
}

tissue.adj.expr <- lapply(1:length(tissue.rz), 
    function(x) filter.expr(tissue.counts[[x]], tissue.rz[[x]], 
    tissue.covar[[x]], min.mean))
names(tissue.adj.expr) <- tissue.names
```

Extract clinical traits, expression traits, and covariates from the 
islet data set. Adjust for covariates.

```{r pheno}
pheno <- as.matrix(read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE))
num.pheno <- apply(pheno[,11:(ncol(pheno)-1)], 2, as.numeric)
rownames(num.pheno) <- pheno[,1]

max.n <- which.max(sapply(tissue.adj.expr, nrow)) #adjust with the largest covariate matrix
covar <- tissue.covar[[max.n]]

adj.pheno <- adjust(num.pheno, covar)
scaled.pheno <- apply(adj.pheno, 2, scale)
rownames(scaled.pheno) <- rownames(adj.pheno)
gene.tables <- lapply(tissue.data, function(x) x$annot.mrna)
```

## Transcript PCA

The following plot shows the first two principal components of the 
full transcript matrix. 

I was expecting separation by tissue, but they all overlap each other. 

```{r transcript_overlap}
transcript.list <- lapply(tissue.adj.expr, colnames)
plotVenn(transcript.list)

common.transcripts <- Reduce("intersect", transcript.list)
common.transcript.idx <- lapply(tissue.adj.expr, function(x) match(common.transcripts, colnames(x)))
common.ind <- Reduce("intersect", lapply(tissue.adj.expr, rownames))
common.ind.idx <- lapply(tissue.adj.expr, function(x) match(common.ind, rownames(x)))

tissue.label <- unlist(lapply(1:length(tissue.adj.expr), 
function(x) rep(names(tissue.adj.expr)[x], ncol(tissue.adj.expr[[x]]))))

matched.expr <- lapply(1:length(tissue.adj.expr), 
function(x) tissue.adj.expr[[x]][common.ind.idx[[x]], common.transcript.idx[[x]]])

all.expr <- Reduce("cbind", matched.expr)

expr.decomp.file <- file.path(results.dir, "all.expr.decomp.RDS")
if(!file.exists(expr.decomp.file)){
    expr.decomp <- plot.decomp(all.expr, plot.results = FALSE)
    saveRDS(expr.decomp, expr.decomp.file)
}else{
    expr.decomp <- readRDS(expr.decomp.file)
}


plot(expr.decomp$v, col = as.numeric(as.factor(tissue.label)), pch = 16,
xlab = "PC1", ylab = "PC2")
legend("topleft", legend = levels(as.factor(tissue.label)), 
col = 1:length(unique(tissue.label)), pch = 16)
```

## Transcript Correlation

The following plot shows the distribution of transcript i in one tissue 
with transcript i in another tissue.

```{r plot_transcript_cor, fig.height = 10, fig.width = 3.5}
tissue.pairs <- pair.matrix(1:length(tissue.names))
tissue.expr.comp <- vector(mode = "list", length = nrow(tissue.pairs))
for(i in 1:nrow(tissue.pairs)){
    tissue.expr.comp[[i]] <- sapply(1:ncol(matched.expr[[1]]),
    function(x) cor(matched.expr[[tissue.pairs[i,1]]][,x], matched.expr[[tissue.pairs[i,2]]][,x]))
}

#quartz(height = 9, width = 3.5)
par(mfrow = c(length(matched.expr),1), mar = c(0, 2, 0, 2))
for(i in 1:length(matched.expr)){
    tissue1 <- tissue.names[tissue.pairs[i,1]]
    tissue2 <- tissue.names[tissue.pairs[i,2]]
    a <- hist(tissue.expr.comp[[i]], xlim = c(-1, 1), axes = FALSE, xlab = "", 
    ylab = "", main = "", breaks = 100, border = NA)
    points(x = median(tissue.expr.comp[[i]]), y = 0, pch = "*", 
    col = "#2b8cbe", cex = 3)
    text(x = -0.1, y = max(a$counts)*0.75, paste(tissue1, tissue2, sep = "-"), 
    adj = 1, cex = 2)
}
axis(1, cex.axis = 2)
par(xpd = NA)
abline(v = 0, col = "darkgray", lty = 2)
par(xpd = FALSE)

```

## Trait Correlation

The following heatmap shows the correlations between trait pairs

```{r pheno_cor, fig.height = 7, fig.width = 6}
trait.order <- hclust(dist(t(scaled.pheno)))$order
layout(matrix(c(1,2), ncol = 2), widths = c(0.8, 0.2))
par(mar = c(8, 8, 2, 2))

pheatmap(cor(scaled.pheno, use = "pairwise.complete.obs")[trait.order, trait.order],
cluster_rows = FALSE, cluster_cols = FALSE)
```

## Trait Partial Correlation

We also looked at the partial correlation of all pairs of variables.
To do this, we used pcor.shrink from corpcor.

The heat map below shows the full partial correlation matrix. It is
dominated by the ex vivo insulin traits. WPIC is basically perfectly
correlated with both insulin per islet and the number, as you might
imagine. Insulin per islet is perfectly negatively correlated with 
number of islets. So as there are fewer islets, each one secretes 
more insulin.

```{r par_cor, fig.height = 7, fig.width = 6}
test.decomp <- plot.decomp(scaled.pheno, plot.results = FALSE)
par.cor <- pcor.shrink(scaled.pheno[test.decomp$rows.used,c(1,3:20)]) #take out num_islets, which is derived from WPIC and Ins_per_islet
pheatmap(par.cor)
```

The heat map below shows the partial correlation traits with the
ex vivo traits removed so we can better see the other correlations.

This shows some potentially interesting patterns. 
Glu_tAUC and Ins_tAUC are negatively correlated. That is, the larger
your insulin response, the faster your glucose goes down. And the smaller 
your insulin response, the more slowly your glucose goes down. This is how 
it should be, I think. 

HOMA_IR, insulin resistance, is positively correlated with Glu_tAUC,
which makes sense. The more resistant you are, the slower your glucose
will go down. 

HOMA_B, beta cell function, is negatively correlated with Glu_tAUC.
The worse your beta cell function, the less insulin you produce, and
the more slowly your glucose goes down.

However, HOMA_IR and HOMA_B are still positively correlated. So beta 
cell function is still compensating for insulin resistance in this 
population.

Weight at different times has different correlations with insulin.
There could be interesting causal relationships here in both directions.
But it's complicated.

Food intake is negatively correlated with insulin at 10 weeks, and
positively correlated with weight at 10 weeks. So more food is 
increasing weight, but potentially reducing islet function, and
reducing insulin production.

```{r par_cor_trimmed, fig.height = 7, fig.width = 7}
col.order <- hclust(dist(par.cor))$order
trimmed.par.cor <- par.cor
diag(trimmed.par.cor) <- NA
imageWithText(trimmed.par.cor[col.order, col.order], split.at.vals = TRUE,
col.scale = c("blue", "brown"), grad.dir = "ends", sig.digs = 2, col.text.shift = -1,
row.text.shift = -1)
```

## Identify covariation in transcripts and traits using CCA

This is an experimental process. I want to see if we can use CCA 
to identify composite transcripts that are correlated with composite 
traits.

Get the X and Z matrices for putting into PMCA.
X is the transcript matrix for the appropriate tissue, 
and Z is the trait matrix (traits, or ETs).

The function get.xz aligns the two matrices by individual.
If pheno_type is set to traits, use the trait matrix, if it is
set to eigentraits, use the eigentrait matrix.

We will be playing around a lot with different trait inputs.
The following code sets up which traits go into the CCA.

```{r set_traits}
if(is.numeric(keep.traits[1])){
    keep.trait.locale <- keep.traits
}else{
    keep.trait.locale <- sapply(keep.traits, function(x) grep(x, colnames(scaled.pheno), ignore.case = TRUE))
}

if(length(adj.traits) > 0){
    adj.trait.locale <- as.vector(sapply(adj.traits, function(x) grep(x, colnames(scaled.pheno), ignore.case = TRUE)))
    keep.trait.locale <- setdiff(keep.trait.locale, adj.trait.locale)
    cca.pheno <- adjust(scaled.pheno[,keep.trait.locale], scaled.pheno[,adj.trait.locale])
}else{
    cca.pheno <- scaled.pheno[,keep.trait.locale]
}
```

```{r tissue_xz}
pheno.decomp <- plot.decomp(cca.pheno, pc = ncol(cca.pheno), plot.results = FALSE)
eig <- pheno.decomp$u
rownames(eig) <- rownames(cca.pheno)[pheno.decomp$rows.used]
colnames(eig) <- paste0("ET", 1:ncol(eig))

ET.loadings <- pheno.decomp$v
rownames(ET.loadings) <- colnames(cca.pheno)
colnames(ET.loadings) <- paste0("ET", 1:ncol(ET.loadings))
pheatmap(ET.loadings, cluster_rows = FALSE, cluster_cols = FALSE)

if(pheno_type == "traits"){
    matched.mats <- lapply(1:length(tissue.adj.expr), 
        function(x) get.xz(tissue.adj.expr[[x]], cca.pheno))
    file.text <- "trait"
}else{
    matched.mats <- lapply(1:length(tissue.adj.expr), 
        function(x) get.xz(tissue.adj.expr[[x]], eig))
    file.text <- "ET"
}
names(matched.mats) <- tissue.names
```


## Penalty Optimization {.tabset .tabset-fade .tabset-pills}

In the code below we do a sweep over a grid of penalties to look for 
penalty combinations that maximize the correlation between latent
transcripts and latent traits.

```{r opt_by_can_cor}
get_trait_description <- function(tissue.mats, tissue.results, short_version = FALSE){
    if(short_version){
        trait.description <- paste0("Composite_Trait", 1:ncol(tissue.mats$Z))
    }else{
        trait.names <- apply(tissue.results$v, 2, function(x) colnames(tissue.mats$Z)[which(x != 0)])
        trait.vals <- apply(tissue.results$v, 2, function(x) x[which(x != 0)])
        trait.order <- lapply(trait.vals, function(x) order(abs(x)))
        trait.description <- unlist(lapply(1:length(trait.names), function(x) paste(trait.names[[x]][trait.order[[x]]], collapse = "-")))
    }
    return(trait.description)
}

#get latent variables and variance explained for each pair
get_latent_var <- function(tissue.mats, tissue.results){
    latent.trans <- apply(tissue.results$u, 2, function(x) tissue.mats$X %*% x)
    latent.traits <- apply(tissue.results$v, 2, function(x) tissue.mats$Z %*% x)
    trait.desc <- get_trait_description(tissue.mats, tissue.results)
    r2 <- sapply(1:ncol(latent.trans), function(x) summary(lm(latent.traits[,x]~latent.trans[,x]))$adj.r.squared)
    names(r2) <- trait.desc
    result <- list("Latent_Traits" = latent.traits, "Latent_Transcripts" = latent.trans,
    "adj.r.squared" = r2)
    return(result)    
}

get_best_penalty  <- function(tissue.grid.results){
    penalty.labels <- apply(tissue.grid.results[[1]], 1, function(x) paste(x, collapse = "-"))
    tissue.grid.avg <- apply(tissue.grid.results[[2]], 1, max)
    penalties <- tissue.grid.results[[1]]

    median.penalty.mat <- matrix(NA, nrow = length(unique(penalties[,1])), 
    ncol = length(unique(penalties[,2])))
    x.pen <- sort(unique(penalties[,1]))
    z.pen <- sort(unique(penalties[,2]))
    rownames(median.penalty.mat) <- paste("Trait_Penalty", z.pen, sep = "_")
    colnames(median.penalty.mat) <- paste("Transcript_Penalty", x.pen, sep = "_")
    for(i in 1:nrow(penalties)){
        x.idx <- which(x.pen == penalties[i,1])
        z.idx <- which(z.pen == penalties[i,2])
        median.penalty.mat[z.idx, x.idx] <- tissue.grid.avg[i]
    }
    pheatmap(median.penalty.mat, cluster_rows = FALSE, cluster_cols = FALSE,
    display_numbers = TRUE)

    best.tissue.idx <- which.max(tissue.grid.avg)
    best.tissue.penalty <- tissue.grid.results[[1]][best.tissue.idx,]
    #box.col <- rep("gray", length(tissue.grid.avg))
    #box.col[best.islet.idx] <- "red"
    #boxplot(t(tissue.grid.results[[2]]), 
    #names = penalty.labels,
    #las = 2, cex.axis = 0.8, col = box.col)
    return(best.tissue.penalty)
}

get_perm_grid <- function(tissue.perm){
    xpen <- tissue.perm$penaltyxs
    zpen <- tissue.perm$penaltyzs
    uxpen <- sort(unique(xpen))
    uzpen <- sort(unique(zpen))

    zmat <- cor.mat <- p.mat <- matrix(NA, nrow = length(uxpen), ncol = length(uzpen))
    rownames(zmat) <- rownames(cor.mat) <- rownames(p.mat) <- uxpen
    colnames(zmat) <- colnames(cor.mat) <- colnames(p.mat) <- uzpen
    for(i in 1:length(xpen)){
        row.idx <- which(uxpen == xpen[i])
        col.idx <- which(uzpen == zpen[i])
        zmat[row.idx, col.idx] <- tissue.perm$zstats[i]
        cor.mat[row.idx, col.idx] <- tissue.perm$cors[i]
        p.mat[row.idx, col.idx] <- tissue.perm$pvals[i]
    }
    result <- list("Cor" = cor.mat, "Z" = zmat, "p" = p.mat)
    return(result)
}
```

For each set of transcripts, we performed sparse CCA over a series of penalties
to identify the penalty combinations that simultaneously yielded a significant
correlation and maximized the canonical correlation coefficient.


```{r penalty_opt, fig.width = 8, fig.height = 8, results = "asis"}
penalty.seq <- seq(0, 1, 0.1)
nperms = 10
tissue.trait.penalty <- vector(mode = "list", length = length(matched.mats))
names(tissue.trait.penalty) <- tissue.names
for(i in 1:length(matched.mats)){
    cat("###", tissue.names[i], "\n")
    #run permutations over the grid
    perm.file <- file.path(results.dir, paste0(tissue.names[i], ".", file.text, ".perm.RDS"))
    tissue.perm <- CCA_permute_grid(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
    filename = perm.file, search_grid = TRUE, nperms = nperms, n.penalty = 11)

    perm.results <- get_perm_grid(tissue.perm)
    par(mfrow = c(2,2))
    imageWithText(perm.results$Z, col.scale = "red", main = "Z statistics")
    imageWithText(perm.results$Cor, col.scale = "blue", main = "Correlation")
    imageWithText(-log10(perm.results$p+1e-6), col.scale = "purple", main = "-log10(p)")
    plot(abs(perm.results$Cor), -log10(perm.results$p+1e-6), 
    xlab = "Correlation",ylab = "-log10(p)")

    sig.cor.idx <- which(tissue.perm$pvals < 0.05)

    if(length(sig.cor.idx) > 0){
        best.cor.idx <- which.max(tissue.perm$ft.cors[sig.cor.idx])
        tissue.trait.penalty[[i]] <- c("X" = tissue.perm$penaltyxs[sig.cor.idx[best.cor.idx]], 
        "Y" = tissue.perm$penaltyzs[sig.cor.idx[best.cor.idx]])
    }else{
        tissue.trait.penalty[[i]] = NULL
    }
    cat("\n\n")
}
```


## CCA on all tissues

We then ran CCA on each tissue transcriptome-trait pair with the optimized 
penalties from above.

```{r run_CCA}
tissue.CCA.results <- vector(mode = "list", length = length(tissue.names))
names(tissue.CCA.results) <- tissue.names

for(i in 1:length(tissue.names)){
    num.components = ncol(matched.mats[[i]]$Z)
    if(!is.null(tissue.trait.penalty[[i]])){
        CCA.file <- file.path(results.dir, paste0(tissue.names[i], 
        ".", file.text, ".CCA.RDS"))
        if(!file.exists(CCA.file)){
            cca.results <- CCA(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
            typex = "standard", typez = "standard", K = num.components, 
            penaltyx = tissue.trait.penalty[[i]][1], 
            penaltyz = tissue.trait.penalty[[i]][2], 
            niter = 100, trace = FALSE)
            saveRDS(cca.results, CCA.file)
        }else{
            cca.results <- readRDS(CCA.file)
        }
    }else{
        cca.results <- NULL
    }
    tissue.CCA.results[[i]] <- cca.results
}
```

## Transcripts and Traits by Tissue {.tabset .tabset-fade .tabset-pills}

The following plot summarize information from the CCA results for 
each tissue. 

The first heatmap shows the loadings of each raw trait
on each composite trait. They are quite different between the tissues.

The boxplot shows summaries for the contributions of each trait
to get an overall idea of which traits contributed.

The barplot shows how many transcripts had non-zero loadings on each 
composite trait. The negative and positive loadings are shown separately.

The next two heatmaps shows the correlation matrix between transcript
loading patterns for the traits, and the jaccard index matrix for the
transcripts assigned to each trait respectively.
 
```{r transcript_num, fig.width = 7, fig.height = 6}

describe_results <- function(tissue.mats, tissue.results){
    if(is.null(tissue.results)){
        plot.text("No involvement in this tissue.")
    }else{

        trait.loadings <- tissue.results$v
        trait.description <- get_trait_description(tissue.mats, tissue.results, 
        short_version = TRUE)
        
        print("Trait Contributions to Composite Trait")
        rownames(trait.loadings) <- colnames(tissue.mats$Z)
        colnames(trait.loadings) <- trait.description
        pheatmap(t(trait.loadings), cluster_rows = FALSE, cluster_cols = FALSE)
        pheatmap(trait.loadings)

        print("Correlation Matrix for Composite Traits")
        pheatmap(cor(trait.loadings))

        print("Correlation Matrix for Original Traits")
        pheatmap(cor(t(trait.loadings[which(rowSums(trait.loadings) != 0),])))

        par(mar = c(10, 4, 4, 4))
        boxplot(t(trait.loadings), las = 2, 
        main = "Summary of Trait Contributions Across All Composite Trait")
        trait.list <- lapply(1:nrow(trait.loadings), function(x) trait.loadings[x,])
        names(trait.list) <- trait.description
        stripchart(trait.list, vertical = TRUE, method = "jitter", pch = 16, las = 2,
        add = TRUE)

        trait.specific <- which(apply(tissue.results$u, 1, function(x) length(which(x != 0))) == 1)
        pos.trans <- apply(tissue.results$u, 2, function(x) length(which(x > 0)))
        neg.trans <- apply(tissue.results$u, 2, function(x) length(which(x < 0)))
        
        cols <- brewer.pal(8, "Accent")
        par(mar = c(4,8, 4, 4))
        barplot(t(cbind(pos.trans, neg.trans)), beside = TRUE, 
        names = trait.description, las = 2, cex.names = 0.8, 
        col = cols[1:2], main = "Number of Transcripts Associated with Each Trait")
        legend("topleft", c("Positive", "Negative"), fill = cols[1:2])

        num.traits  <- apply(tissue.results$u, 1, function(x) length(which(x != 0)))
        num.totals <- table(num.traits)
        #num.totals <- c(num.totals, sum(num.totals[2:length(num.totals)]))
        #names(num.totals)[length(num.totals)] <- "Total"
        a <- barplot(num.totals, ylim = c(0, max(num.totals)*1.1),
        main = "Number of Transcripts Associated with Different Numbers of Traits")
        text(a[,1], (num.totals+(max(num.totals)*0.02)), labels = num.totals)

        print("Heatmap of correlations between transcript loadings for pairs of traits")
        has.loading <- which(rowSums(tissue.results$u) != 0)
        effect.mat <- tissue.results$u[has.loading,]
        cor.effect <- cor(effect.mat)
        rownames(cor.effect) <- colnames(cor.effect) <- trait.description
        diag(cor.effect) <- NA
        if(length(unique(cor.effect[upper.tri(cor.effect, diag = FALSE)])) > 1){
            pheatmap(cor.effect)
        }else{
            print("Too few correlations to show.")
        }

        trans.list <- apply(tissue.results$u, 2, function(x) colnames(tissue.mats$X)[which(x != 0)])
        names(trans.list) <- trait.description
        
        #print("Heatmap of Jaccard indices for non-zero transcripts across pairs of traits")
        #jacc.mat <- jaccard.matrix(trans.list)
        #diag(jacc.mat) <- NA
        #pheatmap(jacc.mat)
    }
}
```

```{r tissue_results, results = "asis"}
for(i in 1:length(tissue.CCA.results)){
    cat("###", tissue.names[i], "Transcripts per Trait", "\n")
    #pdf(file.path(results.dir, paste0("CCA_Results_", paste0(tissue.names[i], ".pdf"))))
    describe_results(matched.mats[[i]], tissue.CCA.results[[i]])
    #dev.off()
    cat("\n\n")
}
```

## Thoughts about CCA Results

*Latent Traits Overall*

* For now we have fit transcripts from each transcriptome to the traits independently.
This shows us that only islet transcripts are ever associated with the ex vivo
insulin traits. These traits are not correlated with transcripts in the other 
tissues.

* All tissues resulted in fairly similar contributions from traits:
    * All were primarily related to the HOMA traits, Ins_tAUC, Glu_tAUC, 
    Insulin at 10 and 14 weeks, food intake, and weight at 6 and 10 weeks

* Only islet and liver transcripts were associated with triglyceride levels.
Adipose transcripts were not.

*Islet transcripts and traits*

* The first 11 composite traits represent insulin/glucose homeostasis
and weight

* Composite traits 12, 15, 16, and 17 (less so 19) are all related to 
the ex vivo insulin traits

* Traits 18 through 20 describe insulin/glucose homeostasis in 6 week old animals.

* The transcript correlations group the traits into two primary groups

*Adipose transcripts and traits*

* Had the fewest contributions from the raw traits 

* The ex vivo traits never contribute to the composite traits 

*Liver transcripts and traits*

* Looked more similar to the islet transcriptome than the adipose transcriptome,
as far as trait contributions.

## Transcript Group Enrichment {.tabset .tabset-fade .tabset-pills}

We then looked for functional enrichment associated with each set of genes.
We sorted each by the magnitude of its association with the trait, and used
an ordered query in gprofiler.

```{r up_down_enrichment_fun}
get_up_down_enrichment <- function(tissue.mats, tissue.results, filename){
    if(is.null(tissue.results)){
        return(NULL)
    }
    trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.up.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] > 0))
    trait.down.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] < 0))
    names(trait.up.transcripts) <- names(trait.down.transcripts) <- trait.description
    #cbind(trait.description, sapply(trait.up.transcripts, length), sapply(trait.down.transcripts, length))
    tissue.nets <- vector(mode = "list", length = length(trait.up.transcripts))
    for(tr in 1:length(trait.up.transcripts)){
        trait.up.genes <- colnames(tissue.mats$X)[trait.up.transcripts[[tr]]]
        trait.up.vals <- tissue.results$u[trait.up.transcripts[[tr]],tr]
        names(trait.up.vals) <- trait.up.genes
        trait.down.genes <- colnames(tissue.mats$X)[trait.down.transcripts[[tr]]]
        trait.down.vals <- tissue.results$u[trait.down.transcripts[[tr]],tr]
        names(trait.down.vals) <- trait.down.genes
        trait.gene.groups <- list(sort(trait.up.vals, decreasing = TRUE), 
        sort(trait.down.vals, decreasing = FALSE))
        names(trait.gene.groups) <- paste0("Transcript", tr, c("_up", "_down"))
        tissue.nets[[tr]] <- trait.gene.groups
    }

    tissue.genes <- unlist(tissue.nets, recursive = FALSE)

    if(!file.exists(filename)){
        tissue.enrich <- lapply(tissue.genes, 
        function(x) if(length(names(x)) >= 5){gost(names(x), organism = "mmusculus", 
        sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE, evcodes = TRUE)}else{NULL})
        saveRDS(tissue.enrich, filename)
    }else{
        tissue.enrich <- readRDS(filename)
    }

    result <- list("Tissue_Transcripts" = tissue.nets, "Enrichments" = tissue.enrich)
}


get_enrichment_plus <- function(tissue.mats, tissue.results, ct){
    gene.vals <- tissue.results$u[,ct]
    neg.idx <- which(gene.vals < 0)
    pos.idx <- which(gene.vals > 0)
    neg.order <- order(gene.vals[neg.idx])
    pos.order <- order(gene.vals[pos.idx], decreasing = TRUE)
    ordered.pos <- colnames(tissue.mats$X)[pos.idx[pos.order]]
    ordered.neg <- colnames(tissue.mats$X)[neg.idx[neg.order]]
    #plot(gene.vals[pos.idx[pos.order]])
    #plot(gene.vals[neg.idx[neg.order]])
    pos.enrich <- gost(ordered.pos, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    #plot.enrichment(pos.enrich, max.term.size = 2000)
    neg.enrich <- gost(ordered.neg, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    result <- list("positive_enrichment" = pos.enrich, 
    "negative_enrichment" = neg.enrich)
    return(result)
}

enrichment_plus_genes <- function(enrichment.plus, search.terms){
    results.table <- enrichment.plus$result
    term.position <- unique(unlist(lapply(search.terms, function(x) grep(x, results.table[,"term_name"], ignore.case = TRUE))))
    if(length(term.position) > 0){
        sub.results <- results.table[term.position,]
    }else{
        sub.results <- "Terms not found"
    }
    return(sub.results)
}
```


```{r tissue_enrich}
tissue.enrich <- vector(mode = "list", length = length(tissue.names))
names(tissue.enrich) <- tissue.names

for(i in 1:length(tissue.names)){
    tissue.enrich[[i]] <- get_up_down_enrichment(matched.mats[[i]], 
    tissue.CCA.results[[i]], file.path(results.dir, 
    paste0(tissue.names[i], ".", file.text, ".enrichment.RDS")))
}

#transcript.ids <- lapply(tissue.enrich, function(x) unlist(x[[1]]))
```

The following figures show the functional enrichments for the transcripts with
positive and negative loadings on each trait for each tissue.

We present this in several different types of figures.

For each trait we show a table of the significant enrichments for the 
transcripts with positive loadings and the transcripts with negative 
loadings side by side.

We then combined these into one heatmap plot to show all the traits 
and their enrichments together.

Finally, we took the top 10 enriched terms from each trait, and constructed
a bipartite graph between traits and enriched terms. We projected this network
onto the traits and the terms. Rather amazingly, the terms for each tissue
cluster into beautiful functional clusters

```{r plot_enrichment}
plot_tissue_enrich <- function(tissue.mats, tissue.results, enrichment.results, 
max.term.size = 2000, num.terms = 30){
    if(is.null(tissue.results)){
        plot.text("No involvement of this tissue.")
        return(NULL)
    }
    #trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.description <- paste0("Composite_Transcript", 1:ncol(tissue.mats$Z))
    tissue.enrich <- enrichment.results[[2]]
    idx <- 1
    for(i in 1:length(trait.description)){
        cat("####", trait.description[i], "\n")
        #quartz(width = 12, height = 7)
        par(mfrow = c(1,2))
        for(dir in 1:2){
            plot.enrichment(tissue.enrich[[idx]], num.terms = num.terms, 
            plot.label = names(tissue.enrich)[idx], 
            max.term.size = max.term.size, text.size = 0.8)
            idx = idx + 1
        }
        mtext(trait.description[i], outer = TRUE, side = 3, line = -2.5)
        cat("\n\n")
    }
cat("\n\n")
}


#This function covers specified nodes in a network with
#white boxes, similar to how we would in Keynote to erase
#something.
cover_nodes <- function(bip.net, label.term = "Transcript", 
search.name = c("partial", "full"), rad = 0.1, border.col = "white",
fill.col = "white"){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        circ.coord <- get_circle(rad, center_x = mid.x, center_y = mid.y, dens = 0.05)
        polygon(circ.coord$x, circ.coord$y, col = fill.col, border = border.col)
    }
}

add_picture_nodes <- function(bip.net, val.mat, label.term = "Transcript", 
search.name = c("partial", "full"), rect.width = 0.1, rect.height = 0.1, lwd = 0.5){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        min.x <- mid.x - (rect.width/2)
        max.x <- mid.x + (rect.width/2)
        min.y <- mid.y - (rect.height/2)
        max.y <- mid.y + (rect.height/2)
        
        x.pts <- scale.between.vals(1:nrow(val.mat), min.x, max.x)
        y.vals <- scale.between.vals(val.mat[,i], min.y, max.y)
        pt.col <- colors.from.values(val.mat[,i], use.pheatmap.colors = TRUE,
        global.color.scale = TRUE, global.min = min(val.mat), global.max = max(val.mat))
        #barplot(val.mat[,i], col = pt.col, las = 2)
        #barplot(1:length(pt.col), col = pt.col)
        #plot.new()
        #plot.window(xlim = c(min.x, max.x), ylim = c(min.y, max.y))
        segments(x0 = x.pts, y0 = min.y, y1 = max.y, col = pt.col, lwd = lwd)
    }
}

#This function plots a bipartite network and replaces the transcript
#nodes with pictures of the effects of that transcript on the traits.
#Because the up and down transcript effects are separated, we multiply
#the down-transcripts by -1 to reverse the trait effects. 
plot_decorated_bip <- function(tissue.bip, tissue.mats, tissue.results, filename,
fig.width = 20, fig.height = 20){
    pdf(filename, width = fig.width, height = fig.height)

    if(is.null(tissue.bip)){
        plot.text("No Bipartite Graph to Show")
        dev.off()
        return(NULL)
    }

    trait.loadings <- tissue.results$v
    rownames(trait.loadings) <- colnames(tissue.mats$Z)
    colnames(trait.loadings) <- paste("Composite_Trait", 1:ncol(trait.loadings))
    #pheatmap(trait.loadings)
    exp.trait.mat <- Reduce("cbind", lapply(1:nrow(trait.loadings), 
    function(x) cbind(trait.loadings[,x,drop=FALSE], trait.loadings[,x,drop=FALSE]*-1)))
    trait.clust <- hclust(dist(exp.trait.mat))
    #plot(trait.clust)
    trait.order <- trait.clust$order
    pheatmap(t(exp.trait.mat[trait.order,seq(1,ncol(exp.trait.mat), 2)]),cex = 2)

    plot(tissue.bip, vertex.size = 5, layout = layout_with_kk,
    vertex.label.dist = 0.7, vertex.label.adj = 1)
    cover_nodes(tissue.bip, label.term = "Transcript", 
    search.name = c("partial", "full"), rad = 0.03)
    add_picture_nodes(tissue.bip, exp.trait.mat[trait.order,], 
    label.term = "Transcript", search.name = "partial", rect.width = 0.06, 
    rect.height = 0.04, lwd = 2)

    par(xpd = TRUE)
    text.x <- segment.region(-1, -0.5, nrow(exp.trait.mat))
    text.y <- rep(-0.9, nrow(exp.trait.mat))
    text(text.x, text.y, rownames(exp.trait.mat)[trait.order], srt = 270, adj = 1)
    text(x = -0.75, y = -0.95, "Trait Order in Figure")
    par(xpd = FALSE)
    dev.off()

}

```

## Individual Composite Trait Enrichments {.tabset .tabset-fade .tabset-pills}

```{r plot_enrich, results = "asis", fig.width = 12, fig.height = 10}
max.term.size = 2000
num.terms = 10

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    plot_tissue_enrich(tissue.mats = matched.mats[[i]], 
    tissue.results = tissue.CCA.results[[i]], 
    enrichment.results = tissue.enrich[[i]], 
    max.term.size = max.term.size, num.terms = 30)
    cat("\n\n")
}
```


## Composite Trait Enrichment Heatmaps {.tabset .tabset-fade .tabset-pills}

```{r all_enrichment_heatmaps, fig.height = 15, fig.width = 7, results = "asis"}
#pdf("~/Desktop/liver.enrich.pdf", height = 40, width = 9)
enrich.mats <- vector(mode = "list", length = length(tissue.names))
names(enrich.mats) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(sum(sapply(tissue.enrich[[i]][[2]], length)) > 0){
        enrich.mats[[i]] <- plot.enrichment.group(tissue.enrich[[i]][[2]], 
        n.terms = num.terms, max.term.size = max.term.size, transformation = sqrt)
    }else{
        plot.text("No Enrichment")
    }
    cat("\n\n")
}
#dev.off()
```


## Traits and Terms Networks {.tabset .tabset-fade .tabset-pills}

Here we visualize the enrichments in a different way. We want to see
how the traits and terms are associated

```{r trait_term, fig.width = 10, fig.height = 10, results = "asis"}
enrich.bips <- vector(mode = "list", length = length(tissue.names))
names(enrich.bips) <- tissue.names

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")

    if(length(enrich.mats[[i]]) > 0){
        enrich.bips[[i]] <- enrich_bipartite_proj(enrich.mats[[i]], vertex.col = "gray", 
        label.vertex = NULL, label.col = "lightblue", search.name = "partial")
    
        plot_decorated_bip(enrich.bips[[i]]$Network, matched.mats[[i]], 
        tissue.CCA.results[[i]], 
        file.path(results.dir, paste0("Bip_", tissue.names[i], ".", file.text, ".pdf")),
        fig.width = 30, fig.height = 30)
    }else{
        plot.text("No Enrichments")
    }

    cat("\n\n")
}
```

## Network Projections onto Traits {.tabset .tabset-fade .tabset-pills}

Here we look at the trait projection of each bipartite 
network constructed above.

```{r trait_proj, fig.width = 10, fig.height = 15, results = "asis"}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(length(enrich.mats[[i]]) > 0){
        plot(enrich.bips[[i]]$Projections[[2]], 
        vertex.size = 5, layout = layout_with_kk) #trait projection
    }else{
        plot.text("No Enrichments")
    }
    cat("\n\n")
}
```

## Network Projections onto Terms {.tabset .tabset-fade .tabset-pills}

Here we look at the term projection of each bipartite 
network constructed above.

```{r term_proj, fig.width = 10, fig.height = 15, results = "asis"}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(length(enrich.mats[[i]]) > 0){
        plot(enrich.bips[[i]]$Projections[[1]], 
        vertex.size = 5, layout = layout_with_kk) #trait projection
    }else{
        plot.text("No Enrichments")
    }
    cat("\n\n")
}
```

## Sandbox

This is a set of code that is not executed, but can be used to explore networks
a bit more. 

```{r term_genes, eval = FALSE}
#here I'm playing around to find genes associated with the GO
#terms of interest for a given tissue for a plot for Greg
#We see that liver trait 7 is associated with mitochondrial 
#respiration, so we look for genes annotated to apoptosis and 
#find their loadings in our traits
tissue = "Liver"; ct <- 1; search.term.up = c("histone", "chromatin"); search.term.down = c("fatty", "acid", "lipid")
#tissue = "Adipose"; ct <- 1; search.term.down = c("cytokine", "leukocyte", "immune"); search.term.up = c("acid", "oxidation")
#tissue = "Adipose"; ct <- 20; search.term.down = "rna"; search.term.up = "stress"
#tissue = "Islet"; ct <- 17; search.term.down = c("mitosis", "mitotic", "division", "cycle"); search.term.up = c("rna", "mrna")
#tissue = "Islet"; ct <- 20; search.term.down = "rna"; search.term.up = "stress"

tissue.locale <- which(tissue.names == tissue)
ct.enrich <- get_enrichment_plus(matched.mats[[tissue.locale]], 
tissue.CCA.results[[tissue.locale]], ct)

plot.enrichment(ct.enrich[[1]], num.terms = 30, max.term.size = 2000)
plot.enrichment(ct.enrich[[2]], num.terms = 30, max.term.size = 2000)

ct.genes <- enrichment_plus_genes(ct.enrich[[1]], 
search.term = search.term.up)

ct.genes <- enrichment_plus_genes(ct.enrich[[2]], 
search.term = search.term.down)

gene.query <- unique(unlist(strsplit(ct.genes[,"intersection"], ",")))
ct.gene.table <- getBM(c("external_gene_name", "ensembl_gene_id", "chromosome_name", "start_position", "end_position"), 
"ensembl_gene_id", gene.query, mus)

table(ct.gene.table[,"chromosome_name"])
ct.gene.locale <- match(ct.gene.table[,"ensembl_gene_id"], colnames(matched.mats[[tissue.locale]]$X))
gene.vals  <- tissue.CCA.results[[tissue.locale]]$u[ct.gene.locale,ct]
names(gene.vals) <- ct.gene.table[,"external_gene_name"]
sort(gene.vals)

#look for connections between these genes and diabetes on pubmed
lit.genes <- names(head(sort(gene.vals), 10)) #for neg genes
#lit.genes <- names(tail(sort(gene.vals), 3)) #for pos genes
#lit.genes <- names(sort(gene.vals))
all.pubmed <- lapply_pb(as.vector(lit.genes), 
function(x) get_pubmed_ids(paste("Diabetes AND", tissue, "AND", x)))
num.papers <- unlist(lapply(all.pubmed, function(x) x$Count))
with.papers <- which(num.papers != 0)
cbind(lit.genes, num.papers)
cbind(lit.genes[with.papers], num.papers[with.papers])
has.data <- all.pubmed[with.papers]
all.abstracts <- lapply(has.data, function(x) fetch_pubmed_data(x, format = "abstract"))
names(all.abstracts) <- lit.genes[with.papers]
```


## QTL mapping modules {.tabset .tabset-fade .tabset-pills}

We used qtl2 to map each of the composite traits. The results are as follows.

```{r map_transcripts, results = "asis", fig.height = 5, fig.width = 7}
qtl.results <- vector(mode = "list", length = length(tissue.names))
names(qtl.results) <- tissue.names

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    trans <- apply(tissue.CCA.results[[i]]$u, 2, function(x) matched.mats[[i]]$X %*% x)
    rownames(trans) <- rownames(matched.mats[[i]]$X)
    colnames(trans) <- paste0("CTrans", 1:ncol(trans))

    trait.trans.cor <- sapply(1:ncol(trans), 
    function(x) apply(matched.mats[[i]]$Z, 2, function(y) cor(trans[,x], y)))
    pheatmap(trait.trans.cor)

    qtl.file <- file.path(results.dir, paste0("QTL.", tissue.names[i], ".", file.text, ".RDS"))
    if(!file.exists(qtl.file)){
        tissue.qtl <- scan1(genoprobs, trans)
        qtl.results[[i]] <- tissue.qtl
        saveRDS(tissue.qtl, qtl.file)
    }else{
        qtl.results[[i]] <- readRDS(qtl.file)
    }

    for(j in 1:ncol(qtl.results[[i]])){
        cat("#### Composite Transcript", i, "\n")
        if(is.interactive){quartz(width = 8, height = 5)}
        plot(qtl.results[[i]], j, map = map, main = paste("Composite Transcript", j))
        cat("\n\n")
    }    
cat("\n\n")
}
```

## LOD Score Heatmaps {.tabset .tabset-fade .tabset-pills}
```{r lodheat, fig.width = 10, fig.height = 5, results = "asis"}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(is.interactive){quartz(width = 10, height = 5)}
    multilod.plot(qtl.results[[i]], map, lod.thresh = 4, chr.label.y = 0, 
    chr.label.cex = 1, row.names = colnames(qtl.results[[i]]))
    cat("\n\n")
}
```

## Allele Coefficients for QTL with High LOD Scores {.tabset .tabset-fade .tabset-pills}

For the largest QTL in each trait, we calculated the DO allele coefficients.

```{r allele_plots, results = "asis", fig.height = 7, fig.width = 7}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(!is.null(tissue.CCA.results[[i]]$u)){
        lodthresh <- floor(max(apply(qtl.results[[i]], 2, max)))
        peak.table <- find_peaks(qtl.results[[i]], map = map, threshold = lodthresh, 
        prob = 0.99)
        if(nrow(peak.table) > 0){
            for(idx in 1:nrow(peak.table)){
                cat("####", peak.table[idx,"lodcolumn"], ", Chr", peak.table[idx,"chr"], 
                ", LOD", signif(peak.table[idx,"lod"], 2), "\n")
                trait = peak.table[idx,2]; chr = peak.table[idx,3]

                trans <- apply(tissue.CCA.results[[i]]$u, 2, function(x) matched.mats[[i]]$X %*% x)
                rownames(trans) <- rownames(matched.mats[[i]]$X)
                colnames(trans) <- paste0("CTrans", 1:ncol(trans))

                chr.lod <- scan1(genoprobs[,chr], trans[,trait,drop=FALSE])
                chr.coef <- scan1coef(genoprobs[,chr], trans[,trait,drop=FALSE])
                if(is.interactive){quartz()}
                par(mfrow = c(2,1), mar = c(2,2,2,2))
                plot(chr.lod, map = map)
                plot_coefCC(chr.coef, map = map)
                mtext(paste("CT", trait, "Chr" = chr), side = 3, outer = TRUE, line = -2)
                cat("\n\n")
            }
        }else{
            plot.text(paste("No QTL above", lodthresh))
        }
    }else{
        plot.text("No involvement from this tissue.")
    }
}
```

## Conclusion