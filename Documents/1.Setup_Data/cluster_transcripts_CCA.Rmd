---
title: "Clustering transcripts with CCA"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow explores the possibility of using CCA to transcript clusters
that correlate with specific traits. We will be playing around a lot with 
different trait inputs. In the first code chunk, set the traits analyzed
along with an experiment name for keeping results from different runs 
separate.


```{r get_args}
args <- commandArgs(trailingOnly=T)
exp.name = args[1]
delete_previous <- as.logical(args[2])
fused.lasso = as.logical(args[3]) #whether to use fused lasso for the transcripts

if(is.na(exp.name)){
    exp.name <- "all_traits"
    #exp.name <- "weight_adjusted"
    #delete_previous <- TRUE
    delete_previous <- FALSE
    fused.lasso <- FALSE
}

if(fused.lasso){
    lasso.text = "does"
}else{
    lasso.text = "does not"
}
```

This file describes results for `r exp.name`. It `r lasso.text` used fused lasso.

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "CCA_Clusters", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r delete_previous}
if(delete_previous){
    results.files <- list.files(results.dir, full.names = TRUE)
    unlink(results.files)
}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "cape", "PMA", "abind", "cluster",
"RColorBrewer", "igraph", "corpcor", "easyPubMed", "knitr", "kableExtra",
"ape", "simplifyEnrichment")
load_libraries(all.packages)
data(CCcolors)
```

Read in pre-filtered and pre-adjusted transcript data from 
adjust_transcripts_traits.Rmd

```{r read_data}
tissue.adj.expr <- readRDS(file.path(results.dir, "Adjusted_Expression.RDS"))
pheno.file <- here("Results", "CCA_Clusters", exp.name, "Adjusted_Phenotypes.RDS")
cca.pheno <- readRDS(pheno.file)
tissue.names <- names(tissue.adj.expr)

tissue.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
data.set.names <- lapply(1:length(tissue.names), 
function(x) paste0("dataset.DO.Cube.", tissue.names[x]))
gene.table <- as.matrix(unique(Reduce("rbind", lapply(data.set.names, function(x) get(x)$annot.mrna))))


#if using fused lasso read in the clusters from CoExpNets
#generated by cluster_transcrpts.Rmd

if(fused.lasso){
    net.files <- lapply(tissue.names, function(x)
    get.files(here("Results", "Expr_Clusters", paste0(x, "_", exp.name)), want = "net",
    full.names = TRUE))
    tissue.mods <- lapply(net.files, readRDS)
    net.enrichment.files <- lapply(tissue.names, function(x)
    get.files(here("Results", "Expr_Clusters", paste0(x, "_", exp.name)), want = "enrichment",
    full.names = TRUE))
    tissue.mod.enrich <- lapply(net.enrichment.files, readRDS)
}
```

## Transcript PCA

The following plot shows the first two principal components of the 
full transcript matrix. 

I was expecting separation by tissue, but they all overlap each other. 

```{r transcript_overlap}
transcript.list <- lapply(tissue.adj.expr, colnames)
plotVenn(transcript.list)

common.transcripts <- Reduce("intersect", transcript.list)
common.transcript.idx <- lapply(tissue.adj.expr, function(x) match(common.transcripts, colnames(x)))
common.ind <- Reduce("intersect", lapply(tissue.adj.expr, rownames))
common.ind.idx <- lapply(tissue.adj.expr, function(x) match(common.ind, rownames(x)))

tissue.label <- unlist(lapply(1:length(tissue.adj.expr), 
function(x) rep(names(tissue.adj.expr)[x], ncol(tissue.adj.expr[[x]]))))

matched.expr <- lapply(1:length(tissue.adj.expr), 
function(x) tissue.adj.expr[[x]][common.ind.idx[[x]], common.transcript.idx[[x]]])

stop()

all.expr <- Reduce("cbind", matched.expr)

expr.decomp.file <- file.path(results.dir, "all.expr.decomp.RDS")
if(!file.exists(expr.decomp.file)){
    expr.decomp <- plot.decomp(all.expr, plot.results = FALSE)
    saveRDS(expr.decomp, expr.decomp.file)
}else{
    expr.decomp <- readRDS(expr.decomp.file)
}


plot(expr.decomp$v, col = as.numeric(as.factor(tissue.label)), pch = 16,
xlab = "PC1", ylab = "PC2")
legend("topleft", legend = levels(as.factor(tissue.label)), 
col = 1:length(unique(tissue.label)), pch = 16)
```

## Transcript Correlation

The following plot shows the distribution of transcript i in one tissue 
with transcript i in another tissue.

```{r plot_transcript_cor, fig.height = 10, fig.width = 3.5}
tissue.pairs <- pair.matrix(1:length(tissue.names))
tissue.expr.comp <- vector(mode = "list", length = nrow(tissue.pairs))
for(i in 1:nrow(tissue.pairs)){
    tissue.expr.comp[[i]] <- sapply(1:ncol(matched.expr[[1]]),
    function(x) cor(matched.expr[[tissue.pairs[i,1]]][,x], matched.expr[[tissue.pairs[i,2]]][,x]))
}

#quartz(height = 9, width = 3.5)
par(mfrow = c(length(matched.expr),1), mar = c(0, 2, 0, 2))
for(i in 1:length(matched.expr)){
    tissue1 <- tissue.names[tissue.pairs[i,1]]
    tissue2 <- tissue.names[tissue.pairs[i,2]]
    a <- hist(tissue.expr.comp[[i]], xlim = c(-1, 1), axes = FALSE, xlab = "", 
    ylab = "", main = "", breaks = 100, border = NA)
    points(x = median(tissue.expr.comp[[i]]), y = 0, pch = "*", 
    col = "#2b8cbe", cex = 3)
    text(x = -0.1, y = max(a$counts)*0.75, paste(tissue1, tissue2, sep = "-"), 
    adj = 1, cex = 2)
}
axis(1, cex.axis = 2)
par(xpd = NA)
abline(v = 0, col = "darkgray", lty = 2)
par(xpd = FALSE)

```

## Trait Correlation

The following heatmap shows the correlations between pairs of traits
after adjusting for covariates, and any specified traits, such as 
weight. The traits were also scaled prior to calculating correlations.

```{r pheno_cor, fig.height = 6, fig.width = 6}
trait.order <- hclust(dist(t(cca.pheno)))$order
layout(matrix(c(1,2), ncol = 2), widths = c(0.8, 0.2))
par(mar = c(8, 8, 2, 2))

pheatmap(cor(cca.pheno, use = "pairwise.complete.obs")[trait.order, trait.order],
cluster_rows = FALSE, cluster_cols = FALSE)
```

## Trait Partial Correlation

We also looked at the partial correlation of all pairs of variables.
To do this, we used pcor.shrink from corpcor.

The heat map below shows the full partial correlation matrix. It is
dominated by the ex vivo insulin traits. WPIC is basically perfectly
correlated with both insulin per islet and the number, as you might
imagine. Insulin per islet is perfectly negatively correlated with 
number of islets. So as there are fewer islets, each one secretes 
more insulin.

```{r par_cor, fig.height = 6, fig.width = 6}
test.decomp <- plot.decomp(cca.pheno, plot.results = FALSE)
not.num.islet <- which(colnames(cca.pheno) != "WPIC")
par.cor <- pcor.shrink(cca.pheno[test.decomp$rows.used,not.num.islet]) #take out WPIC, which is derived from num_islets and Ins_per_islet
pheatmap(par.cor)
```

The heat map below shows the partial correlation traits with the
ex vivo traits removed so we can better see the other correlations.

This shows some potentially interesting patterns. 
Glu_tAUC and Ins_tAUC are negatively correlated. That is, the larger
your insulin response, the faster your glucose goes down. And the smaller 
your insulin response, the more slowly your glucose goes down. This is how 
it should be, I think. 

HOMA_IR, insulin resistance, is positively correlated with Glu_tAUC,
which makes sense. The more resistant you are, the slower your glucose
will go down. 

HOMA_B, beta cell function, is negatively correlated with Glu_tAUC.
The worse your beta cell function, the less insulin you produce, and
the more slowly your glucose goes down.

However, HOMA_IR and HOMA_B are still positively correlated. So beta 
cell function is still compensating for insulin resistance in this 
population.

Weight at different times has different correlations with insulin.
There could be interesting causal relationships here in both directions.
But it's complicated.

Food intake is negatively correlated with insulin at 10 weeks, and
positively correlated with weight at 10 weeks. So more food is 
increasing weight, but potentially reducing islet function, and
reducing insulin production.

```{r par_cor_trimmed, fig.height = 7, fig.width = 7}
col.order <- hclust(dist(par.cor))$order
trimmed.par.cor <- par.cor
diag(trimmed.par.cor) <- NA
if(length(which(trimmed.par.cor < 0)) > 0 && length(which(trimmed.par.cor > 0)) > 0){
    imageWithText(trimmed.par.cor[col.order, col.order], split.at.vals = TRUE,
    col.scale = c("blue", "brown"), grad.dir = "ends", sig.digs = 2, col.text.shift = -1,
    row.text.shift = -1)
}else{
    imageWithText(trimmed.par.cor[col.order, col.order], split.at.vals = FALSE,
    sig.digs = 2, col.scale = "blue", cex = 1)
}
```

## Identify covariation in transcripts and traits using CCA

This is an experimental process. I want to see if we can use CCA 
to identify composite transcripts that are correlated with composite 
traits.

Get the X and Z matrices for putting into PMA.
X is the transcript matrix for the appropriate tissue, 
and Z is the trait matrix (traits, or ETs).

The function get.xz aligns the two matrices by individual.
If pheno_type is set to traits, use the trait matrix, if it is
set to eigentraits, use the eigentrait matrix.

We want to use a LASSO penalty to sparsify the transcriptome in each
tissue. This helps with interpretation. However, we also want to smooth
loadings over correlated genes. To do this, we use fused LASSO in PMA.
We put the transcripts from different modules onto different "chromosomes"
in PMA, and we order the transcripts based on their correlation to the 
module eigengene.

```{r tissue_xz}
matched.mats <- lapply(1:length(tissue.adj.expr), 
    function(x) get.xz(tissue.adj.expr[[x]], cca.pheno))
file.text <- "trait"
names(matched.mats) <- tissue.names
```

The following code identifies a "chromosome" (module) for each transcript in 
each transcriptome, and orders transcripts within a module based on their
correlation to the module eigengene. This code is only run if fused LASSO 
is requested.

```{r order_transcripts}

if(fused.lasso){
    transcript.order.file <- file.path(results.dir, "Transcript.Order.RDS")
    chr.label.file <- file.path(results.dir, "ChromX.RDS")

    if(!file.exists(transcript.order.file)){
        ordered.transcripts <- chr.labels <- vector(mode = "list", length = length(tissue.names))
        names(ordered.transcripts) <- names(chr.labels) <- tissue.names

        for(i in 1:length(tissue.names)){

            mods <- tissue.mods[[i]]$moduleColors
            umods <- unique(mods)
            mod.mem <- sapply(umods, function(x) length(which(mods == x)))
            mod.order <- order(mod.mem, decreasing = TRUE)
            ordered.mods <- umods[mod.order]
            MEs <- tissue.mods[[i]]$MEs[,mod.order]
            tissue.expr <- tissue.adj.expr[[i]]

            trans.order <- vector(mode = "list", length = length(umods))
            chromosome <- vector(mode = "list", length = length(umods))

            for(m in 1:length(umods)){
                #print(m)
                m.transcripts <- which(mods == ordered.mods[m])
                me.cor <- sapply(m.transcripts, function(x) cor(tissue.expr[,x], MEs[,m]))
                #pair.dist <- dist(t(tissue.expr[,m.transcripts]))
                #pair.clust <- hclust(pair.dist)
                #transcript.order.clust <- pair.clust$order
                #transcript.order.me <- order(me.cor, decreasing = TRUE)
                transcript.order <- order(me.cor, decreasing = TRUE) #use module eigengene ordering
                #pdf("~/Desktop/transcript.order.pdf")
                #pheatmap(cor(tissue.expr[,m.transcripts[transcript.order.clust]]), cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = FALSE)
                #pheatmap(cor(tissue.expr[,m.transcripts[transcript.order.me]]), cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = FALSE)
                #dev.off()
                trans.order[[m]] <- m.transcripts[transcript.order]
                chromosome[[m]] <- rep(m, length(m.transcripts))
            }

            ordered.transcripts[[i]] <- unlist(trans.order)
            chr.labels[[i]] <- unlist(chromosome)
        }
        saveRDS(ordered.transcripts, transcript.order.file)
        saveRDS(chr.labels, chr.label.file)
    }else{
        ordered.transcripts <- readRDS(transcript.order.file)
        chr.labels <- readRDS(chr.label.file)
    }
} #end case for using fused lasso
```

## Penalty Optimization {.tabset .tabset-fade .tabset-pills}

In the code below we do a sweep over a grid of penalties to look for 
penalty combinations that maximize the correlation between latent
transcripts and latent traits.

```{r opt_by_can_cor}
get_trait_description <- function(tissue.mats, tissue.results, short_version = FALSE){
    if(short_version){
        trait.description <- paste0("Composite_Trait", 1:ncol(tissue.mats$Z))
    }else{
        trait.names <- apply(tissue.results$v, 2, function(x) colnames(tissue.mats$Z)[which(x != 0)])
        trait.vals <- apply(tissue.results$v, 2, function(x) x[which(x != 0)])
        trait.order <- lapply(trait.vals, function(x) order(abs(x)))
        trait.description <- unlist(lapply(1:length(trait.names), function(x) paste(trait.names[[x]][trait.order[[x]]], collapse = "-")))
    }
    return(trait.description)
}

#get latent variables and variance explained for each pair
get_latent_var <- function(tissue.mats, tissue.results){
    latent.trans <- apply(tissue.results$u, 2, function(x) tissue.mats$X %*% x)
    latent.traits <- apply(tissue.results$v, 2, function(x) tissue.mats$Z %*% x)
    colnames(latent.trans) <- paste0("Composite_Transcript", 1:ncol(latent.trans))
    colnames(latent.traits) <- paste0("Composite_Trait", 1:ncol(latent.trans))
    rownames(latent.trans) <- rownames(latent.traits) <- rownames(tissue.mats$X)
    r2 <- sapply(1:ncol(latent.trans), function(x) summary(lm(latent.traits[,x]~latent.trans[,x]))$adj.r.squared)
    names(r2) <- paste0("Composite_Cor", 1:length(r2))
    result <- list("Composite_Traits" = latent.traits, 
    "Composite_Transcripts" = latent.trans,
    "adj.r.squared" = r2)
    return(result) 
}

get_best_penalty  <- function(tissue.grid.results){
    penalty.labels <- apply(tissue.grid.results[[1]], 1, function(x) paste(x, collapse = "-"))
    tissue.grid.avg <- apply(tissue.grid.results[[2]], 1, max)
    penalties <- tissue.grid.results[[1]]

    median.penalty.mat <- matrix(NA, nrow = length(unique(penalties[,1])), 
    ncol = length(unique(penalties[,2])))
    x.pen <- sort(unique(penalties[,1]))
    z.pen <- sort(unique(penalties[,2]))
    rownames(median.penalty.mat) <- paste("Trait_Penalty", z.pen, sep = "_")
    colnames(median.penalty.mat) <- paste("Transcript_Penalty", x.pen, sep = "_")
    for(i in 1:nrow(penalties)){
        x.idx <- which(x.pen == penalties[i,1])
        z.idx <- which(z.pen == penalties[i,2])
        median.penalty.mat[z.idx, x.idx] <- tissue.grid.avg[i]
    }
    pheatmap(median.penalty.mat, cluster_rows = FALSE, cluster_cols = FALSE,
    display_numbers = TRUE)

    best.tissue.idx <- which.max(tissue.grid.avg)
    best.tissue.penalty <- tissue.grid.results[[1]][best.tissue.idx,]
    #box.col <- rep("gray", length(tissue.grid.avg))
    #box.col[best.islet.idx] <- "red"
    #boxplot(t(tissue.grid.results[[2]]), 
    #names = penalty.labels,
    #las = 2, cex.axis = 0.8, col = box.col)
    return(best.tissue.penalty)
}

get_perm_grid <- function(tissue.perm){
    xpen <- tissue.perm$penaltyxs
    zpen <- tissue.perm$penaltyzs
    uxpen <- sort(unique(xpen))
    uzpen <- sort(unique(zpen))

    zmat <- cor.mat <- p.mat <- matrix(NA, nrow = length(uxpen), ncol = length(uzpen))
    rownames(zmat) <- rownames(cor.mat) <- rownames(p.mat) <- uxpen
    colnames(zmat) <- colnames(cor.mat) <- colnames(p.mat) <- uzpen
    for(i in 1:length(xpen)){
        row.idx <- which(uxpen == xpen[i])
        col.idx <- which(uzpen == zpen[i])
        zmat[row.idx, col.idx] <- tissue.perm$zstats[i]
        cor.mat[row.idx, col.idx] <- tissue.perm$cors[i]
        p.mat[row.idx, col.idx] <- tissue.perm$pvals[i]
    }
    result <- list("Cor" = cor.mat, "Z" = zmat, "p" = p.mat)
    return(result)
}
```

For each set of transcripts, we performed sparse CCA over a series of penalties
to identify the penalty combinations that simultaneously yielded a significant
correlation and maximized the canonical correlation coefficient.


```{r penalty_opt, fig.width = 8, fig.height = 8, results = "asis"}
nperms = 10
perm.components = FALSE
tissue.trait.penalty <- vector(mode = "list", length = length(matched.mats))
names(tissue.trait.penalty) <- tissue.names
for(i in 1:length(matched.mats)){
    cat("###", tissue.names[i], "\n")
    #run permutations over the grid
    perm.file <- file.path(results.dir, paste0(tissue.names[i], ".", file.text, ".perm.RDS"))

    if(fused.lasso){
        #penalty range for fused lasso is different
        if(!perm.components){
            tissue.perm <- CCA_permute_grid(X = matched.mats[[i]]$X[,ordered.transcripts[[i]]], 
            Z = matched.mats[[i]]$Z, chromx = chr.labels[[i]], filename = perm.file, 
            search_grid = TRUE, nperms = nperms, x_penalty = seq(0, 0.07, 0.01),
            z_penalty = seq(0, 1, 0.1))
        }else{
            #do permutations for all components
            tissue.perm <- CCA_permute_components(
            X = matched.mats[[i]]$X[,ordered.transcripts[[i]]], 
            Z = matched.mats[[i]]$Z, chromx = chr.labels[[i]], 
            filename = perm.file, search_grid = TRUE, nperms = nperms, 
            x_penalty = seq(0, 0.1, 0.01), z_penalty = seq(0, 1, 0.1),
            verbose = TRUE, plot.results = TRUE)
        }
    }else{
        if(!perm.components){
            tissue.perm <- CCA_permute_grid(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
            filename = perm.file, search_grid = TRUE, nperms = nperms, 
            x_penalty = seq(0, 1, 0.1), z_penalty = seq(0, 1, 0.1))
        }else{
            #do permutations for all components
            tissue.perm <- CCA_permute_components(
            X = matched.mats[[i]]$X[,ordered.transcripts[[i]]], 
            Z = matched.mats[[i]]$Z, filename = perm.file, 
            search_grid = TRUE, nperms = nperms, 
            x_penalty = seq(0, 1, 0.1), z_penalty = seq(0, 1, 0.1),
            verbose = TRUE, plot.results = TRUE)
        }

    }

    perm.results <- get_perm_grid(tissue.perm)
    par(mfrow = c(2,2))
    imageWithText(perm.results$Z, col.scale = "red", main = "Z statistics")
    imageWithText(perm.results$Cor, col.scale = "blue", main = "Correlation")
    imageWithText(-log10(perm.results$p+1e-6), col.scale = "purple", main = "-log10(p)")
    plot(abs(perm.results$Cor), -log10(perm.results$p+1e-6), 
    xlab = "Correlation",ylab = "-log10(p)")

    sig.cor.idx <- which(tissue.perm$pvals < 0.05)

    if(length(sig.cor.idx) > 0){
        best.cor.idx <- which.max(tissue.perm$ft.cors[sig.cor.idx])
        tissue.trait.penalty[[i]] <- c("X" = tissue.perm$penaltyxs[sig.cor.idx[best.cor.idx]], 
        "Y" = tissue.perm$penaltyzs[sig.cor.idx[best.cor.idx]])
    }else{
        tissue.trait.penalty[[i]] = NA
    }
    cat("\n\n")
}
```


## Selected Penalties

The penalties identified for each trait are the following:

```{r final_penalties}
penalty.table <- Reduce("rbind", tissue.trait.penalty)
rownames(penalty.table) <- tissue.names
colnames(penalty.table) <- c("Transcript_Penalty", "Trait_Penalty")
kable(data.frame(penalty.table), format = "html", table.attr = "style='width:30%;'")
```


## CCA on all tissues

We then ran CCA on each tissue transcriptome-trait pair with the optimized 
penalties from above.

```{r run_CCA}
tissue.CCA.results <- vector(mode = "list", length = length(tissue.names))
names(tissue.CCA.results) <- tissue.names

for(i in 1:length(tissue.names)){
    num.components = ncol(matched.mats[[i]]$Z)
    if(length(tissue.trait.penalty[[i]]) > 1){
        CCA.file <- file.path(results.dir, paste0(tissue.names[i], 
        ".", file.text, ".CCA.RDS"))
        if(!file.exists(CCA.file)){
            if(fused.lasso){
                cca.results <- CCA(matched.mats[[i]]$X[,ordered.transcripts[[i]]], 
                matched.mats[[i]]$Z, typex = "ordered", typez = "standard", 
                K = num.components, penaltyx = tissue.trait.penalty[[i]][1], 
                penaltyz = tissue.trait.penalty[[i]][2], chromx = chr.labels[[i]], 
                trace = FALSE)
            }else{
                cca.results <- CCA(matched.mats[[i]]$X, matched.mats[[i]]$Z, 
                typex = "standard", typez = "standard", K = num.components, 
                penaltyx = tissue.trait.penalty[[i]][1], 
                penaltyz = tissue.trait.penalty[[i]][2], trace = FALSE)
            }
            saveRDS(cca.results, CCA.file)
        }else{
            cca.results <- readRDS(CCA.file)
        }
    }else{
        cca.results <- NA
    }
    tissue.CCA.results[[i]] <- cca.results
}
```

## Bootstrap Loadings

The loadings estimated above are from a single run of LASSO-penalized
CCA. Despite correlated traits and transcripts, the loadings on these
variables will not be smooth because of the nature of the LASSO penalty.

We like sparsification because it helps improve interpretability of the
results, but we also do not want to select one of a handful of relevant,
correlated genes because of the nature of LASSO.

To help smooth the loadings, we will use bootstrap aggregation to 
estimate loadings. 

```{r bootstrap_loadings}
boot.trans.file <- file.path(results.dir, "Bootstrapped.Transcript.Loadings.RDS")
boot.trait.file <- file.path(results.dir, "Bootstrapped.Trait.Loadings.RDS")

if(!file.exists(boot.trans.file)){
    n.bootstraps = 100
    tissue.transcript.boots <- tissue.trait.boots <- vector(mode = "list", length = length(tissue.names))
    names(tissue.transcript.boots) <- names(tissue.trait.boots) <- tissue.names

    for(i in 1:length(tissue.names)){
        penalties <- tissue.trait.penalty[[i]]
        all.transcript.loadings <- vector(mode = "list", length = n.bootstraps)
        all.trait.loadings <- vector(mode = "list", length = n.bootstraps)
        for(b in 1:n.bootstraps){
            sample.set <- sample(1:nrow(matched.mats[[i]]$X), replace = TRUE)
            cca.results.train <- CCA(matched.mats[[i]]$X[sample.set,], 
            matched.mats[[i]]$Z[sample.set,], 
            typex = "standard", typez = "standard", K = 20, 
            penaltyx = penalties[1], penaltyz = penalties[2], 
            trace = FALSE)
            all.transcript.loadings[[b]] <- cca.results.train$u
            all.trait.loadings[[b]] <- cca.results.train$v
        }
        tissue.transcript.boots[[i]] <- all.transcript.loadings
        tissue.trait.boots[[i]] <- all.trait.loadings
    }
    saveRDS(tissue.transcript.boots, boot.trans.file)
    saveRDS(tissue.trait.boots, boot.trait.file)
}else{
    tissue.transcript.boots  <- readRDS(boot.trans.file)
    tissue.trait.boots  <- readRDS(boot.trait.file)
}
```

```{r agg_fun}
get_agg_loadings <- function(tissue.boot.results, tissue.results, trait.or.trans = "trans"){

    tissue.loadings <- lapply(1:ncol(tissue.boot.results[[1]]), 
    function(tr) sapply(tissue.boot.results, function(x) x[,tr]))

    #orient all loadings with the original CCA
    if(trait.or.trans == "trans"){
        orig.cca <- tissue.results$u
    }else{
        orig.cca <- tissue.results$v
    }
    cor.loadings <- sapply(1:length(tissue.loadings), function(x) cor(orig.cca[,x], tissue.loadings[[x]][,1]))
    neg.locale <- which(cor.loadings < 0)
    if(length(neg.locale) > 0){
        for(n in neg.locale){
            tissue.loadings[[n]] <- tissue.loadings[[n]] * -1
        }
    }

    oriented.loadings <- vector(mode = "list", length = length(tissue.loadings))
    cor.loadings <- lapply(tissue.loadings, cor)
    for(f in 1:length(cor.loadings)){
        flip.which <- which(cor.loadings[[f]][1,] < 0)
        flipped.loadings <- tissue.loadings[[f]]
        flipped.loadings[,flip.which] <- flipped.loadings[,flip.which] * -1
        oriented.loadings[[f]] <- flipped.loadings
        #pheatmap(cor(flipped.loadings))
    }

    #aggregate over the bootstraps
    tissue.boot.agg <- sapply(oriented.loadings, rowMeans)
    return(tissue.boot.agg)
}
```

```{r aggregate_bootstrapped_loadings}
#create a new CCA results object with the bootstrapped loadings
boot.CCA.results <- tissue.CCA.results
for(i in 1:length(tissue.names)){
    boot.CCA.results[[i]]$u <- get_agg_loadings(tissue.transcript.boots[[i]], tissue.CCA.results[[i]], "trans")
    boot.CCA.results[[i]]$v <- get_agg_loadings(tissue.trait.boots[[i]], tissue.CCA.results[[i]], "trait")
}
```

## Compare Original CCA and Bootsrapped Results {.tabset .tabset-fade .tabset-pills}

### Number of Transcripts {.tabset .tabset-fade .tabset-pills}

The following plots show the number of transcripts with non-zero
loadings for the two methods. Bootstrapping increased the number 
of transcripts represented while still sparsifying.

```{r boot_comp, fig.width = 7, fig.height = 5, results = "asis"}
bar.cols <- c("#b2df8a", "#33a02c", "#a6cee3", "#1f78b4")
tissue.pos.neg <- vector(mode = "list", length = length(tissue.names))
names(tissue.pos.neg) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("####", tissue.names[i], "\n")
    trans.loadings  <- tissue.CCA.results[[i]]$u
    trait.loadings  <- tissue.CCA.results[[i]]$v
    trans.boot  <- boot.CCA.results[[i]]$u
    trait.boot  <- boot.CCA.results[[i]]$v

    num.neg <- apply(trans.loadings, 2, function(x) length(which(x < 0)))
    num.pos <- apply(trans.loadings, 2, function(x) length(which(x > 0)))
    num.neg.boot <- apply(trans.boot, 2, function(x) length(which(x < 0)))
    num.pos.boot <- apply(trans.boot, 2, function(x) length(which(x > 0)))

    #zero.cca <- apply(trans.loadings, 2, function(x) length(which(x == 0)))
    #zero.boot <- apply(trans.boot, 2, function(x) length(which(x == 0)))

    count.mat <- rbind(num.pos, num.neg, num.pos.boot, num.neg.boot)
    tissue.pos.neg[[i]] <- count.mat

    if(is.interactive){quartz(width = 9, height = 5)}
    barplot(count.mat, beside = TRUE,
    names = paste("CT", 1:ncol(trans.loadings)), las = 2, main = tissue.names[i],
    col = bar.cols, ylab = "Number of Transcripts")
    legend("topleft", legend = c("CCA Positive", "CCA Negative", 
    "Boot Positive", "Boot Negative"), fill = bar.cols)
    cat("\n\n")
}

cat("#### Combined Results\n")
plot.grouped.boxes(lapply(tissue.pos.neg, t), type = "matrix")
cat("\n\n")
```

### Canonical Correlations {.tabset .tabset-fade .tabset-pills}

The following plots show the canonical correlations for the original CCA
and the bootstrap-aggregaged CCA. It's a mixed bag. Sometimes the correlation
from the bootstrapping is better and sometimes it's worse. Can we assume
that if the correlation is worse, the original CCA was overfitting?

```{r cancor}
all.cancor <- vector(mode = "list", length = length(tissue.names))
names(all.cancor) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("####", tissue.names[i], "\n")
    cca.var <- get_latent_var(matched.mats[[i]], tissue.CCA.results[[i]])
    boot.var <- get_latent_var(matched.mats[[i]], boot.CCA.results[[i]])

    cancor.mat <- rbind("CCA" = cca.var[[3]], "Boot" = boot.var[[3]])
    barplot(cancor.mat, beside = TRUE, las = 2, 
    names = paste("CT", 1:ncol(trans.loadings)), col = bar.cols[c(1,3)],
    main = tissue.names[i], ylab = "CTrait-CTranscript R2")

    all.cancor[[i]] <- cancor.mat
    cat("\n\n")
}

cat("#### Combined Results\n")

all.cca.cancor <- sapply(all.cancor, function(x) x[1,])
all.boot.cancor <- sapply(all.cancor, function(x) x[2,])

tissue.cols <- c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3")
pt.col <- sapply(1:ncol(all.cca.cancor), function(x) rep(tissue.cols[x], nrow(all.cca.cancor)))
plot(unlist(all.cca.cancor), unlist(all.boot.cancor), col = unlist(pt.col), pch = 16,
xlab = "CCA Canonical Correlation", ylab = "Bootstrapped Canonical Correlation")
legend("topleft", legend = colnames(all.cca.cancor), pch = 16, col = pt.col[1,])
abline(0,1)
cat("\n\n")
```

### Comparison of Trait Loadings {.tabset .tabset-fade .tabset-pills}

```{r trait_comp, fig.height = 5, fig.width = 9}
for(i in 1:length(tissue.names)){
    cat("####", tissue.names[i], "\n")
    cca.traits <- tissue.CCA.results[[i]]$v
    boot.traits <- boot.CCA.results[[i]]$v

    rownames(cca.traits) <- rownames(boot.traits) <- colnames(matched.mats[[i]]$Z)
    colnames(cca.traits) <- colnames(boot.traits) <- paste0("CT", 1:ncol(cca.traits))

    if(is.interactive){quartz(width = 9, height = 5)}
    box.groups <- list("CCA" = cca.traits, "Boot" = boot.traits)
    plot.grouped.boxes(lapply(box.groups, function(x) t(abs(x))), type = "matrix", 
    main = tissue.names[i], label.srt = 90, print.vals = NA)
    cat("\n\n")
}

```

For the remainder of the analysis, we focus on the bootstrap-aggregated
results.

## Transcripts and Traits by Tissue {.tabset .tabset-fade .tabset-pills}

The following plot summarize information from the results for 
each tissue. 

The first heatmap shows the loadings of each raw trait
on each composite trait. They are quite different between the tissues.

The boxplot shows summaries for the contributions of each trait
to get an overall idea of which traits contributed.

The barplot shows how many transcripts had non-zero loadings on each 
composite trait. The negative and positive loadings are shown separately.

The next two heatmaps shows the correlation matrix between transcript
loading patterns for the traits, and the jaccard index matrix for the
transcripts assigned to each trait respectively.
 
```{r transcript_num, fig.width = 7, fig.height = 6}

describe_results <- function(tissue.mats, tissue.results, filename = NULL){
    
    if(!is.null(filename)){pdf(filename)}

    if(is.null(tissue.results)){
        plot.text("No involvement in this tissue.")
    }else{

        trait.loadings <- tissue.results$v
        trait.description <- get_trait_description(tissue.mats, tissue.results, 
        short_version = TRUE)
        
        print("Trait Contributions to Composite Trait")
        rownames(trait.loadings) <- colnames(tissue.mats$Z)
        colnames(trait.loadings) <- trait.description
        pheatmap(t(trait.loadings), cluster_rows = FALSE, cluster_cols = FALSE)

        print("Trait Contributions Clustered")
        pheatmap(trait.loadings)

        par(mar = c(10, 4, 4, 4))
        boxplot(t(trait.loadings), las = 2, 
        main = "Summary of Trait Contributions Across All Composite Traits")
        trait.list <- lapply(1:nrow(trait.loadings), function(x) trait.loadings[x,])
        names(trait.list) <- trait.description
        stripchart(trait.list, vertical = TRUE, method = "jitter", pch = 16, las = 2,
        add = TRUE)

        trait.specific <- which(apply(tissue.results$u, 1, function(x) length(which(x != 0))) == 1)
        pos.trans <- apply(tissue.results$u, 2, function(x) length(which(x > 0)))
        neg.trans <- apply(tissue.results$u, 2, function(x) length(which(x < 0)))
        
        cols <- brewer.pal(8, "Accent")
        par(mar = c(4,8, 4, 4))
        barplot(t(cbind(pos.trans, neg.trans)), beside = TRUE, 
        names = trait.description, las = 2, cex.names = 0.8, 
        col = cols[1:2], main = "Number of Transcripts Associated with Each Composite Trait")
        legend("topleft", c("Positive", "Negative"), fill = cols[1:2])

        num.traits  <- apply(tissue.results$u, 1, function(x) length(which(x != 0)))
        num.totals <- table(num.traits)
        #num.totals <- c(num.totals, sum(num.totals[2:length(num.totals)]))
        #names(num.totals)[length(num.totals)] <- "Total"
        a <- barplot(num.totals, ylim = c(0, max(num.totals)*1.1),
        main = "Number of Transcripts Associated with Different Numbers of Traits")
        text(a[,1], (num.totals+(max(num.totals)*0.02)), labels = num.totals)

        #This plot shows how similar the composite transcripts are
        print("Heatmap of correlations between transcript loadings for pairs of traits")
        has.loading <- which(rowSums(tissue.results$u) != 0)
        effect.mat <- tissue.results$u[has.loading,]
        cor.effect <- cor(effect.mat)
        rownames(cor.effect) <- colnames(cor.effect) <- gsub("Trait", "Transcript", trait.description)
        diag(cor.effect) <- 0
        if(length(unique(cor.effect[upper.tri(cor.effect, diag = FALSE)])) > 1){
            pheatmap(cor.effect)
        }else{
            print("Too few correlations to show.")
        }

        trans.list <- apply(tissue.results$u, 2, function(x) colnames(tissue.mats$X)[which(x != 0)])
        names(trans.list) <- gsub("Trait", "Transcript", trait.description)
        
        #print("Heatmap of Jaccard indices for non-zero transcripts across pairs of traits")
        #jacc.mat <- jaccard.matrix(trans.list)
        #diag(jacc.mat) <- NA
        #pheatmap(jacc.mat)

        trait.by.transcript <- trait.loadings %*% t(effect.mat)
        #take out traits without contributions from transcripts
        has.transcript <- which(colSums(t(trait.by.transcript)) > 0)
        trait.transcript.cor <- cor(t(trait.by.transcript[has.transcript,]))
        diag(trait.transcript.cor) <- 0
        #pheatmap(trait.transcript.cor)
        trait_graph <- graph_from_adjacency_matrix(trait.transcript.cor, 
        weighted = TRUE, mode = "undirected")
        edge_sign <- sign(E(trait_graph)$weight)
        edge_weight <- E(trait_graph)$weight
        E(trait_graph)$weight <- abs(edge_weight)
        if(length(unique(E(trait_graph)$weight)) > 2){
            e.col <- colors.from.values(edge_weight, use.pheatmap.colors = TRUE)
        }else{
            e.col = "gray"
        }
        plot(trait_graph, edge.color = e.col, layout = layout_nicely, 
        main = "Trait Relatedness By Associated Transcripts", 
        edge.width = E(trait_graph)$weight*3)
    }
    if(!is.null(filename)){dev.off()}
}
```

```{r plot_agg, results = "asis"}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(is.interactive){
        filename = file.path(results.dir, paste0("Boot.Results.", tissue.names[i], ".pdf"))
        }else{
        filename = NULL
        }
    describe_results(matched.mats[[i]], boot.CCA.results[[i]], filename = filename)
    cat("\n\n")
}
```


## Transcript Group Enrichment {.tabset .tabset-fade .tabset-pills}

We then looked for functional enrichment associated with each set of genes.
We sorted each by the magnitude of its association with the trait, and used
an ordered query in gprofiler.

```{r enrichment_fun}

get_transcript_list <- function(tissue.mats, tissue.results, percentile = 50){
    if(length(tissue.results) == 1){
        return(NA)
    }
    trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.up.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] > 0))
    trait.down.transcripts <- lapply(1:ncol(tissue.mats$Z), function(x) which(tissue.results$u[,x] < 0))
    names(trait.up.transcripts) <- names(trait.down.transcripts) <- trait.description
    #cbind(trait.description, sapply(trait.up.transcripts, length), sapply(trait.down.transcripts, length))
    tissue.nets <- vector(mode = "list", length = length(trait.up.transcripts))
    for(tr in 1:length(trait.up.transcripts)){
        trait.up.genes <- colnames(tissue.mats$X)[trait.up.transcripts[[tr]]]
        trait.up.vals <- tissue.results$u[trait.up.transcripts[[tr]],tr]
        top.perc <- get.percentile(trait.up.vals, percentile)
        top.genes <- which(trait.up.vals >= top.perc)
        trait.up.vals <- trait.up.vals[top.genes]
        names(trait.up.vals) <- trait.up.genes[top.genes]

        trait.down.genes <- colnames(tissue.mats$X)[trait.down.transcripts[[tr]]]
        trait.down.vals <- tissue.results$u[trait.down.transcripts[[tr]],tr]
        bot.perc <- get.percentile(abs(trait.down.vals), percentile)
        bot.genes <- which(trait.down.vals <= bot.perc*-1)
        trait.down.vals <- trait.down.vals[bot.genes]
        names(trait.down.vals) <- trait.down.genes[bot.genes]
        trait.gene.groups <- list(sort(trait.up.vals, decreasing = TRUE), 
        sort(trait.down.vals, decreasing = FALSE))
        names(trait.gene.groups) <- paste0("Transcript", tr, c("_up", "_down"))
        tissue.nets[[tr]] <- trait.gene.groups
    }

    tissue.genes <- unlist(tissue.nets, recursive = FALSE)
    return(tissue.genes)
}

gprofiler_enrichment <- function(tissue.gene.list, ordered_query = FALSE, filename){
    if(!file.exists(filename)){
        tissue.enrich <- lapply(tissue.gene.list, 
        function(x) if(length(x) >= 5){gost(names(x), 
        organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME"), 
        ordered_query = ordered_query, evcodes = TRUE)}else{NULL})
        saveRDS(tissue.enrich, filename)
    }else{
        tissue.enrich <- readRDS(filename)
    }
    result <- list("Tissue_Transcripts" = tissue.gene.list, "Enrichments" = tissue.enrich)
    return(result)
}

get_enrichment_plus <- function(tissue.mats, tissue.results, ct){
    gene.vals <- tissue.results$u[,ct]
    neg.idx <- which(gene.vals < 0)
    pos.idx <- which(gene.vals > 0)
    neg.order <- order(gene.vals[neg.idx])
    pos.order <- order(gene.vals[pos.idx], decreasing = TRUE)
    ordered.pos <- colnames(tissue.mats$X)[pos.idx[pos.order]]
    ordered.neg <- colnames(tissue.mats$X)[neg.idx[neg.order]]
    #plot(gene.vals[pos.idx[pos.order]])
    #plot(gene.vals[neg.idx[neg.order]])
    pos.enrich <- gost(ordered.pos, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    #plot.enrichment(pos.enrich, max.term.size = 2000)
    neg.enrich <- gost(ordered.neg, organism = "mmusculus",
    sources = c("GO", "KEGG", "REACTOME"), ordered_query = TRUE,
    evcodes = TRUE)
    result <- list("positive_enrichment" = pos.enrich, 
    "negative_enrichment" = neg.enrich)
    return(result)
}

enrichment_plus_genes <- function(enrichment.plus, search.terms){
    results.table <- enrichment.plus$result
    term.position <- unique(unlist(lapply(search.terms, function(x) grep(x, results.table[,"term_name"], ignore.case = TRUE))))
    if(length(term.position) > 0){
        sub.results <- results.table[term.position,]
    }else{
        sub.results <- "Terms not found"
    }
    return(sub.results)
}
```


```{r tissue_enrich}
tissue.enrich <- vector(mode = "list", length = length(tissue.names))
names(tissue.enrich) <- tissue.names
for(i in 1:length(tissue.names)){
    #get lists of non-zero transcripts
    #and sort by magnitude of loading
    tissue.gene.list <- get_transcript_list(tissue.mats = matched.mats[[i]], 
    tissue.results = boot.CCA.results[[i]], percentile = 90)
    tissue.enrich[[i]] <- gprofiler_enrichment(tissue.gene.list, ordered_query = TRUE,
    filename = file.path(results.dir, 
    paste0(tissue.names[i], ".Composite.Transcript.Enrichments.RDS")))
}
```

The following figures show the functional enrichments for the 
transcripts with positive and negative loadings on each trait 
for each tissue.

We present this in several different types of figures.

For each trait we show a table of the significant enrichments for the 
transcripts with positive loadings and the transcripts with negative 
loadings side by side.

We then combined these into one heatmap plot to show all the traits 
and their enrichments together.

Finally, we took the top 10 enriched terms from each trait, and constructed
a bipartite graph between traits and enriched terms. We projected this network
onto the traits and the terms. Rather amazingly, the terms for each tissue
cluster into beautiful functional clusters

```{r plot_enrichment}
plot_tissue_enrich <- function(tissue.mats, tissue.results, enrichment.results, 
max.term.size = 2000, num.terms = 30){
    if(length(tissue.results) == 1){
        plot.text("No involvement of this tissue.")
        return(NULL)
    }
    #trait.description <- get_trait_description(tissue.mats, tissue.results, short_version = TRUE)
    trait.description <- paste0("Composite_Transcript", 1:ncol(tissue.mats$Z))
    tissue.enrich <- enrichment.results[[2]]
    idx <- 1
    for(i in 1:length(trait.description)){
        cat("####", trait.description[i], "\n")
        #quartz(width = 12, height = 7)
        par(mfrow = c(1,2))
        for(dir in 1:2){
            plot.enrichment(tissue.enrich[[idx]], num.terms = num.terms, 
            plot.label = names(tissue.enrich)[idx], 
            max.term.size = max.term.size, text.size = 0.8)
            idx = idx + 1
        }
        mtext(trait.description[i], outer = TRUE, side = 3, line = -2.5)
        cat("\n\n")
    }
cat("\n\n")
}


#This function covers specified nodes in a network with
#white boxes, similar to how we would in Keynote to erase
#something.
cover_nodes <- function(bip.net, label.term = "Transcript", 
search.name = c("partial", "full"), rad = 0.1, border.col = "white",
fill.col = "white"){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        circ.coord <- get_circle(rad, center_x = mid.x, center_y = mid.y, dens = 0.05)
        polygon(circ.coord$x, circ.coord$y, col = fill.col, border = border.col)
    }
}

add_picture_nodes <- function(bip.net, val.mat, label.term = "Transcript", 
search.name = c("partial", "full"), rect.width = 0.1, rect.height = 0.1, lwd = 0.5){
    
    net.layout <- layout_with_kk(bip.net)
    new.x <- scale.between.vals(net.layout[,1], -1, 1)
    new.y <- scale.between.vals(net.layout[,2], -1, 1)

    search.name = search.name[1]
    if(search.name == "full"){
        trait.idx <- sapply(label.term, function(x) which(V(bip.net)$name == x))
    }else{
        trait.idx <- sapply(label.term, function(x) grep(x, V(bip.net)$name))
    }
        
    cover.coord  <- cbind(new.x, new.y)[trait.idx,]
    for(i in 1:nrow(cover.coord)){
        mid.x <- cover.coord[i,1]
        mid.y <- cover.coord[i,2]
        min.x <- mid.x - (rect.width/2)
        max.x <- mid.x + (rect.width/2)
        min.y <- mid.y - (rect.height/2)
        max.y <- mid.y + (rect.height/2)
        
        x.pts <- scale.between.vals(1:nrow(val.mat), min.x, max.x)
        y.vals <- scale.between.vals(val.mat[,i], min.y, max.y)
        pt.col <- colors.from.values(val.mat[,i], use.pheatmap.colors = TRUE,
        global.color.scale = TRUE, global.min = min(val.mat), global.max = max(val.mat))
        #barplot(val.mat[,i], col = pt.col, las = 2)
        #barplot(1:length(pt.col), col = pt.col)
        #plot.new()
        #plot.window(xlim = c(min.x, max.x), ylim = c(min.y, max.y))
        segments(x0 = x.pts, y0 = min.y, y1 = max.y, col = pt.col, lwd = lwd)
    }
}

#This function plots a bipartite network and replaces the transcript
#nodes with pictures of the effects of that transcript on the traits.
#Because the up and down transcript effects are separated, we multiply
#the down-transcripts by -1 to reverse the trait effects. 

plot_decorated_bip <- function(tissue.bip, tissue.mats, tissue.results, 
cluster.assig, filename, fig.width = 20, fig.height = 20){
    
    pdf(filename, width = fig.width, height = fig.height)
    on.exit(dev.off())
    if(is.null(tissue.bip)){
        plot.text("No Bipartite Graph to Show")
        return(NULL)
    }

    trait.loadings <- tissue.results$v
    rownames(trait.loadings) <- colnames(tissue.mats$Z)
    colnames(trait.loadings) <- paste("Composite_Trait", 1:ncol(trait.loadings))
    #pheatmap(trait.loadings)
    exp.trait.mat <- Reduce("cbind", lapply(1:nrow(trait.loadings), 
    function(x) cbind(trait.loadings[,x,drop=FALSE], trait.loadings[,x,drop=FALSE]*-1)))
    trait.clust <- hclust(dist(exp.trait.mat))
    #plot(trait.clust)
    trait.order <- trait.clust$order
    pheatmap(t(exp.trait.mat[trait.order,seq(1,ncol(exp.trait.mat), 2)]), cex = 2)

    go.cluster.color <- rep("lightgray", vcount(tissue.bip))
    if(length(cluster.assig) > 0){
        not.na <- which(!is.na(cluster.assig))
        go.cluster.color[not.na] <- cluster.assig[not.na]
    }
    plot(tissue.bip, vertex.size = 5, layout = layout_with_kk,
    vertex.label.dist = 0.7, vertex.label.adj = 1, vertex.color = go.cluster.color)
    cover_nodes(tissue.bip, label.term = "Transcript", 
    search.name = c("partial", "full"), rad = 0.03)
    add_picture_nodes(tissue.bip, exp.trait.mat[trait.order,], 
    label.term = "Transcript", search.name = "partial", rect.width = 0.06, 
    rect.height = 0.04, lwd = 2)

    par(xpd = TRUE)
    text.x <- segment.region(-1, -0.5, nrow(exp.trait.mat))
    text.y <- rep(-0.9, nrow(exp.trait.mat))
    text(text.x, text.y, rownames(exp.trait.mat)[trait.order], srt = 270, adj = 1)
    text(x = -0.75, y = -0.95, "Trait Order in Figure")
    par(xpd = FALSE)
}
```




## Individual Composite Trait Enrichments {.tabset .tabset-fade .tabset-pills}

```{r plot_enrich, results = "asis", fig.width = 12, fig.height = 10}
max.term.size = 2000
num.terms = 10
p_val_thresh = 1e-3

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    plot_tissue_enrich(tissue.mats = matched.mats[[i]], 
    tissue.results = boot.CCA.results[[i]], 
    enrichment.results = tissue.enrich[[i]], 
    max.term.size = max.term.size, num.terms = num.terms)
    cat("\n\n")
}
```


## Composite Trait Enrichment Heatmaps {.tabset .tabset-fade .tabset-pills}

```{r all_enrichment_heatmaps, fig.height = 15, fig.width = 7, results = "asis"}

enrich.mats <- vector(mode = "list", length = length(tissue.names))
names(enrich.mats) <- tissue.names
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(is.interactive){pdf(file.path(results.dir, paste0("Enrichment.mat.", 
    tissue.names[i], ".pdf")), height = 40, width = 9)}
    if(length(tissue.enrich[[i]]) > 1 && sum(sapply(tissue.enrich[[i]][[2]], length)) > 0){
        enrich.mats[[i]] <- plot.enrichment.group(enrichment.list = tissue.enrich[[i]][[2]], 
        n.terms = num.terms, max.term.size = max.term.size, transformation = sqrt,
        pval.thresh = p_val_thresh)
    }else{
        plot.text("No Enrichment")
    }
    if(is.interactive){dev.off()}
    cat("\n\n")
}
#dev.off()
```

## Simplified Enrichment
Attempting to simplify GO term enrichments using the R package 
simplifyEnrichment.

```{r simpEnrich, echo = FALSE}

go.domains <- c("BP")
cluster.col <- brewer.pal(12, "Paired")
#go.domains = c("BP", "MF", "CC")
#make an object to hold enrichment summaries
go.summaries <- go.groupings <- vector(mode = "list", length = length(tissue.names))
names(go.summaries) <- names(go.groupings) <- tissue.names
for(i in 1:length(tissue.names)){

    all.trans.enrich <- tissue.enrich[[i]]$Enrichments
    #threshold by specified p value
    
    thresh.enrich <- lapply(all.trans.enrich, function(x) x$result[which(x$result[,"p_value"] <= p_val_thresh),]) 
    all.enrich.terms <- lapply(thresh.enrich, function(x) x[grep("GO:BP", x[,"source"]),"term_id"])
    u_terms <- Reduce("union", all.enrich.terms)    

    pdf(file.path(results.dir, paste0("Enrichment_Simplified_", tissue.names[i], ".pdf")), width = 11, height = 7)
    #mf.mat = GO_similarity(u_terms, ont = "MF", db = "org.Mm.eg.db")
    #cc.mat = GO_similarity(u_terms, ont = "CC", db = "org.Mm.eg.db")
    bp.mat = GO_similarity(u_terms, ont = "BP", db = "org.Mm.eg.db")
    #mf.df = simplifyGO(mf.mat)
    #cc.df <- simplifyGO(cc.mat)
    bp.df <- simplifyGO(bp.mat)
    dev.off()

    #keep the assignments for each GO term
    go.groupings[[i]] <- bp.df

    #look through the composite transcripts and make a matrix
    #to specify the cluster membership of each transcript
    c.table <- table(bp.df[,"cluster"])
    big.c <- c.table[which(c.table >= 5)]
    mem.mat <- matrix(0, nrow = length(big.c), ncol = length(all.trans.enrich))
    colnames(mem.mat) <- names(all.trans.enrich)
    cl.names <- rep(NA, length(big.c))
    for(cl in 1:length(big.c)){
        cl.locale <- which(bp.df[,"cluster"] == names(big.c)[cl])
        cl.terms <- bp.df[cl.locale,]

        #name the cluster
        sorted.cl <- sort(table(unlist(strsplit(cl.terms[,"term"], " "))), decreasing = TRUE)
        cl.names[cl] <- paste(names(head(sorted.cl, 10)), collapse = "_")
        
        #calculate the 
        cl.idx <- lapply(all.trans.enrich, function(x) which(x$result[,"term_id"] %in% cl.terms[,1]))
        cl.nlp <- lapply(1:length(cl.idx), 
            function(x) if(length(cl.idx[[x]]) > 0){-log10(all.trans.enrich[[x]]$result[cl.idx[[x]],"p_value"])}else{0})
        names(cl.nlp) <- names(cl.idx)
        mean.nlp <- sapply(cl.nlp, mean)
        cl.p.locale <- match(names(mean.nlp), colnames(mem.mat))
        mem.mat[cl,cl.p.locale] <- mean.nlp
    }

    rownames(mem.mat) <- cl.names
    pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
    tissue.names[i], "_Transcript_Clusters.pdf")), width = 20, height = 7)
    pheatmap(mem.mat, cluster_rows = FALSE, cluster_cols = FALSE)
    dev.off()
    go.summaries[[i]] <- mem.mat

    #make a matrix of p values for each transcript and each
    #GO term. Sort by cluster and plot.
    term.mat <- matrix(0, nrow = nrow(bp.mat), ncol = length(all.trans.enrich))
    colnames(term.mat) <- names(all.trans.enrich)
    rownames(term.mat) <- colnames(bp.mat)
    for(tr in 1:length(all.trans.enrich)){
        trans.go <- all.trans.enrich[[tr]]$result[,"term_id"]
        if(length(trans.go) > 0){
            trans.p <- all.trans.enrich[[tr]]$result[,"p_value"]
            common.terms <- intersect(colnames(bp.mat), trans.go)
            common.table.locale <- match(common.terms, trans.go)
            common.mat.locale <- match(common.terms, rownames(bp.mat))
            term.mat[common.mat.locale,tr] <- -log10(trans.p[common.table.locale])
        }
    }
    #put the term matrix in order of big clusters
    #put all the small clusters at the end
    cl.list <- cl.df <- vector(mode = "list", length = length(big.c)+1)
     for(cl in 1:length(big.c)){
        cl.go <- bp.df[which(bp.df[,3] == names(big.c)[cl]),1]
        cl.list[[cl]] <- match(cl.go, rownames(term.mat))
        cl.df[[cl]] <- rep(cl, length(cl.go))
    }
    cl = cl + 1
    misc.clust <- setdiff(1:nrow(term.mat), unlist(cl.list))
    cl.go <- rownames(term.mat)[misc.clust]
    cl.list[[cl]] <- match(cl.go, rownames(term.mat))
    cl.df[[cl]] <- rep(cl, length(cl.go))

    cl.order <- unlist(cl.list)
    cluster <- data.frame(as.factor(unlist(cl.df)))
    rownames(cluster) <- rownames(term.mat)[cl.order]

    pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
    tissue.names[i], "_Transcript_Membership.pdf")), width = 7, height = 7)    
    par(mar = c(6, 20, 2, 2))
    imageWithText(term.mat[cl.order,], use.pheatmap.colors = TRUE, show.text = FALSE,
    row.names = NULL, col.text.cex = 0.5)
    #draw boxes around clusters
    top.y <- nrow(term.mat)
    min.x <- 0
    max.x <- ncol(term.mat)+1
    key.width <- (max.x - min.x)/20
    for(cl in 1:length(cl.list)){
        bottom.y <- top.y - length(cl.list[[cl]])
        draw.rectangle(min.x, max.x, top.y, bottom.y, border.col = "white", fill = NA)
        draw.rectangle(min.x-key.width, min.x, top.y, bottom.y, 
        border.col = "white", fill = cluster.col[(cl%%length(cluster.col)+1)])
        if(cl < length(cl.list)){cl.label = cl.names[cl]}else{cl.label = "Other"}
        text(x = min.x - (1.5*key.width), y = mean(c(top.y, bottom.y)), 
        labels = cl.label, cex = 0.5, adj = 1)
        top.y <- bottom.y
    }
    dev.off()

    plot.network = FALSE
    if(plot.network){
        pdf(file.path(results.dir, paste0("Enrichment_Simplified_", 
        tissue.names[i], "_Network.pdf")), width = 10, height = 10)    
        in.big.cl <- bp.df[which(bp.df[,3] %in% names(big.c)),]
        big.go <- in.big.cl[,1]
        go.adj <- bp.mat[match(big.go, rownames(bp.mat)), match(big.go, colnames(bp.mat))]
        diag(go.adj) <- 0
        #hist(go.adj^4, breaks = 100)
        go.adj[which(go.adj^1 < 0.05)] <- 0
        go.net <- graph_from_adjacency_matrix(go.adj, weighted = TRUE, mode = "undirected")
        V(go.net)$name = in.big.cl[,2]
        go.deg <- degree(go.net)
        to.remove <- which(go.deg == 0)
        to.keep <- setdiff(1:length(go.deg), to.remove)
        if(length(to.remove) > 0){
            go.net <- delete_vertices(go.net, to.remove)
        }
        e.col <- colors.from.values(E(go.net)$weight, use.pheatmap.colors = TRUE)

        mods <- mod.col <- in.big.cl[to.keep,3]
        u_mods <- unique(mods)
        for(m in 1:length(u_mods)){mod.col[which(mods == u_mods[m])] <- cluster.col[m+1]}
        plot(go.net, layout = layout_nicely, vertex.color = mod.col, 
        vertex.size = 5, vertex.label = NA, edge.width = E(go.net)$weight,
        edge.color = e.col)
        dev.off()
    }
}
```

## Traits and Terms Networks

Here we visualize the enrichments in a different way. We want to see
how the traits and terms are associated with processes. The following
code plots networks to pdfs with the prefix Bip. These figures show
the trait contributions to each composite trait as well as a large 
network that shows how the composite transcripts relate to the original
traits as well as to biological processes. The nodes representing 
GO term enrichments are 

```{r trait_term}
#I'm having trouble with pheatmap devices staying open 
#and making unfinished pdfs. This code is here and at 
#the bottom of the loop to make sure we close pdfs
#from this and previous runs.
any.open <- dev.list()
while(length(any.open) > 0){
    dev.off()
    any.open <- dev.list()
}

enrich.bips <- vector(mode = "list", length = length(tissue.names))
names(enrich.bips) <- tissue.names

for(i in 1:length(tissue.names)){

    if(class(enrich.mats[[i]])[1] == "matrix"){
        enrich.bips[[i]] <- enrich_bipartite_proj(enrich.mat = enrich.mats[[i]], 
        vertex.col = "gray", label.vertex = NULL, label.col = "lightblue", 
        search.name = "partial")
    
        plot_decorated_bip(tissue.bip = enrich.bips[[i]]$Network, 
        tissue.mats = matched.mats[[i]], tissue.results = boot.CCA.results[[i]], 
        cluster.assig = V(enrich.bips[[i]]$Projection[[1]])$go_cluster,
        file.path(results.dir, paste0("Bip_", tissue.names[i], ".", file.text, ".pdf")),
        fig.width = 30, fig.height = 30)
    }
}

any.open <- dev.list()
while(length(any.open) > 0){
    dev.off()
    any.open <- dev.list()
}

```




## QTL mapping composite transcripts {.tabset .tabset-fade .tabset-pills}

We used qtl2 to map each of the composite traits and 
each of the composite transcripts.

```{r map_transcripts, results = "asis", fig.height = 7, fig.width = 7}
qtl.results <- vector(mode = "list", length = length(tissue.names))
names(qtl.results) <- tissue.names

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(boot.CCA.results[[i]]) > 1){

        trait.trans <- get_latent_var(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]])

        pheno.trans.cor <- sapply(1:ncol(trait.trans$Composite_Transcripts), 
        function(x) apply(matched.mats[[i]]$Z, 2, 
        function(y) cor(trait.trans$Composite_Transcripts[,x], y)))
        
        colnames(pheno.trans.cor) <- colnames(trait.trans$Composite_Transcripts)
        
        pheatmap(pheno.trans.cor, main = "Correlations Between Composite 
        Transcripts and Physiological Traits")

        pheno.trait.cor <- sapply(1:ncol(trait.trans$Composite_Traits), 
        function(x) apply(matched.mats[[i]]$Z, 2, function(y) cor(trait.trans$Composite_Traits[,x], y)))
        colnames(pheno.trait.cor) <- colnames(trait.trans$Latent_Traits)
        pheatmap(pheno.trait.cor, main = "Correlations Between Composite 
        Traits and Physiological Traits")

        qtl.file <- file.path(results.dir, paste0("QTL.", tissue.names[i], ".", file.text, ".RDS"))
        if(!file.exists(qtl.file)){
            tissue.ctranscript.qtl <- scan1(genoprobs, trait.trans$Composite_Transcripts)
            tissue.ctrait.qtl <- scan1(genoprobs, trait.trans$Composite_Traits)
            tissue.qtl <- list("CTranscript_QTL" = tissue.ctranscript.qtl, 
            "CTrait_QTL" = tissue.ctrait.qtl)
            qtl.results[[i]] <- tissue.qtl
            saveRDS(tissue.qtl, qtl.file)
        }else{
            qtl.results[[i]] <- readRDS(qtl.file)
        }

        for(j in 1:ncol(qtl.results[[i]][[1]])){
            if(j == 1){cat("\n\n")}
            cat("#### Composite Transcript", j, "\n")
            if(is.interactive){quartz(width = 8, height = 8)}
            par(mfrow = c(2,1))
            plot(qtl.results[[i]][[1]], j, map = map, main = paste("Composite Transcript", j))
            plot(qtl.results[[i]][[2]], j, map = map, main = paste("Composite Trait", j))
            cat("\n\n")
        } 

    }
cat("\n\n")
}
```


## Composite Transcript LOD Score Heatmaps {.tabset .tabset-fade .tabset-pills}

The following figures show heatmaps comparing the LOD score 
traces of the composite transcripts and composite traits.

I'm still working on getting something for this...

```{r lodheat, fig.width = 11, fig.height = 6, results = "asis", eval = FALSE}
chr.table <- matrix(NA, ncol = 2, nrow = length(map))
start.pos = 1
for(i in 1:length(map)){
    chr.table[i,1] <- start.pos
    chr.table[i,2] <- start.pos + length(map[[i]]) - 1
    start.pos <- start.pos + length(map[[i]])
}

for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(qtl.results[[i]][[1]]) > 0){
        if(is.interactive){quartz(width = 10, height = 5)}
        
        trait.trans.qtl <- lapply(qtl.results[[i]], t)
        for(j in 1:nrow(trait.trans.qtl[[1]])){
            cat("#### CT", j, "\n")
            if(is.interactive){quartz(width = 11, height = 6)}
            one.comp <- cbind(qtl.results[[i]][[1]][,j], qtl.results[[i]][[2]][,j])

            par(mfrow = c(2,1))
            par(mar = c(0,2,2,2))
            ylim <- c(0, max(one.comp))
            plot(one.comp[,1], type = "h", axes = FALSE, ylim = ylim, xlab = "", 
            cex = 0.7, main = paste("Composite Trait and Transcript", j))
            abline(v = chr.table[,2], col = "gray")
            abline(h = 6, col = "gray", lty = 2)
            mtext(side = 4, text = paste("Composite Transcript", j), line = -1.5)
            axis(2)
            
            par(mar = c(4,2,0,2))
            plot(one.comp[,2], type = "h", ylim = ylim, axes = FALSE, xlab = "",
            cex = 0.7)
            abline(v = chr.table[,2], col = "gray")
            abline(h = 6, col = "gray", lty = 2)
            mtext(side = 4, text = paste("Composite Trait", j), line = -1.5)
            axis(2)

            par(xpd = TRUE)
            text(y = rep(-0.5, nrow(chr.table)), x = rowMeans(chr.table), 
            labels = 1:nrow(chr.table))
            par(xpd = FALSE)
            cat("\n\n")
        }    
    }
    cat("\n\n")
}

```


```{r all_lod, eval = FALSE}
all.qtl.names <- unlist(lapply(1:length(tissue.names), function(x) paste0(tissue.names[x], colnames(qtl.results[[x]][[1]]))))
all.qtl.transcripts <- Reduce("cbind", lapply(qtl.results, function(x) x[[1]]))
all.qtl.traits <- Reduce("cbind", lapply(qtl.results, function(x) x[[2]]))
colnames(all.qtl.transcripts) <- colnames(all.qtl.traits) <- all.qtl.names
rownames(all.qtl.transcripts) <- rownames(all.qtl.traits) <- rownames(qtl.results[[1]][[1]])

lodmax = 9
all.qtl.transcripts[which(all.qtl.transcripts > lodmax)] <- lodmax
all.qtl.traits[which(all.qtl.traits > lodmax)] <- lodmax

pdf(file.path(results.dir, "all_qtl.transcripts.pdf"), width = 12, height = 8)
multilod.plot(all.qtl.transcripts, map, lod.thresh = 4, chr.label.y = 0, 
        chr.label.cex = 1, row.names = colnames(all.qtl.transcripts), 
        row.name.shift = -800)
dev.off()

pdf(file.path(results.dir, "all_qtl.traits.pdf"), width = 12, height = 8)
multilod.plot(all.qtl.traits, map, lod.thresh = 4, chr.label.y = 0, 
        chr.label.cex = 1, row.names = colnames(all.qtl.traits), 
        row.name.shift = -800)
dev.off()
```

## Allele Coefficients for Matched QTL {.tabset .tabset-fade .tabset-pills}

We are most interested in trait-transcript pairs that have shared QTL.
Here we go through each pair and identify overlapping peaks above
a given threshold. We then plot the allele effects of the two to see
if they match.

```{r allele_plots}
lodthresh = 5
peak.dist <- 10 #maximum distance in MB for overlapping QTL
shared.peaks <- vector(mode = "list", length = length(tissue.names))
names(shared.peaks) <- tissue.names

for(i in 1:length(tissue.names)){
    
    if(length(qtl.results[[i]][[1]]) > 0){
        shared.tissue.peaks <- NULL

        transcript.peak.table <- find_peaks(qtl.results[[i]][[1]], 
        map = map, threshold = lodthresh, prob = 0.95)
        trait.peak.table <- find_peaks(qtl.results[[i]][[2]], 
        map = map, threshold = lodthresh, drop = 0.95)

        shared.traits <- intersect(transcript.peak.table[,"lodindex"], trait.peak.table[,"lodindex"])
        
        for(tr in 1:length(shared.traits)){
            tr.trait <- transcript.peak.table[which(transcript.peak.table[,"lodindex"] == shared.traits[tr]),]
            tr.transcript <- trait.peak.table[which(trait.peak.table[,"lodindex"] == shared.traits[tr]),]
            tr.pairs <- cbind(rep(1:nrow(tr.trait), nrow(tr.transcript)), rep(1:nrow(tr.transcript), each = nrow(tr.trait)))
            for(p in 1:nrow(tr.pairs)){
                trait.pair <- tr.pairs[p,1]
                trans.pair <- tr.pairs[p,2]
                if(tr.trait[trait.pair,"chr"] == tr.transcript[trans.pair,"chr"]){
                    peak1.mb <- tr.trait[trait.pair,"pos"]
                    peak2.mb <- tr.transcript[trans.pair,"pos"]
                    peaks.overlap <- (abs(peak1.mb - peak2.mb) <= peak.dist)
                    if(peaks.overlap){
                        shared.info <- matrix(c(unlist(tr.transcript[trans.pair,]), 
                        unlist(tr.trait[trait.pair,])), nrow = 1)
                        shared.tissue.peaks <- rbind(shared.tissue.peaks, shared.info)
                    }
                }
            }
        shared.peaks[[i]] <- shared.tissue.peaks
        }
    }
}
```


```{r plot_shared, results = "asis", fig.height = 9, fig.width = 11}
for(i in 1:length(tissue.names)){
    if(is.interactive){pdf(file.path(results.dir, 
    paste0("Overlapping.Peaks.", tissue.names[i], ".pdf")), width = 11, height = 6)}
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(shared.peaks[[i]]) > 0){
        for(tr in 1:nrow(shared.peaks[[i]])){
            cat("####", shared.peaks[[i]][tr,2], ", Chr", shared.peaks[[i]][tr,3], "\n")
                
            trait = as.numeric(gsub("Composite_Trait", "", shared.peaks[[i]][tr,2]))
            chr = as.numeric(shared.peaks[[i]][tr,3])
            pos.trait.qtl <- as.numeric(shared.peaks[[i]][tr,4])
            pos.transcript.qtl <- as.numeric(shared.peaks[[i]][tr,11])
            if(chr == 20){chr = "X"}

            trans <- apply(boot.CCA.results[[i]]$u, 2, function(x) matched.mats[[i]]$X %*% x)
            rownames(trans) <- rownames(matched.mats[[i]]$X)
            colnames(trans) <- paste0("CTrans", 1:ncol(trans))

            ctrait <- apply(boot.CCA.results[[i]]$v, 2, function(x) matched.mats[[i]]$Z %*% x)
            rownames(ctrait) <- rownames(matched.mats[[i]]$Z)
            colnames(ctrait) <- paste0("CTrans", 1:ncol(ctrait))

            transcript.lod <- scan1(genoprobs[,chr], trans[,trait,drop=FALSE])
            transcript.coef <- scan1blup(genoprobs[,chr], trans[,trait,drop=FALSE])
            #map the trait too
            trait.lod <- scan1(genoprobs[,chr], ctrait[,trait,drop=FALSE])
            trait.coef <- scan1blup(genoprobs[,chr], ctrait[,trait,drop=FALSE])
            
            result <- list("Transcript_LOD" = transcript.lod, 
            "Transcript_Coef" = transcript.coef, 
            "Trait_LOD" = trait.lod, 
            "Trait_Coef" = trait.coef)

            #plot the results
            layout.mat <- matrix(c(1,2,3,4,5,0), nrow = 3, byrow = TRUE)
            layout(layout.mat)
            par(mar = c(2,2,2,2))
            plot(transcript.lod, map = map, main = paste("Transcript QTL"))
            abline(v = pos.transcript.qtl)
            
            plot_coefCC(transcript.coef, map = map)
            abline(v = pos.transcript.qtl)
            mtext(paste("CTranscript", trait, "Chr", chr), side = 3, outer = TRUE, line = -2)
            #cat("\n\n")

            plot(trait.lod, map = map, main = "Trait QTL")
            abline(v = pos.trait.qtl)
            plot_coefCC(trait.coef, map = map)
            abline(v = pos.trait.qtl)
            #mtext(paste0("CTrait: ", trait, ", Chr: ", chr), side = 3, 
            #outer = TRUE, line = -2)

            #compare allele coefficients for the trait and transcript
            chr.pos.trait <- as.numeric(sapply(strsplit(rownames(trait.coef), "_"), function(x) x[2]))
            nearest.trait.marker <- get.nearest.pt(chr.pos.trait, pos.trait.qtl*1e6)
            trait.allele <- trait.coef[nearest.trait.marker,LETTERS[1:8]]
            
            chr.pos.trans <- as.numeric(sapply(strsplit(rownames(transcript.coef), "_"), function(x) x[2]))
            nearest.trans.marker <- get.nearest.pt(chr.pos.trans, pos.transcript.qtl*1e6)
            transcript.allele <- transcript.coef[nearest.trans.marker,LETTERS[1:8]]
            plot.with.model(trait.allele, transcript.allele, pch = 16, col = CCcolors,
            xlab = "Trait Coefficients", ylab = "Transcript Coefficients")
     
            cat("\n\n")
        }
    }  #end peaks for tissue
    if(is.interactive){dev.off()}
}
```


## All Together {.tabset .tabset-fade .tabset-pills}

In this analysis we care about the confluence of good QTL, good functional 
enrichments, and good trait contributions. So far we don't have a way of 
really showing those all together. I am going to attempt to build a graphic
that will show us everything together for a single composite trait-transcript
pair. 

```{r all_together_fun}
plot.all.together <- function(tissue.mats, tissue.results, tissue.enrich.summary,
    tissue.qtl, separate.windows = FALSE){

    trait.loadings <- tissue.results$v
    trait.description <- get_trait_description(tissue.mats, tissue.results, 
    short_version = TRUE)
    rownames(trait.loadings) <- colnames(tissue.mats$Z)
    colnames(trait.loadings) <- trait.description

    latent_trait_trans <- get_latent_var(tissue.mats, tissue.results)

    for(ct in 1:ncol(trait.loadings)){
        cat("#### CT", ct, "\n")
        
        if(separate.windows){quartz(width = 11, height = 6)}
        layout.mat <- matrix(c(1,2,2,3,3,5,4,4,0), nrow = 3, byrow = TRUE)
        layout(layout.mat, heights = c(1, 0.7, 0.7), widths = c(0.7, 1, 1))
        
        #plot trait contributions to composite trait
        par(mar = c(4, 8, 4, 2))
        have.contributions <- which(trait.loadings[,ct] != 0)
        loading.order <- order(trait.loadings[have.contributions,ct])
        barplot(t(trait.loadings[have.contributions[loading.order],ct,drop=FALSE]), 
        las = 2, main = paste("CT", ct, "Trait Contributions"), horiz = TRUE, 
        col = "gray")

        split.enrich.names <- strsplit(gsub("Transcript", "", colnames(tissue.enrich.summary)), "_")
        ct.enrich.name <- sapply(split.enrich.names, function(x) x[1])
        ct.enrich.dir <- sapply(split.enrich.names, function(x) x[2])
        ct.locale <- which(ct.enrich.name == ct)
        ct.enrich.up <- tissue.enrich.summary[,intersect(ct.locale, which(ct.enrich.dir == "up"))]
        ct.enrich.down <- tissue.enrich.summary[,intersect(ct.locale, which(ct.enrich.dir == "down"))]
        enrich.summ <- cbind(ct.enrich.up, ct.enrich.down)
        enrich.summ <- enrich.summ[which(rowSums(enrich.summ) > 0),]
        colnames(enrich.summ) <- c("Positive", "Negative")
        ordered.summ <- enrich.summ[order(rowSums(enrich.summ), decreasing = FALSE),]
        
        par(mar = c(4,40,4,4))
        #imageWithText(ordered.summ, use.pheatmap.colors = TRUE, cex = 1.5, col.text.rotation = 0, col.text.adj = 0.5, col.text.shift = 0.6, row.text.adj = 1, row.text.shift = 0.3)
        #mtext("Enrichment Summary", side = 3)
        up.down.col <- c(get.color("brown")[3], get.color("blue")[3])
        barplot(t(ordered.summ), horiz = TRUE, las = 2, 
        col = up.down.col, xlab = "-log10(pval)")
        legend("bottomright", fill = up.down.col, legend = c("Positive", "Negative"),
        adj = 0)

        par(mar = c(4,4,2,4))
        plot(tissue.qtl[[1]], map = map, lodcol = ct, main = "Composite Transcript QTL")
        plot(tissue.qtl[[2]], map = map, lodcol = ct, main = "Composite Trait QTL")

        plot.with.model(latent_trait_trans[[2]][,ct], latent_trait_trans[[1]][,ct],
        xlab = paste("Latent Transcript", ct), ylab = paste("Latent Trait", ct))
        cat("\n\n")
    }
}

```

```{r plot_all, results = "asis", fig.width = 11, fig.height = 11}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "{.tabset .tabset-fade .tabset-pills}\n")
    plot.all.together(tissue.mats = matched.mats[[i]], 
        tissue.results = boot.CCA.results[[i]], 
        tissue.enrich.summary = go.summaries[[i]],
        tissue.qtl = qtl.results[[i]], separate.windows = is.interactive)
}
```

## All together trait loadings

```{r tissue_trait_comparison, fig.height = 11, fig.width = 7}
all.loadings <- lapply(boot.CCA.results, function(x) x$v)
for(i in 1:length(all.loadings)){
    rownames(all.loadings[[i]]) <- colnames(matched.mats[[i]]$Z)
    colnames(all.loadings[[i]]) <- paste0(tissue.names[i], "_Trait", 1:ncol(all.loadings[[i]]))
}
loading.mat <- Reduce("cbind", all.loadings)

tissue.col <- data.frame(sapply(strsplit(colnames(loading.mat), "_"), function(x) x[1]))
colnames(tissue.col) <- "Tissue"
rownames(tissue.col) <- colnames(loading.mat)

row.order <- order(rownames(loading.mat))
#pdf("~/Desktop/loading_mat.pdf", width = 7, height = 11)
pheatmap(t(loading.mat), annotation_row = tissue.col)
pheatmap(t(loading.mat), annotation_row = tissue.col, cluster_rows = FALSE)
#dev.off()

#pheatmap(cor(loading.mat))
#has.vals <- which(rowSums(loading.mat) != 0)
#pheatmap(cor(t(loading.mat[has.vals,])))
```


## Transcript Loading Profiles {.tabset .tabset-fade .tabset-pills}

The following plots show the original CCA loadings for each trait
plotted with the bootstrapped loadings.

```{r trans_loadings, results = "asis", fig.height = 7, fig.width = 9}
for(i in 1:length(tissue.names)){
    cat("###", tissue.names[i], "\n")
    if(is.interactive){quartz(width = 9, height = 7)}
    par(mfrow = c(4,5), mar = c(2,2,2,2))
    for(j in 1:20){
        trans.loadings <- boot.CCA.results[[i]]$u[,j]
        orig.loadings <- tissue.CCA.results[[i]]$u[,j]
        length(which(trans.loadings != 0))
        length(which(orig.loadings != 0))
        length(intersect(which(trans.loadings != 0), which(orig.loadings != 0)))
        non.zero <- which(trans.loadings != 0)
        trans.order <- order(trans.loadings[non.zero])
        if(j != 3){main.text = paste0("CT", j)}else{main.text = ""}
        plot(orig.loadings[non.zero[trans.order]], pch = 16, cex = 0.5, main = main.text)
        points(trans.loadings[non.zero[trans.order]], pch = 16, cex = 0.5, col = "red")
    }
    mtext(side = 3, text = tissue.names[i], line= -1.5, outer = TRUE)
    cat("\n\n")
}
```

## Compare Bootstrapping by CT

The following plots compare the bootstrapped CT pairs to the original CT
pairs.

```{r}
max.cor <- max(c(max(all.cca.cancor), max(all.boot.cancor)))
for(i in 1:length(tissue.names)){
    if(is.interactive){quartz(width = 10, height = 10)}
    layout.matrix <- get.layout.mat(ncol(matched.mats[[i]]$Z)*2, "upright")
    layout(layout.matrix, widths = rep(c(0.8, 0.5), 3))
    par(mar = c(2,2,2,2))
    tissue.cca.cancor <- all.cca.cancor[,i]
    tissue.boot.cancor <- all.boot.cancor[,i]

    for(j in 1:ncol(matched.mats[[i]]$Z)){
        trans.loadings <- boot.CCA.results[[i]]$u[,j]
        orig.loadings <- tissue.CCA.results[[i]]$u[,j]
        length(which(trans.loadings != 0))
        length(which(orig.loadings != 0))
        length(intersect(which(trans.loadings != 0), which(orig.loadings != 0)))
        non.zero <- which(trans.loadings != 0)
        trans.order <- order(trans.loadings[non.zero])
        plot(orig.loadings[non.zero[trans.order]], pch = 16, cex = 0.5, 
        main = paste0("CT", j, " Loadings"),
        ylab = "Transcript Loadings", col = tissue.cols[1])
        points(trans.loadings[non.zero[trans.order]], pch = 16, cex = 0.5, 
        col = tissue.cols[2])

        #neg.boot.idx <- which(trans.loadings[non.zero[trans.order]] < 0)
        #pos.boot.idx <- which(trans.loadings[non.zero[trans.order]] > 0)
        #neg.boot <- trans.loadings[non.zero[trans.order]][neg.boot.idx]
        #pos.boot <- trans.loadings[non.zero[trans.order]][pos.boot.idx]
        
        #neg.elbow <- get_elbow(1:length(neg.boot), neg.boot, TRUE)
        #genes.below.elbow <- colnames(matched.mats[[i]]$X)[non.zero[trans.order][neg.boot.idx][1:neg.elbow]]

        #pos.elbow <- get_elbow(1:length(pos.boot), pos.boot, TRUE)
        #genes.above.elbow <- colnames(matched.mats[[i]]$X)[non.zero[trans.order][pos.boot.idx][pos.elbow:length(pos.boot)]]

        #pos.elbow.genes <- gene.table[match(genes.above.elbow, gene.table[,1]),"symbol"]
        #neg.elbow.genes <- gene.table[match(genes.below.elbow, gene.table[,1]),"symbol"]

        #pos.enrich <- gost(pos.elbow.genes, organism = "mmusculus")
        #plot.enrichment(pos.enrich)
        
        #neg.enrich <- gost(neg.elbow.genes, organism = "mmusculus")
        #plot.enrichment(neg.enrich)


        barplot(c(all.cca.cancor[j,i], all.boot.cancor[j,i]), 
        ylab = "Canonical Correlation", names = c("Orig", "Boot"),
        col = tissue.cols[1:2], ylim = c(0, max.cor), main = paste0("CT", j, " Cancor"))
    
    
    }
}
```

```{r finding_individuals, eval = FALSE}
tissue.idx = 3
ct.name <- "Transcript18"
ct.idx <- grep(ct.name, names(transcript.ids[[tissue.idx]]))
length(ct.idx)
transcript.ids[[tissue.idx]][ct.idx]


```

## All together transcript loadings

```{r transcripts_per_trait, fig.width = 7, fig.height = 5}
all.transcript.loadings <- lapply(boot.CCA.results, function(x) x$u)
all.pos.trans <- lapply(all.transcript.loadings, 
    function(y) apply(y, 2, function(x) length(which(x > 0))))
all.neg.trans <- lapply(all.transcript.loadings, 
    function(y) apply(y, 2, function(x) length(which(x < 0))))

#pdf("~/Desktop/transcripts_per_trait.pdf", width = 7, height = 5)
plot.grouped.boxes(list("Positive Loadings" = all.pos.trans, 
"Negative Loadings" = all.neg.trans), plot.type = "box",
legend.x = 6, legend.y = 5000)
#dev.off()
```

## All together canonical correlations

The following figure shows the distribution of canonical correlations
for each tissue. The right-hand plot shows correlations for only 
penalty combinations that had significant correlations.

```{r all_can_cor, fig.width = 8, fig.height = 4}
perm.files <- lapply(tissue.names, function(x) file.path(results.dir, paste0(x, ".", file.text, ".perm.RDS")))
all.tissue.perm <- lapply(perm.files, readRDS)
all.perm.results <- lapply(all.tissue.perm, function(x) x$cors)

par(mfrow = c(1,2))
boxplot(all.perm.results, names = tissue.names, main = "Canonical Correlation by Tissue")

sig.cor <- lapply(1:length(all.tissue.perm), function(x) all.tissue.perm[[x]]$cors[which(all.tissue.perm[[x]]$pvals < 0.05)])
boxplot(sig.cor, names = tissue.names, main = "Significant Canonical Correlation by Tissue")
```

```{r check_eqtl, eval = FALSE}
gene.name = "Wisp1"
gene.id <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "gene.id"])
gene.chr <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "chr"])
gene.pos <- unique(gene.table[which(gene.table[,"symbol"] == gene.name), "start"])
gene.locale <- lapply(matched.mats, function(x) which(colnames(x$X) == unlist(gene.id)))
gene.eqtl <- lapply(1:length(gene.locale), function(x) if(length(gene.locale[[x]] > 0)){scan1(genoprobs, matched.mats[[x]]$X[,gene.locale[[x]]])}else{NA})
for(i in 1:length(gene.eqtl)){
    if(length(gene.eqtl[[i]]) > 1){
        if(is.interactive){quartz(width = 10, height = 7)}
        par(mfrow = c(2,1))
        plot(gene.eqtl[[i]], map = map, main = paste0(tissue.names[i], ": ", gene.name))
        chr.locale <- which(names(map) == gene.chr)
        allele.coef <- scan1coef(genoprobs[,chr.locale], matched.mats[[i]]$X[,gene.locale[[i]]])
        plot_coefCC(allele.coef, map = map)
        abline(v = as.numeric(gene.pos))
    }
}
```

## Mediation

We can 

## Conclusion

What does this get us? 

Transcriptional processes that are highly correlated with physiological traits

Clustering of functional enrichments helps interpret the enrichments.
    For example...

Limited number of transcripts associated with each composite trait


