---
title: "High Dimensional Mediation"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow explores the possibility of using high-dimensional mediation
with the Cube data. 

There are several parameters to set.
    1. exp.name: will determine the directory in which the results are stored.
    2. merge.tissues: if TRUE, the transcription kernel is an average of 
        all independent tissue kernels.
    3. use.local.imputation: if TRUE uses locally imputed transcript values 
        to generate polygenic risk scores, if FALSE, uses transcripts imputed 
        with full genetic model (local + kinship)
        The full genetic model gives us better concordance with DO phenotypes,
        but we can't use kinship in the model if we are going to predict phenotypes
        in other populations, like inbred founders, or the CC-RIX.

```{r get_args}
args <- commandArgs(trailingOnly=T)

#args <- c(1,1,0,0,0) #merged tissues, local imputation, reactive model
#args <- c(1,1,0,1,0) #merged tissues, local imputation, mediation model
args <- c(0,0,0,0,0) #sep tissues, full imputation, reactive model
#args <- c(0,0,0,1,0) #sep tissues, full imputation, mediation model

merge.tissues <- as.logical(args[1]) #if TRUE tissue transcriptome kernels are averaged. Otherwise they are used separtely
use.local.imputation <- as.logical(args[2]) #if TRUE, locally imputed transcripts are used to generate polytranscriptomic risk scores. Otherwise transcripts imputed with the full genetic model are used.
weight.adjusted <- as.logical(args[3]) #if TRUE, body weight is adjusted out of the phenotypes and transcriptome before running mediation
complete.mediation <- as.logical(args[4]) #if TRUE use a mediation network. If FALSE use a reactive network
delete_previous <- as.logical(args[5])

merge.text.options <- c("tissue_sep", "tissue_together")
imputation.options <- c("full_imp", "local_imp")
weight.options <- c("_", "weight_adjusted")
mediation.options <- c("reactive", "complete_mediation")

merge.text <- merge.text.options[(as.numeric(merge.tissues)+1)]
imp.text <- imputation.options[(as.numeric(use.local.imputation)+1)]
weight.text <- weight.options[(as.numeric(weight.adjusted)+1)]
mediation.text <- mediation.options[(as.numeric(complete.mediation)+1)]

exp.name <- paste(merge.text, imp.text, weight.text, mediation.text, sep = "-")

```

This run had the following settings:

* Tissue treatment: `r merge.text`
* Imutation used: `r imp.text`
* Weight adjustment: `r weight.text`
* Mediation type: `r mediation.text`

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "High_Dim_Med", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir, recursive = TRUE)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "Matrix", "RGCCA", 
    "bnstruct", "igraph", "corpcor")
load_libraries(all.packages, personal.library = TRUE)
```

## Read in data

Load data from QTL viewer.

```{r read_data}
tissue.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
tissue.names <- gsub("dataset.DO.Cube.", "", tissue.data[1:4])

data.set.names <- lapply(1:length(tissue.names), 
    function(x) paste0("dataset.DO.Cube.", tissue.names[x]))
gene.table <- as.matrix(unique(Reduce("rbind", lapply(data.set.names, 
    function(x) get(x)$annot.mrna))))

covar <- lapply(data.set.names, function(x) get(x)$covar.matrix)
```


## Read phenotypes and adjust

Adjust phenotype data for DO generation, sex, and diet days.

```{r pheno}
pheno <- as.matrix(read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE))
num.pheno <- apply(pheno[,11:(ncol(pheno)-1)], 2, as.numeric)
rownames(num.pheno) <- pheno[,1]

max.n <- which.max(sapply(covar, nrow)) #adjust with the largest covariate matrix
adj.covar <- Reduce("cbind", get.xz(covar[[max.n]], num.pheno[,"diet_days",drop=FALSE]))
adj.pheno <- adjust(num.pheno[,2:ncol(num.pheno)], adj.covar) #remove diet days from num.pheno
```


## Adjust transcripts

Adjust transcripts for the same covariates.
Also adjust out weight from phenotypes and expression if specified.

```{r adj_expr}
tissue.expr <- lapply(data.set.names, function(x) get(x)$data$norm)
tissue.adj.expr <- lapply(tissue.expr, function(x) adjust(x, adj.covar))

#adjust wei
if(weight.adjusted){
    #try adjusting out weight
    weight.col <- grep("weight", colnames(adj.pheno))
    non.weight.col <- setdiff(1:ncol(adj.pheno), weight.col)
    weight <- adj.pheno[,weight.col]

    adj.pheno <- adjust(adj.pheno[,non.weight.col], weight)    
    tissue.adj.expr <- lapply(tissue.adj.expr, function(x) adjust(x, weight))
}

```


## Scale transcriptome and phenotypes

to mean 0 and std 1 by gene

```{r scale}
scaled.expr <- lapply(tissue.adj.expr, function(x) apply(x, 2, scale))
for(i in 1:length(scaled.expr)){
    rownames(scaled.expr[[i]]) <- rownames(tissue.adj.expr[[i]])
}
scaled.pheno <- apply(adj.pheno, 2, scale)
rownames(scaled.pheno) <- rownames(adj.pheno)
```


```{r weight, eval = FALSE}
cols <- categorical_pal(8)
weight <- adj.pheno[,18:20]
sex <- pheno[match(rownames(weight), pheno[,1]),"sex"]
sex.col <- rep(cols[2], length(sex))
sex.col[which(sex == "M")] <- cols[3]

weight.diff <- weight[,3]/weight[,2]
stripchart(round(weight.diff, 3), method = "stack", col = "darkgray", 
    pch = 16, ylim = c(1,2), offset = 0.7, axes = FALSE)
axis(1);abline(v = 1)

scaled.pheno <- apply(adj.pheno, 2, scale)
pheatmap(scaled.pheno, show_rownames = FALSE)

pheno.decomp <- plot.decomp(cov(t(scaled.pheno), use = "pairwise.complete.obs"), pc = 20)
pheno.decomp <- plot.decomp(scaled.pheno, pc = 20)
decomp.cor <- matrix(NA, nrow = 20, ncol = 20)
rownames(decomp.cor) <- paste0("PC", 1:20)
colnames(decomp.cor) <- colnames(scaled.pheno)

trait.loadings <- pheno.decomp$v
var.exp <- pheno.decomp$var.exp*100
rownames(trait.loadings) <- colnames(scaled.pheno)
colnames(trait.loadings) <- paste0("PC", 1:20)

trait.order <- c(1:3, c(4:20)[order(colnames(scaled.pheno)[4:20])])
layout(matrix(c(1,2,0,3), ncol = 2, byrow = FALSE), heights = c(0.4, 1), widths = c(1, 0.3))
par(mar = c(0,7.6,1,0.8))
barplot_with_num(round(var.exp, 1), ylab = "% Var. Exp.", text.srt = 45, adj = 0)
par(mar = c(3,8,0,1))
imageWithText(trait.loadings[trait.order,], show.text = FALSE, use.pheatmap.colors = TRUE,
    row.text.shift = 0.05, col.text.shift = 0.05)
par(mar = c(19,2,1,8))
imageWithTextColorbar(trait.loadings, use.pheatmap.colors = TRUE, cex = 1)

for(i in 1:nrow(decomp.cor)){
    for(j in 1:ncol(decomp.cor)){
        cor.val <- cor(pheno.decomp$u[,i], scaled.pheno[,j], use = "pairwise.complete.obs")
        decomp.cor[i,j] <- decomp.cor[j,i] <- cor.val
    }
}
pheatmap(decomp.cor, cluster_rows = FALSE, cluster_cols = FALSE)


layout(matrix(1:20, nrow = 4, ncol = 5))
par(mar = c(1,1,1,1))
for(i in 1:ncol(scaled.pheno)){
    plot(pheno.decomp$u[,2], scaled.pheno[,i], main = colnames(scaled.pheno)[i])
}

gene.name = "Lep"
gene.id <- gene.table[match(gene.name, gene.table[,"symbol"]),1]
gene.idx <- lapply(scaled.expr, function(x) which(colnames(x) == gene.id))
gene.expr <- lapply(1:length(gene.idx), function(x) if(length(gene.idx[[x]]) > 0){scaled.expr[[x]][,gene.idx[[x]]]})
tx = 4
plot.with.model(gene.expr[[tx]], scaled.pheno[names(gene.expr[[tx]]),"Ins_tAUC"])
```


## Build transcriptomic kernel

```{r kernelize}
Kt <- lapply(scaled.expr, function(x) x %*% t(x) / dim(x)[2])

if(merge.tissues){
    #make a single Kt matrix that is the average of all expression kernels
    #it is repeated for all tissues, so we don't need to change the structure
    #of the analysis
    #This will represent the structure of expression across all tissues
    common.ind <- Reduce("intersect", lapply(Kt, rownames))
    total.Kt <- Reduce("+", lapply(Kt, function(x) x[common.ind, common.ind]))
    Kt <- lapply(1:length(tissue.names), function(x) total.Kt/length(tissue.names))
    names(Kt) <- tissue.names
}
```

## Kinship matrix

```{r kin}
kin.file <- here("Data", "overall.kinship.RDS")
if(!file.exists(kin.file)){
    Kg = calc_kinship(genoprobs, "overall")
    saveRDS(Kg, kin.file)
}else{
    Kg <- readRDS(kin.file)
}
```

Subset and center kinship matrix based on DO generation.

```{r subset}
do_gen <- lapply(covar, function(x) x[,2:ncol(x)])
gen_cent = lapply(do_gen, function(x) x %*% Diagonal(dim(x)[2], 1 / colSums(x)) %*% t(x)) # Centering matrix

#subset kinship matrix to match the individuals in each tissue.
#remove DO generation from kinship matrix
Kg_sub = lapply(1:length(gen_cent), function(x) Kg[rownames(gen_cent[[x]]), rownames(gen_cent[[x]])])
Kg_cent = lapply(1:length(gen_cent), function(x) Kg_sub[[x]] - gen_cent[[x]] %*% Kg_sub[[x]] - Kg_sub[[x]] %*% gen_cent[[x]] + gen_cent[[x]] %*% Kg_sub[[x]] %*% gen_cent[[x]])
```

## Build phenotype kernel

```{r pheno_kernel}
#select a subset of phenotypes
#sub.pheno <- scaled.pheno[,c("num_islets", "Ins_per_islet", "WPIC")]
#sub.pheno <- scaled.pheno[,c("TG_6wk", "TG_10wk", "TG_14wk")]
sub.pheno <- scaled.pheno

#there are a few missing values. Impute these
sub.pheno <- knn.impute(sub.pheno)
Kp = sub.pheno %*% t(sub.pheno) / dim(sub.pheno)[2]
```

## Perform high-dimensional mediation


```{r mediation}

transcript_loading_file <- file.path(results.dir, "Loadings_Transcripts.RDS")
trait_loading_file <- file.path(results.dir, "Loadings_Traits.RDS")
model_file <- file.path(results.dir, "Model_Scores.RDS")

if(!file.exists(transcript_loading_file) || delete_previous){
    transcript_loadings <- trait_loadings <- model_scores <- vector(mode = "list", length = length(tissue.names))
    names(transcript_loadings) <- names(trait_loadings) <- names(model_scores) <- tissue.names
    flags <- rep(NA, length(tissue.names))
    stopping.reasons <- rep(NA, length(tissue.names))
    for(tx in 1:length(tissue.names)){
        if(is.interactive){cat("\n", tissue.names[tx], "\n")}
        
        #assign matrices to proper positions
        if(complete.mediation){
            #transcripts are the mediator
            mediator.kernel = Kt[[tx]]; transcript.col <- "Mediator"
            #phenotypes are the outcome
            outcome.kernel = Kp; trait.col <- "Outcome"
        }else{
            #phenotypes are the mediator
            mediator.kernel = Kp;trait.col <- "Mediator" 
            #transcripts are the outcome
            outcome.kernel = Kt[[tx]]; transcript.col = "Outcome" 
        }
        
        fit.result <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
            mediating.matrix = mediator.kernel, outcome.matrix = outcome.kernel, 
            min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
            verbose = is.interactive, kernel.c = TRUE, kernel.m = TRUE, 
            kernel.o = TRUE)
        model_scores[[tx]] <- fit.result[[1]]
        flags[tx] <- fit.result[[2]]
        stopping.reasons[tx] <- fit.result[[3]]

        #calculate transcript loadings
        #This is the correlation between the scaled expression
        #and the transcript score found by the model
        expr_cor <- calc_loadings(model_scores[[tx]][,transcript.col,drop = FALSE], 
            scaled.expr[[tx]])
        
        #convert ensembl Ids to gene names and save loadings
        transcript.names = gene.table[match(rownames(expr_cor), gene.table[,1]),"symbol"]
        rownames(expr_cor) = transcript.names
        transcript_loadings[[tx]] <- expr_cor

        #do the same for phenotype loadings
        trait_cor <- calc_loadings(model_scores[[tx]][,trait.col,drop = FALSE], 
            sub.pheno)
        trait_loadings[[tx]] <- trait_cor
    }

    saveRDS(transcript_loadings, transcript_loading_file)
    saveRDS(trait_loadings, trait_loading_file)
    saveRDS(model_scores, model_file)
}else{
    transcript_loadings <- readRDS(transcript_loading_file)
    trait_loadings <- readRDS(trait_loading_file)
    model_scores <- readRDS(model_file)
}

```

The following plots show the partial correlations between
the causal factor, the mediator, and the outcome. Line
width corresponds to partial correlation, and line color
corresponds with the sign of the partial correlation. Orange
is negative and green is positive.

```{r plot_nets}
for(tx in 1:length(tissue.names)){
    tx.pcor <- pcor.shrink(model_scores[[tx]], verbose = FALSE)
    tx.pcor[lower.tri(tx.pcor, diag = TRUE)] <- 0
    net <- graph_from_adjacency_matrix(tx.pcor, weighted = TRUE, mode = "directed")
    e.weight <- E(net)$weight
    plot(net, edge.width = abs(e.weight*10), edge.color = sign(e.weight)+2, 
        main = tissue.names[tx], layout = layout_on_grid, edge.label = signif(e.weight, 2),
        edge.label.cex = 1.5, vertex.size = 30)
}
```

## Permutations {.tabset .tabset-fade .tabset-pills}

Run permutations to calulate a null distribution for the path
coefficient. This is the correlation between the causal matrix
and the outcome matrix. To do this, we shuffle the names of the
mediator kernel. This decorrelates the 


```{r perm}

if(merge.tissues){
    max.tx <- 1
}else{
    max.tx <- 4
}

perm.file <- file.path(results.dir, "Permutations.RDS")

if(!file.exists(perm.file) || delete_previous){
    num.perm = 100
    all.perms <- vector(mode = "list", length = max.tx)

    for(tx in 1:max.tx){

        if(complete.mediation){
            #for the mediation model, the transcript kernel is the mediator
            mediator.kernel = Kt[[tx]]
            outcome.kernel = Kp
        }else{
            #for the reactive model, the phenotype is the mediator
            mediator.kernel = Kp
            outcome.kernel = Kt[[tx]]
        }
        
        perm_path <- rep(NA, length = num.perm)
        perm.flags <- rep(NA, length = num.perm)
        perm.reasons <- rep(NA, length = num.perm)
        for(p in 1:num.perm){

            if(is.interactive){report.progress(p, num.perm)}
            
            #permute the mediator
            perm_names <- sample(rownames(mediator.kernel))
            perm_mediator <- mediator.kernel
            rownames(perm_mediator) <- colnames(perm_mediator) <- perm_names

            #and the outcome? Not sure if this is the right thing to do
            perm_names <- sample(rownames(outcome.kernel))
            perm_outcome <- outcome.kernel
            rownames(perm_outcome) <- colnames(perm_outcome) <- perm_names

            perm_scores <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
                mediating.matrix = perm_mediator, outcome.matrix = perm_outcome, 
                min.weight.diff = 1e-5, max.iter = 15, scheme = "horst", 
                verbose = is.interactive, kernel.c = TRUE, kernel.m = TRUE, 
                kernel.o = TRUE)
        
            perm_path[p] <- path_coef(perm_scores[[1]])
            perm.flags[p] <- perm_scores[[2]]
            perm.reasons[p] <- perm_scores[[3]]
        }

    all.perms[[tx]] <- perm_path
    }

    saveRDS(all.perms, perm.file)

}else{
    all.perms <- readRDS(perm.file)
}
```

The following plots show the null distribution for each 
tissue, unless tissues were merged, and then only one
null distribution is shown.

```{r plot_perm, results = "asis"}

for(tx in 1:max.tx){
    cat("###", tissue.names[tx], "\n")
    
    tissue.path.coef <- path_coef(model_scores[[tx]])

    xmax <- max(all.perms[[tx]], tissue.path.coef)
    xmin <- min(all.perms[[tx]], tissue.path.coef)
    hist(all.perms[[tx]], xlim = c(xmin, xmax))
    abline(v = tissue.path.coef, col = "red")

    cat("\n\n")
}
```


## Correlation Plots {.tabset .tabset-fade .tabset-pills}

The following plots show the correlations between the 
pairs of scores for all model scores. With perfect 
mediation, the product of the genome-transcripts 
correlation and the transcripts-phenotype correlation
should be equal to that of the genome-phenotype correlation.

The correlation diff at the top of each figure tells us
the difference between the ideal correlation and 
the actual correlation.

```{r plot_cor, results = "asis", fig.height = 6, fig.width = 6}

for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "\n")
    #find the correlations between the scores
    curr_scores <- model_scores[[tx]]
    
    #change from generic names to specific names
    if(complete.mediation){
        colnames(curr_scores) <- c("Genome", "Transcriptome", "Traits")
    }else{
        colnames(curr_scores) <- c("Genome", "Traits", "Transcriptome")
    }
    
    path.coef <- path_coef(curr_scores)

    #test <- check_signs(curr_scores)
    #pairs(test[[1]])

    pairs(curr_scores, main = paste(tissue.names[tx], "\nPath  Coef:", round(path.coef, 3)))
    cat("\n\n")
}

```


## Enrichment Plots {.tabset .tabset-fade .tabset-pills}

The following plots show the functional enrichment for transcripts
at the top and bottom of each list for each tissue.

This section also writes out the top and bottom transcripts
for analysis in CMAP.

```{r enrichment}
enrich.file <- file.path(results.dir, "Top_Bottom_Enrichment.RDS")
hum.mus.ortho <- as.matrix(read.delim(here("Data", "human.mouse.orthologs.txt"), 
    stringsAsFactors = FALSE))

if(!file.exists(enrich.file) || delete_previous){
    all.enrich <- vector(mode = "list", length = length(tissue.names))
    names(all.enrich) <- tissue.names

    top.n <- 150
    for(tx in 1:length(tissue.names)){
        top.genes <- sort(transcript_loadings[[tx]][,1], decreasing = TRUE)[1:top.n]
        top.enrich <- gost(names(top.genes), organism = "mmusculus")
        
        top.id <- gene.table[match(names(top.genes), gene.table[,"symbol"]),1]
        top.hum.id <- mouse_to_human_entrez(top.id, hum.mus.ortho)

        bottom.genes <- sort(transcript_loadings[[tx]][,1], decreasing = FALSE)[1:top.n]
        bottom.enrich <- gost(names(bottom.genes), organism = "mmusculus")
        bottom.id <- gene.table[match(names(bottom.genes), gene.table[,"symbol"]),1]
        bottom.hum.id <- mouse_to_human_entrez(bottom.id, hum.mus.ortho)
        
        cmap.table <- cbind(top.hum.id[,"Human.Entrez"], bottom.hum.id[,"Human.Entrez"])
        colnames(cmap.table) <- c("Positive", "Negative")
        write.table(cmap.table, 
            file.path(results.dir, paste0("CMAP_Human_Entrez_", tissue.names[tx], ".txt")),
            quote = FALSE, row.names = FALSE, sep = "\t")

        all.enrich[[tx]] <- list("top" = top.enrich, "bottom" = bottom.enrich)
    }
    saveRDS(all.enrich, enrich.file)
}else{
    all.enrich <- readRDS(enrich.file)
}

```

```{r plot_enrichment, results = "asis", fig.width = 8, fig.height = 6}
 
for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")

    cat("#### Positive Loadings\n\n")
    plot.enrichment(all.enrich[[tx]]$top, 
        plot.label = paste(tissue.names[tx], "Positive Loadings"), 
        num.terms = 30)

    cat("#### Negative Loadings\n\n")
    plot.enrichment(all.enrich[[tx]]$bottom, 
        plot.label = paste(tissue.names[tx], "Negative Loadings"), 
        num.terms = 25)

    cat("\n\n")
}
```

## Trait loadings

The following plots show the loadings on traits for 
each tissue.

This shows either 

* which traits are most affected by the genome -> transcriptome path (complete mediation)
* Or which traits are most affecting the transcriptome (reactive)

```{r trait_loadings, fig.width = 7, fig.height = 6}
all.loadings <- Reduce("cbind", trait_loadings)
colnames(all.loadings) <- tissue.names
pheatmap(all.loadings)
```


## Polygenic risk scores  {.tabset .tabset-fade .tabset-pills}

If we are mediating the effect of the genome on phenotype with 
the transcriptome, each transcript has a loading for how much 
it affects the phenotypes and eQTL that regulate its transcription. 
For a given individual mouse, their position in trait space will 
depend on the amount that transcript affects the phenotype, and the 
degree to which the transcript is up or downregulated in that particular 
individual based on genotype.

Can we generate a transcript score for each individual based on 
their genotype(s) at the eQTL loci?

Note that this only makes sense to do if we are using the 
transcriptome to mediate the effect of the genome on phenotype. 
We cannot make trait predictions based on eQTL if we are 
running the reactive model.

Each transcript has some effect on the composite phenotype, 
based on its loading. Here we multiply the transcript
loadings by each imputed transcript. This gives us the
contribution of each transcript to the overall phenotype
in each individual. This is the transcriptional pressure
each gene is putting on the phenotype. We can add up, or
take the mean of the transcriptional pressure across the 
whole genome to estimate where the individual lives in 
phenotype space. 

If we are using the transcriptome to mediate the effects of
the genome on the phenome, multiple plots will appear below:
    1. Histogram of the transcriptional weights driving phenotype in the
        organism with the lowest transcriptionally predicted phenotype
    2. Boxplots for the top and bottom 10 individuals based on transcriptionally
        predicted phenotype.
    3. Scatterplot showing the first principal component of the trait matrix
        plotted agains the transcriptional prediction for phenotype.
    4. There are many transcripts with large effects. We selected all
        transcripts that had an effect above a threshold in any animal.
        We then counted in how many animals that transcript had a large
        effect. This plot shows that count of individuals for each 
        large-effect transcript.
    5. We then selected the transcripts that had large effects in a minimum
        number of animals. The boxplot shows the distribution of effects of 
        these common large effect transcripts across the population. 
        For the most part the effects are consistent, but almost all have
        positive effects in some individuals and negative effects in others.

The genes that have large effects across multiple organisms seem to be rather
obscure. Some are known diabetes genes, but most of them seem pretty irrelevant.

```{r polygenic_risk_score, results = "asis"}
if(mediation.text == "complete_mediation"){
    #read in the imputed transcripts generated by Matt
    if(use.local.imputation){
        tissue.imp.gen <- readRDS(here("Data", "imputed", paste0("Adjusted_Expression_DO_imputed_local.RDS")))
    }else{
        tissue.imp.gen <- readRDS(here("Data", "imputed", paste0("Adjusted_Expression_DO_imputed_genetic.RDS")))
    }

    #Get the first principle componenet of the phenotype matrix
    trait.decomp <- plot.decomp(sub.pheno, plot.results = FALSE, pc = 3)
    pc <- trait.decomp$u
    rownames(pc) <- rownames(sub.pheno)

    large.effect.size = 0.5 #minimum effect size that is considered large
    num.common.genes = 20 #number of genes to look at from the top of the list

    #For each tissue, calculate the pressure
    #exerted by each transcript on the phenotype
    common.large.effect.genes <- vector(mode = "list", length = length(tissue.names))
    names(common.large.effect.genes) <- tissue.names
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")
        trans.load <- transcript_loadings[[tx]]
        transcript.id <- gene.table[match(rownames(trans.load), gene.table[,"symbol"]),"gene.id"]
        rownames(trans.load) <- transcript.id
        
        common.transcripts <- intersect(transcript.id, colnames(tissue.imp.gen[[tx]]))
        expr.by.load <- apply(tissue.imp.gen[[tx]][,common.transcripts], 1, function(x) x*trans.load[common.transcripts,])
        expr.names <- gene.table[match(rownames(expr.by.load), gene.table[,1]),"symbol"]
        rownames(expr.by.load) <- expr.names
        mean.order <- order(colMeans(expr.by.load))

        #par(mfrow = c(1,2))
        cat("#### One Transcriptional Pressure Distribution\n\n")
        hist(expr.by.load[,mean.order[1]], breaks = 100, 
            main = "Polygenic Transcriptional Pressure\non Phenotype Space\nFor Lowest Individual",
            xlab = "Transcriptional Pressure", ylab = "Gene Count")
        abline(v = mean(expr.by.load[,mean.order[1]]), col = "red")
        #hist(expr.by.load[,tail(mean.order, 1)], breaks = 100, 
        #    main = "Polygenic Transcriptional Pressure on Phenotype Space\nFor Highest Individual")
        #abline(v = mean(expr.by.load[,tail(mean.order, 1)]), col = "red")
        
        cat("#### Top Transcriptional Pressure Distributions\n\n")
        show.plot <- c(mean.order[1:10], mean.order[tail(1:length(mean.order), 10)])
        boxplot(expr.by.load[,show.plot], ylab = "Transcriptional Pressure", 
            xlab = "", las = 2)
        abline(h = 0, col = "red")

        cat("#### Transcriptional Prediction vs. PC1 of Traits\n\n")
        common.ind <- intersect(rownames(sub.pheno), colnames(expr.by.load))
        ind.score <- colMeans(expr.by.load)
        plot.with.model(ind.score[common.ind], pc[common.ind,1], 
            xlab = "Transcriptionally Predicted Phenotype", 
            ylab = "First PC of Trait Matrix")

        large.effect <- apply(expr.by.load, 2, function(x) which(abs(x) > large.effect.size))
        all.large <- unlist(large.effect)
        u_large <- unique(all.large)
        large.ind <- sapply(u_large, function(x) which(all.large == x))
        num.ind <- sapply(large.ind, length)

        cat("#### Individuals with Specific Large-Effect Transcripts\n\n")
        plot(sort(num.ind), xlab = "", ylab = "Number of Individuals")

        top.common <- sort(num.ind, decreasing = TRUE)[1:num.common.genes]
        num.thresh <- min(top.common)
        abline(h = num.thresh)
        many.ind <- which(num.ind >= num.thresh)
        large.effect.transcripts <- sapply(strsplit(names(all.large[match(u_large[many.ind], all.large)]), ".", fixed = TRUE), function(x) x[2])
        pop.large.effect <- expr.by.load[large.effect.transcripts,]
        avg.large.effect <- rowMeans(pop.large.effect)
        effect.order <- order(avg.large.effect, decreasing = TRUE)
        #pheatmap(pop.large.effect, show_colnames = FALSE)

        cat("#### Top Large-Effect Transcripts\n\n")
        boxplot(t(pop.large.effect[effect.order,]), las = 2);abline(h = 0, col = "red")
        #avg.large.effect[effect.order]
        #cat(names(avg.large.effect), sep = "\n")

        common.large.effect.genes[[tx]] <- avg.large.effect
        cat("\n\n")
    }

    #cat(names(common.large.effect.genes[[1]]), sep = "\n")
}
```

## Loadings vs. LOD

What is the maximum eQTL LOD score for transcripts compared with 
their loading?

```{r lod_v_loading}
if(mediation.text == "complete_mediation"){
    par(mfrow = c(2,2))
    for(tx in 1:length(tissue.names)){
        eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive
        gene.id <- gene.table[match(rownames(transcript_loadings[[tx]]), gene.table[,"symbol"]),1]
        gene.lod <- lapply(gene.id, function(x) eqtl.table$lod[which(eqtl.table$gene.id == x)])
        max.lod <- sapply(gene.lod, function(x) if(length(x) > 0){max(x)}else{3})
        plot(max.lod, abs(transcript_loadings[[tx]][,1]), xlab = "Maximum LOD", 
            ylab = "|Loading|", main = tissue.names[tx])
        abline(h = c(0.5, 0, -0.5), col = c("red", "black", "red"))  

    }
}
```

## Prediction of inbred phenotypes {.tabset .tabset-fade .tabset-pills}

Can we use allele effects across all transcripts to predict
where an inbred mouse will fall in phenotype space? And can 
we further predict the effect that swapping in an allele from
another mouse will have on the phenotype?

caveat: Any predictions will only incorporate local effects, 
and will ignore kinship.

First we collect the allele effects for all transcripts with
eQTL. For now we will only use the allele effects in the eQTL
browser. This only includes transcripts with eQTL LOD scores
above 6. Eventually we may want to expand to all transcripts.


```{r inbred_prediction}
if(mediation.text == "complete_mediation"){
    inbred.effects.file <- file.path(results.dir, "Inbred_Effects.RDS")

    if(!file.exists(inbred.effects.file) || delete_previous){
        tissue.inbred.effects <- vector(mode = "list", length = length(tissue.names))
        names(tissue.inbred.effects) <- tissue.names
        for(tx in 1:length(tissue.names)){
            t.loadings <- transcript_loadings[[tx]]
            t.id <- gene.table[match(rownames(t.loadings), gene.table[,"symbol"]),1]
            eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive
            u_transcripts <- unique(eqtl.table$gene.id)
            inbred.effects <- matrix(NA, nrow = length(u_transcripts), ncol = 8)
            colnames(inbred.effects) <- names(CCcolors)
            rownames(inbred.effects) <- u_transcripts
            for(tr in 1:length(u_transcripts)){
                if(is.interactive){report.progress(tr, length(u_transcripts))}
                tr.idx <- which(eqtl.table$gene.id == u_transcripts[tr])
                tr.alleles <- eqtl.table[tr.idx,LETTERS[1:8]]
                tr.loading <- t.loadings[which(t.id == u_transcripts[tr])]
                tr.effects <- colMeans(tr.alleles*tr.loading)
                inbred.effects[tr,] <- tr.effects
            }
            tissue.inbred.effects[[tx]] <- inbred.effects
        }
        saveRDS(tissue.inbred.effects, inbred.effects.file)
    }else{
        tissue.inbred.effects <- readRDS(inbred.effects.file)
    }
}
```

The following plots show the predicted phenotype for each inbred
strain based on their collective transcriptional pressure.

```{r plot_predictions, results = "asis"}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "\n")
        inbred.means <- colMeans(tissue.inbred.effects[[tx]], na.rm = TRUE)
        mean.order <- order(inbred.means)
        barplot(inbred.means[mean.order], col = CCcolors[mean.order], main = tissue.names[tx])
        cat("\n\n")
    }
}
```

## Overall Effects

The effects overall are interesting, if a little confusing. 
The following plot shows that we predict the order of the 
three bears using this method. This shows the overall
phenotype merged across all tissues for the three bear
strains.

```{r overall_effects}
if(mediation.text == "complete_mediation"){
    three.bears <- c("CAST", "B6", "NZO")
    overall.strain.effect <- sapply(tissue.inbred.effects, function(x) colMeans(x, na.rm = TRUE))
    barplot(rowMeans(overall.strain.effect)[three.bears], 
        col = CCcolors[three.bears], ylab = "Phenotype")
}
```

Looking across all strains shows an interesting pattern.
NZO is predicted to be the outlier on the high end. 
PWK is predicted to be the outlier on the low end, but 
I'm not sure this is right. I think CAST is the most
resistant to these diet-induced traits. We have to 
remember, though, that our trait is a composite
trait, not any individual trait. 
[Mitok et al. (2017)](https://doi.org/10.1074/jbc.RA117.001102).
showed that CAST, PWK, and WSB had the least weight gain
on an HF diet, while NZO had the greatest gain, followed
by NOD and then B6. Glucose levels were not distinguishable
by strain. CAST had the lowest insulin levels across both 
sexes, while NZO levels were highest only in females. 
A/J had the second lowest insulin levels, and NOD had the
second highest. NZO males really lost their islets, but 
the NZO females retained theirs. The picture is complex
and depends on sex and other factors. 

Mitok et al. found that PWK and CAST mice have elevated
levels of tyrosine hydroxylase (Th) in their islets, 
which causes a blunted insulin response. Th is used in
the first step in catecholamine synthesis. Increased
Th leads to increased dopamine production and blunted
insulin secretion.


```{r overall_strains}
if(mediation.text == "complete_mediation"){
    effect.order <- order(rowMeans(overall.strain.effect))
    barplot(rowMeans(overall.strain.effect)[effect.order], 
        col = CCcolors[effect.order], ylab = "Phenotype")
}
```

If we look at breakout of effects by tissue in the three bears, it looks
as if the tissue that leads to the most variance in phenotype is the 
adipose tissue. Its transcription pattern pushes the NZO way up in 
phenotype space, and pushes the other two down relative to the overall
mean. 

For NZO, the adipose and liver contribute most to the high phenotype
levels. For CAST, its adipose and islet transcriptomes both help 
it be resistant. And for B6, the adipose transcriptome is the primary
source of resistance to diet-induced obesity and insulin resistance.

```{r tissue_effects}
if(mediation.text == "complete_mediation"){
    pheatmap(overall.strain.effect[rev(three.bears),], cluster_rows = FALSE)
}
```

If we look at all strains, the pattern breaks down a bit. We predict
that PWK will be more resistant than CAST, but I think CAST is actually
the more resistant strain.

Also, NOD has a big positive effect from the adipose transcriptome,
In Mitok et al, NOD was susceptible to diet-induced obesity, so this
does make sense. NOD also has the largest contribution from islets 
across all the strains, which we expect, since this is a diabetes 
model.

```{r all_strains, fig.width = 5, fig.height = 5}
if(mediation.text == "complete_mediation"){
    pheatmap(overall.strain.effect[rev(effect.order),], cluster_rows = FALSE)
}
```

## In silico complementation 

Can we predict the effect of a given allele swap into B6?
Since we can't do all possible allele swaps among strains, 
we will use B6 as the reference, since this is the preferred
model and best for CRISPR.

To further reduce the combinations we look at, we will only
consider the allele swap that is likely to have the biggest
effect. That is, the one with the largest difference in 
effect from B6.

To perform a swap, we simply replace the transcript effect 
calculated for B6 with the transcript effect calculated for
the strain with the maximum difference to B6. This does igore
kinship, and so we should do this swap only with transcript
effects estimated from local effects.


```{r allele_swaps, eval = FALSE}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        inbred.effects <- tissue.inbred.effects[[tx]]
        gene.names <- gene.table[match(rownames(inbred.effects), gene.table[,1]),"symbol"]
        b6.allele.pheno <- inbred.effects[,"B6",drop=FALSE]
        b6.start.pheno <- mean(b6.allele.pheno, na.rm = TRUE)
        num.alleles <- length(which(!is.na(b6.allele.pheno)))
        
        max.diff <- lapply(1:nrow(inbred.effects), 
            function(x) which.max(abs(inbred.effects[x,2]-inbred.effects[x,])))
        b6.swap.pheno <- lapply(1:length(max.diff), 
            function(x) b6.start.pheno-(b6.allele.pheno[x,1]/num.alleles)+(inbred.effects[x,max.diff[[x]]]/num.alleles))
        vals.used <- which(sapply(b6.swap.pheno, length) == 1)
        final.table <- cbind(unlist(b6.swap.pheno), unlist(max.diff)) 
        colnames(final.table) <- c("B6_swap_pheno", "allele")
        rownames(final.table) <- rownames(inbred.effects)[vals.used]

        b6.diff.pheno <- b6.start.pheno - final.table[,1]

        trans.table <- gene.table[match(rownames(final.table), gene.table[,1]),]
        u_chr <- unique(trans.table[,"chr"])
        ylim = c(min(b6.diff.pheno), max(b6.diff.pheno))
        layout(matrix(1:20, nrow = 1))
        par(mar = c(2,0,2,0))
        for(ch in c(1:19, "X")){
            ch.locale <- which(trans.table[,"chr"] == ch)
            plot(as.numeric(trans.table[ch.locale,"start"]), b6.diff.pheno[ch.locale], 
                type = "h", axes = FALSE, ylim = ylim, col = CCcolors[final.table[ch.locale,2]])
            mtext(side = 1, ch)
            abline(h = 0, col = "red")
            #axis(1)
        }
    }
}

```

## Allele effects by chromosome {.tabset .tabset-fade .tabset-pills}

```{r effects_by_chr, results = "asis", fig.width = 10, fig.height = 6}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")
        inbred.effects <- tissue.inbred.effects[[tx]]
        ylim <- c(min(inbred.effects, na.rm = TRUE), max(inbred.effects, na.rm = TRUE))
        inbred.gene.table <- gene.table[match(rownames(inbred.effects), gene.table[,1]),]
        for(ch in c(1:19, "X")){
            cat("####", ch, "\n")
            ch.locale <- which(inbred.gene.table[,"chr"] == ch)
            xlim <- c(min(as.numeric(inbred.gene.table[ch.locale,"start"])), max(as.numeric(inbred.gene.table[ch.locale,"start"])))
            plot.new()
            plot.window(xlim = xlim, ylim = ylim)
            for(a in 1:ncol(inbred.effects)){
                start.order <- order(as.numeric(inbred.gene.table[ch.locale,"start"]), decreasing = FALSE)
                points(as.numeric(inbred.gene.table[ch.locale[start.order],"start"]), 
                    inbred.effects[ch.locale[start.order],a], col = CCcolors[a], type = "h")
            }
            axis(1);axis(2)
            large.effects <- which(abs(inbred.effects[ch.locale,]) > 0.5, arr.ind = TRUE)
            if(nrow(large.effects) > 0){
                for(g in 1:nrow(large.effects)){
                    gene.row <- ch.locale[large.effects[g,1]]
                    max.effect <- which.max(abs(inbred.effects[gene.row,]))
                    text(as.numeric(inbred.gene.table[gene.row,"start"]), inbred.effects[gene.row,max.effect], 
                        labels = inbred.gene.table[gene.row,"symbol"], col = CCcolors[max.effect])
                }
            }
            mtext(paste("Chr", ch), side = 3, line = 2.5)
            cat("\n\n")
        }
        cat("\n\n")
    }
}

```