---
title: "High Dimensional Mediation"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow explores the possibility of using high-dimensional mediation
with the Cube data. 

There are several parameters to set.
    1. exp.name: will determine the directory in which the results are stored.
    2. merge.tissues: if TRUE, the transcription kernel is an average of 
        all independent tissue kernels.
    3. use.local.imputation: if TRUE uses locally imputed transcript values 
        to generate polygenic risk scores, if FALSE, uses transcripts imputed 
        with full genetic model (local + kinship)
        The full genetic model gives us better concordance with DO phenotypes,
        but we can't use kinship in the model if we are going to predict phenotypes
        in other populations, like inbred founders, or the CC-RIX.

```{r get_args}
args <- commandArgs(trailingOnly=T)

#args <- c(1,1,0,0,0) #merged tissues, local imputation, reactive model
#args <- c(1,1,0,1,0) #merged tissues, local imputation, mediation model
#args <- c(0,0,0,0,0) #sep tissues, full imputation, reactive model
#args <- c(0,0,0,1,0) #sep tissues, full imputation, mediation model

merge.tissues <- as.logical(args[1]) #if TRUE tissue transcriptome kernels are averaged. Otherwise they are used separtely
use.local.imputation <- as.logical(args[2]) #if TRUE, locally imputed transcripts are used to generate polytranscriptomic risk scores. Otherwise transcripts imputed with the full genetic model are used.
weight.adjusted <- as.logical(args[3]) #if TRUE, body weight is adjusted out of the phenotypes and transcriptome before running mediation
complete.mediation <- as.logical(args[4]) #if TRUE use a mediation network. If FALSE use a reactive network
delete_previous <- as.logical(args[5])

merge.text.options <- c("tissue_sep", "tissue_together")
imputation.options <- c("full_imp", "local_imp")
weight.options <- c("_", "weight_adjusted")
mediation.options <- c("reactive", "complete_mediation")

merge.text <- merge.text.options[(as.numeric(merge.tissues)+1)]
imp.text <- imputation.options[(as.numeric(use.local.imputation)+1)]
weight.text <- weight.options[(as.numeric(weight.adjusted)+1)]
mediation.text <- mediation.options[(as.numeric(complete.mediation)+1)]

exp.name <- paste(merge.text, imp.text, weight.text, mediation.text, sep = "-")

```

This run had the following settings:

* Tissue treatment: `r merge.text`
* Imutation used: `r imp.text`
* Weight adjustment: `r weight.text`
* Mediation type: `r mediation.text`

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "High_Dim_Med", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir, recursive = TRUE)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "Matrix", "RGCCA", 
    "bnstruct", "igraph", "corpcor", "GOSemSim", "cluster", "org.Mm.eg.db",
    "grid", "wordcloud", "stringr")
load_libraries(all.packages, personal.library = TRUE)
```

```{r container, eval = FALSE}
load_libraries(c("containerit", "here", "rmarkdown")) #add other necessary packages
doc.obj <- dockerfile()
write(doc.obj)
```

## Read in data

Load data from QTL viewer.

```{r read_data}
tissue.data <- load(here("Data", "dataset.DO.CUBE.multissue.RData"))
tissue.names <- gsub("dataset.DO.Cube.", "", tissue.data[1:4])

data.set.names <- lapply(1:length(tissue.names), 
    function(x) paste0("dataset.DO.Cube.", tissue.names[x]))
gene.table <- as.matrix(unique(Reduce("rbind", lapply(data.set.names, 
    function(x) get(x)$annot.mrna))))

covar <- lapply(data.set.names, function(x) get(x)$covar.matrix)
```


## Read phenotypes and adjust

Adjust phenotype data for DO generation, sex, and diet days.

```{r pheno}
pheno <- as.matrix(read.csv(here("Data", "DO_clinical_phenotypes.csv"), stringsAsFactors = FALSE))
num.pheno <- apply(pheno[,11:(ncol(pheno)-1)], 2, as.numeric)
rownames(num.pheno) <- pheno[,1]

max.n <- which.max(sapply(covar, nrow)) #adjust with the largest covariate matrix
adj.covar <- Reduce("cbind", get.xz(covar[[max.n]], num.pheno[,"diet_days",drop=FALSE]))
adj.pheno <- adjust(num.pheno[,2:ncol(num.pheno)], adj.covar) #remove diet days from num.pheno
```


## Adjust transcripts

Adjust transcripts for the same covariates.
Also adjust out weight from phenotypes and expression if specified.

```{r adj_expr}
tissue.expr <- lapply(data.set.names, function(x) get(x)$data$norm)
tissue.adj.expr <- lapply(tissue.expr, function(x) adjust(x, adj.covar))

#adjust wei
if(weight.adjusted){
    #try adjusting out weight
    weight.col <- grep("weight", colnames(adj.pheno))
    non.weight.col <- setdiff(1:ncol(adj.pheno), weight.col)
    weight <- adj.pheno[,weight.col]

    adj.pheno <- adjust(adj.pheno[,non.weight.col], weight)    
    tissue.adj.expr <- lapply(tissue.adj.expr, function(x) adjust(x, weight))
}

```


## Scale transcriptome and phenotypes

to mean 0 and std 1 by gene

```{r scale}
scaled.expr <- lapply(tissue.adj.expr, function(x) apply(x, 2, scale))
for(i in 1:length(scaled.expr)){
    rownames(scaled.expr[[i]]) <- rownames(tissue.adj.expr[[i]])
}
scaled.pheno <- apply(adj.pheno, 2, scale)
rownames(scaled.pheno) <- rownames(adj.pheno)

```


```{r weight, eval = FALSE}
cols <- categorical_pal(8)
weight <- num.pheno[,18:20]
sex <- pheno[match(rownames(weight), pheno[,1]),"sex"]
sex.col <- rep(cols[2], length(sex))
sex.col[which(sex == "M")] <- cols[3]

sex.order <- order(sex, decreasing = TRUE)
weight.diff <- weight[,3]/weight[,2]

pdf("~/Desktop/pheno_hist.pdf", width = 5, height = 5)
hist_with_points(weight.diff[sex.order], breaks = 100, col = sex.col[sex.order], 
    main = "Proportion Weight Change", xlab = "Proportion Weight Change", 
    ylim = c(0,20))
    abline(v = 1)
    legend("topleft", col = cols[c(2,3)], pch = 16, legend = c("Female", "Male"))

for(i in 1:ncol(adj.pheno)){
    hist_with_points(num.pheno[sex.order,i], breaks = 100, col = sex.col[sex.order], 
        main = colnames(adj.pheno)[i], xlab = colnames(adj.pheno)[i])
    legend("topleft", col = cols[c(2,3)], pch = 16, legend = c("Female", "Male"))


}
dev.off()


plot(density(weight.diff[f.locale]), col = cols[2])
points(density(weight.diff[m.locale]), col = cols[3], type = "l")

scaled.pheno <- apply(adj.pheno, 2, scale)
#pheatmap(scaled.pheno, show_rownames = FALSE)

pheno.decomp <- plot.decomp(cov(t(scaled.pheno), use = "pairwise.complete.obs"), 
    pc = 20, plot.results = FALSE)
pheno.decomp <- plot.decomp(scaled.pheno, pc = 20, plot.results = FALSE)
decomp.cor <- matrix(NA, nrow = 20, ncol = 20)
rownames(decomp.cor) <- paste0("PC", 1:20)
colnames(decomp.cor) <- colnames(scaled.pheno)

trait.loadings <- pheno.decomp$v
var.exp <- pheno.decomp$var.exp*100
rownames(trait.loadings) <- colnames(scaled.pheno)
colnames(trait.loadings) <- paste0("PC", 1:20)

trait.order <- c(1:3, c(4:20)[order(colnames(scaled.pheno)[4:20])])
layout(matrix(c(1,2,0,3), ncol = 2, byrow = FALSE), heights = c(0.4, 1), widths = c(1, 0.3))
par(mar = c(0,7.6,1,0.8))
barplot_with_num(round(var.exp, 1), ylab = "% Var. Exp.", text.srt = 45, adj = 0)
par(mar = c(3,8,0,1))
imageWithText(trait.loadings[trait.order,], show.text = FALSE, use.pheatmap.colors = TRUE,
    row.text.shift = 0.05, col.text.shift = 0.05)
par(mar = c(19,2,1,8))
imageWithTextColorbar(trait.loadings, use.pheatmap.colors = TRUE, cex = 1)

for(i in 1:nrow(decomp.cor)){
    for(j in 1:ncol(decomp.cor)){
        cor.val <- cor(pheno.decomp$u[,i], scaled.pheno[,j], use = "pairwise.complete.obs")
        decomp.cor[i,j] <- decomp.cor[j,i] <- cor.val
    }
}
pheatmap(decomp.cor, cluster_rows = FALSE, cluster_cols = FALSE)


layout(matrix(1:20, nrow = 4, ncol = 5))
par(mar = c(1,1,1,1))
for(i in 1:ncol(scaled.pheno)){
    plot(pheno.decomp$u[,2], scaled.pheno[,i], main = colnames(scaled.pheno)[i])
}

gene.name = "Lep"
trait.name = "Ins_tAUC"
gene.id <- gene.table[match(gene.name, gene.table[,"symbol"]),1]
gene.idx <- lapply(scaled.expr, function(x) which(colnames(x) == gene.id))
gene.expr <- lapply(1:length(gene.idx), function(x) if(length(gene.idx[[x]]) > 0){scaled.expr[[x]][,gene.idx[[x]]]})
tx = 4
plot.with.model(gene.expr[[tx]], scaled.pheno[names(gene.expr[[tx]]),trait.name], 
    xlab = paste(gene.name, "Expression in", tissue.names[tx]), 
    ylab = trait.name, report = "cor.test")

eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive
gene.idx <- which(eqtl.table[[1]] == gene.id)


```


## Build transcriptomic kernel

```{r kernelize}
Kt <- lapply(scaled.expr, function(x) x %*% t(x) / dim(x)[2])

if(merge.tissues){
    #make a single Kt matrix that is the average of all expression kernels
    #it is repeated for all tissues, so we don't need to change the structure
    #of the analysis
    #This will represent the structure of expression across all tissues
    common.ind <- Reduce("intersect", lapply(Kt, rownames))
    total.Kt <- Reduce("+", lapply(Kt, function(x) x[common.ind, common.ind]))
    Kt <- lapply(1:length(tissue.names), function(x) total.Kt/length(tissue.names))
    names(Kt) <- tissue.names
}
```

## Kinship matrix

```{r kin}
kin.file <- here("Data", "overall.kinship.RDS")
if(!file.exists(kin.file)){
    Kg = calc_kinship(genoprobs, "overall")
    saveRDS(Kg, kin.file)
}else{
    Kg <- readRDS(kin.file)
}
```

Subset and center kinship matrix based on DO generation.

```{r subset}
do_gen <- lapply(covar, function(x) x[,2:ncol(x)])
gen_cent = lapply(do_gen, function(x) x %*% Diagonal(dim(x)[2], 1 / colSums(x)) %*% t(x)) # Centering matrix

#subset kinship matrix to match the individuals in each tissue.
#remove DO generation from kinship matrix
Kg_sub = lapply(1:length(gen_cent), function(x) Kg[rownames(gen_cent[[x]]), rownames(gen_cent[[x]])])
Kg_cent = lapply(1:length(gen_cent), function(x) Kg_sub[[x]] - gen_cent[[x]] %*% Kg_sub[[x]] - Kg_sub[[x]] %*% gen_cent[[x]] + gen_cent[[x]] %*% Kg_sub[[x]] %*% gen_cent[[x]])
```

## Build phenotype kernel

```{r pheno_kernel}
#select a subset of phenotypes
#sub.pheno <- scaled.pheno[,c("num_islets", "Ins_per_islet", "WPIC")]
#sub.pheno <- scaled.pheno[,c("TG_6wk", "TG_10wk", "TG_14wk")]
sub.pheno <- scaled.pheno

#there are a few missing values. Impute these
sub.pheno <- knn.impute(sub.pheno)
Kp = sub.pheno %*% t(sub.pheno) / dim(sub.pheno)[2]
```

## Perform high-dimensional mediation


```{r mediation}
transcript_loading_file <- file.path(results.dir, "Loadings_Transcripts.RDS")
trait_loading_file <- file.path(results.dir, "Loadings_Traits.RDS")
model_file <- file.path(results.dir, "Model_Scores.RDS")

if(!file.exists(transcript_loading_file) || delete_previous){
    transcript_loadings <- trait_loadings <- model_scores <- vector(mode = "list", length = length(tissue.names))
    names(transcript_loadings) <- names(trait_loadings) <- names(model_scores) <- tissue.names
    flags <- rep(NA, length(tissue.names))
    stopping.reasons <- rep(NA, length(tissue.names))
    for(tx in 1:length(tissue.names)){
        if(is.interactive){cat("\n", tissue.names[tx], "\n")}
        
        #assign matrices to proper positions
        if(complete.mediation){
            #transcripts are the mediator
            mediator.kernel = Kt[[tx]]; transcript.col <- "Mediator"
            #phenotypes are the outcome
            outcome.kernel = Kp; trait.col <- "Outcome"
        }else{
            #phenotypes are the mediator
            mediator.kernel = Kp;trait.col <- "Mediator" 
            #transcripts are the outcome
            outcome.kernel = Kt[[tx]]; transcript.col = "Outcome" 
        }
        
        fit.result <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
            mediating.matrix = mediator.kernel, outcome.matrix = outcome.kernel, 
            min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
            verbose = is.interactive, kernel.c = TRUE, kernel.m = TRUE, 
            kernel.o = TRUE)

        #test <- scan1(genoprobs, fit.result[[1]][,2])
        #plot(test, map = map)

        model_scores[[tx]] <- fit.result[[1]]
        flags[tx] <- fit.result[[2]]
        stopping.reasons[tx] <- fit.result[[3]]

        #calculate transcript loadings
        #This is the correlation between the scaled expression
        #and the transcript score found by the model
        expr_cor <- calc_loadings(model_scores[[tx]][,transcript.col,drop = FALSE], 
            scaled.expr[[tx]])
        
        #convert ensembl Ids to gene names and save loadings
        transcript.names = gene.table[match(rownames(expr_cor), gene.table[,1]),"symbol"]
        rownames(expr_cor) = transcript.names
        transcript_loadings[[tx]] <- expr_cor

        #do the same for phenotype loadings
        trait_cor <- calc_loadings(model_scores[[tx]][,trait.col,drop = FALSE], 
            sub.pheno)
        trait_loadings[[tx]] <- trait_cor
    }

    saveRDS(transcript_loadings, transcript_loading_file)
    saveRDS(trait_loadings, trait_loading_file)
    saveRDS(model_scores, model_file)
}else{
    transcript_loadings <- readRDS(transcript_loading_file)
    trait_loadings <- readRDS(trait_loading_file)
    model_scores <- readRDS(model_file)
}

```

```{r bmediatr, eval = FALSE}
for(tx in 1:length(tissue.names)){
    X <- model_scores[[tx]][,1,drop=FALSE]
    M <- model_scores[[tx]][,2,drop=FALSE]
    Y <- model_scores[[tx]][,3,drop=FALSE]
    
    test_med <- bmediatR(y = Y, M = M, X = X,
        ln_prior_c = "reactive",
        options_X = list(sum_to_zero = FALSE, center = FALSE, scale = FALSE))
    med_prob <- get_posterior(test_med, mediator_id = "Mediator")
    par(mar = c(8, 4, 4, 4));barplot(unlist(med_prob[1,c(5,8,9,12,13)]), las = 2)
}

```

## Causal Networks {.tabset .tabset-fade .tabset-pills}

The following plots show the partial correlations between
the causal factor, the mediator, and the outcome. Line
width corresponds to partial correlation, and line color
corresponds with the sign of the partial correlation. Orange
is negative and green is positive.

```{r plot_nets, results = "asis"}
for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "\n")
    tx.pcor <- pcor.shrink(model_scores[[tx]], verbose = FALSE)
    tx.pcor[lower.tri(tx.pcor, diag = TRUE)] <- 0
    net <- graph_from_adjacency_matrix(tx.pcor, weighted = TRUE, mode = "directed")
    e.weight <- E(net)$weight
    plot(net, edge.width = abs(e.weight*10), edge.color = sign(e.weight)+2, 
        main = tissue.names[tx], layout = layout_on_grid, edge.label = signif(e.weight, 2),
        edge.label.cex = 1.5, vertex.size = 30)
    cat("\n\n")
}
```

## Permutations {.tabset .tabset-fade .tabset-pills}

Run permutations to calulate a null distribution for the path
coefficient. This is the correlation between the causal matrix
and the outcome matrix. To do this, we shuffle the names of the
mediator kernel. This decorrelates the 


```{r perm}

if(merge.tissues){
    max.tx <- 1
}else{
    max.tx <- 4
}

perm.file <- file.path(results.dir, "Permutations.RDS")

if(!file.exists(perm.file) || delete_previous){
    num.perm = 100
    all.perms <- vector(mode = "list", length = max.tx)

    for(tx in 1:max.tx){

        if(complete.mediation){
            #for the mediation model, the transcript kernel is the mediator
            mediator.kernel = Kt[[tx]]
            outcome.kernel = Kp
        }else{
            #for the reactive model, the phenotype is the mediator
            mediator.kernel = Kp
            outcome.kernel = Kt[[tx]]
        }
        
        perm_stats <- matrix(NA, nrow = num.perm, ncol = 4)
        colnames(perm_stats) <- c("path_coef", "X-M", "M-Y", "X-Y")
        
        for(p in 1:num.perm){

            if(is.interactive){report.progress(p, num.perm)}
            
            #permute the mediator
            perm_names <- sample(rownames(mediator.kernel))
            perm_mediator <- mediator.kernel
            rownames(perm_mediator) <- colnames(perm_mediator) <- perm_names

            perm_scores <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
                mediating.matrix = perm_mediator, outcome.matrix = outcome.kernel, 
                min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
                verbose = FALSE, kernel.c = TRUE, kernel.m = TRUE, 
                kernel.o = TRUE)
        
            perm_stats[p,] <- path_coef(perm_scores[[1]])
        }

    all.perms[[tx]] <- perm_stats
    }

    saveRDS(all.perms, perm.file)

}else{
    all.perms <- readRDS(perm.file)
}
```

The following plots show null distributions for each 
tissue, unless tissues were merged, and then only one
set of null distribution is shown. 

The dot plot shows the 
relationship between the X-M correlation and the M-Y
correlation. The permutations show that you can make
one of them quite high, but getting both high is very
difficult and can only be done with the true data.

The histogram shows the null distribution of the path
coefficient along with the observed path coeffient.
The observed path coefficient is well outside the 
null distribution.

```{r plot_perm, results = "asis", fig.height = 5, fig.width = 5}

for(tx in 1:max.tx){
    if(max.tx == 1){
        cat("### All Tissues\n")
    }else{
        cat("###", tissue.names[tx], "\n")
    }
    
    tissue.path.stats <- path_coef(model_scores[[tx]])
    tissue.path.coef <- tissue.path.stats[1]

    axis.max <- max(c(all.perms[[tx]][,c("X-M", "M-Y")], tissue.path.stats[c("X-M", "M-Y")]))
    axis.min <- min(c(all.perms[[tx]][,c("X-M", "M-Y")], tissue.path.stats[c("X-M", "M-Y")]))

    plot(all.perms[[tx]][,"X-M"], all.perms[[tx]][,"M-Y"], xlim = c(axis.min, axis.max), 
        ylim = c(axis.min, axis.max), xlab = "X-M correlation", ylab = "M-Y correlation")
    points(tissue.path.stats["X-M"], tissue.path.stats["M-Y"], 
        col = "red", pch = 16)
    abline(0,1)

    path.min <- min(c(all.perms[[tx]][,"path_coef"], tissue.path.coef))
    path.max <- max(c(all.perms[[tx]][,"path_coef"], tissue.path.coef))
    hist(all.perms[[tx]][,"path_coef"], xlim = c(path.min, path.max), 
        main = "Path Coef. Permutations", xlab = "")
    abline(v = tissue.path.coef, col = "red")

    cat("\n\n")
}
```


## Correlation Plots {.tabset .tabset-fade .tabset-pills}

The following plots show the partial correlations between 
the pairs of scores for all model scores. With perfect 
mediation of X -> M -> Y, the partial correlation between 
X and Y should be 0. We get pretty close here.

```{r plot_cor, results = "asis", fig.height = 6, fig.width = 6}

for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "\n")
    #find the correlations between the scores
    curr_scores <- model_scores[[tx]]
    
    #change from generic names to specific names
    if(complete.mediation){
        colnames(curr_scores) <- c("Genome", "Transcriptome", "Traits")
    }else{
        colnames(curr_scores) <- c("Genome", "Traits", "Transcriptome")
    }
    
    path.coef <- path_coef(curr_scores)

    all.pairs <- pair.matrix(1:ncol(curr_scores))
    adj.var <- apply(all.pairs, 1, function(x) setdiff(1:3, x))
    #pdf("~/Desktop/test.pdf") 
    par(mfrow = c(2,2))
    for(i in 1:nrow(all.pairs)){
        var1 <- all.pairs[i,1]
        var2 <- all.pairs[i,2]
        adj.by <- adj.var[i]
        plot.with.model(adjust(curr_scores[,var1,drop=FALSE], curr_scores[,adj.by,drop=FALSE]), 
            adjust(curr_scores[,var2,drop=FALSE], curr_scores[,adj.by,drop=FALSE]),
            xlab = colnames(curr_scores)[all.pairs[i,1]], 
            ylab = colnames(curr_scores)[all.pairs[i,2]], report = "cor.test")
    }
    #test <- check_signs(curr_scores)
    #pairs(test[[1]])

    #pairs(curr_scores, main = paste(tissue.names[tx], "\nPath  Coef:", round(path.coef, 3)))
    cat("\n\n")
}

```


## Enrichment Plots {.tabset .tabset-fade .tabset-pills}

The following plots show the functional enrichment for transcripts
at the top and bottom of each list for each tissue.

This section also writes out the top and bottom transcripts
for analysis in CMAP.

```{r enrichment}
enrich.file <- file.path(results.dir, "Top_Bottom_Enrichment.RDS")
hum.mus.ortho <- as.matrix(read.delim(here("Data", "human.mouse.orthologs.txt"), 
    stringsAsFactors = FALSE))

if(!file.exists(enrich.file) || delete_previous){
    all.enrich <- vector(mode = "list", length = length(tissue.names))
    names(all.enrich) <- tissue.names

    top.n <- 150
    for(tx in 1:length(tissue.names)){
        top.genes <- sort(transcript_loadings[[tx]][,1], decreasing = TRUE)[1:top.n]
        top.enrich <- gost(names(top.genes), organism = "mmusculus")
        
        top.id <- gene.table[match(names(top.genes), gene.table[,"symbol"]),1]
        top.hum.id <- mouse_to_human_entrez(top.id, hum.mus.ortho)

        bottom.genes <- sort(transcript_loadings[[tx]][,1], decreasing = FALSE)[1:top.n]
        bottom.enrich <- gost(names(bottom.genes), organism = "mmusculus")
        bottom.id <- gene.table[match(names(bottom.genes), gene.table[,"symbol"]),1]
        bottom.hum.id <- mouse_to_human_entrez(bottom.id, hum.mus.ortho)
        
        cmap.table <- cbind(top.hum.id[,"Human.Entrez"], bottom.hum.id[,"Human.Entrez"])
        colnames(cmap.table) <- c("Positive", "Negative")
        write.table(cmap.table, 
            file.path(results.dir, paste0("CMAP_Human_Entrez_", tissue.names[tx], ".txt")),
            quote = FALSE, row.names = FALSE, sep = "\t")

        all.enrich[[tx]] <- list("top" = top.enrich, "bottom" = bottom.enrich)
    }
    saveRDS(all.enrich, enrich.file)
}else{
    all.enrich <- readRDS(enrich.file)
}

```

```{r plot_enrichment, results = "asis", fig.width = 10, fig.height = 5, warning = FALSE, message = FALSE}
for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")

    cat("#### Positive Loadings\n")
    par(mfrow = c(1,2))
    plot.enrichment.wordcloud(enrichment = all.enrich[[tx]]$top, 
        order.by = "p_value",
        plot.label = paste(tissue.names[tx], "Positive Loadings"), 
        num.terms = 25, max.term.size = 5000)

    cat("\n#### Negative Loadings\n")
    par(mfrow = c(1,2))
    plot.enrichment.wordcloud(all.enrich[[tx]]$bottom, 
        plot.label = paste(tissue.names[tx], "Negative Loadings"), 
        num.terms = 25, max.term.size = 5000)

    cat("\n\n")
}
```

## Trait loadings

The following plots show the loadings on traits for 
each tissue.

This shows either 

* which traits are most affected by the genome -> transcriptome path (complete mediation)
* Or which traits are most affecting the transcriptome (reactive)

```{r trait_loadings, fig.width = 7, fig.height = 6}
all.loadings <- Reduce("cbind", trait_loadings)
colnames(all.loadings) <- tissue.names

if(merge.tissues){
    par(mar = c(4, 8, 4, 2))
    barplot(sort(all.loadings[,1]), las = 2, horiz = TRUE, xlab = "Trait Loading")
}else{
    pheatmap(all.loadings)
}

```


## Polygenic risk scores  {.tabset .tabset-fade .tabset-pills}

If we are mediating the effect of the genome on phenotype with 
the transcriptome, each transcript has a loading for how much 
it affects the phenotypes and eQTL that regulate its transcription. 
For a given individual mouse, their position in trait space will 
depend on the amount that transcript affects the phenotype, and the 
degree to which the transcript is up or downregulated in that particular 
individual based on genotype.

Can we generate a transcript score for each individual based on 
their genotype(s) at the eQTL loci?

Note that this only makes sense to do if we are using the 
transcriptome to mediate the effect of the genome on phenotype. 
We cannot make trait predictions based on eQTL if we are 
running the reactive model.

Each transcript has some effect on the composite phenotype, 
based on its loading. Here we multiply the transcript
loadings by each imputed transcript. This gives us the
contribution of each transcript to the overall phenotype
in each individual. This is the transcriptional pressure
each gene is putting on the phenotype. We can add up, or
take the mean of the transcriptional pressure across the 
whole genome to estimate where the individual lives in 
phenotype space. 

If we are using the transcriptome to mediate the effects of
the genome on the phenome, multiple plots will be created in
the appropriate results folder. They are too diverse to put into
the html. Filenames and descriptions are the following:

1. Population_Pressure_Enrichments_tissue_name
    We calculated population-level transcriptomic pressure for each
    transcript in each tissue. These plots show the enrichments of the
    top and bottom of each list

2. Individual_Level_Transcriptional_Pressure_tissue_name
    A histogram of the transcriptomic pressures across the transcriptome
    for a single animal. The animal chosen is the one with the lowest
    predicted phenotype based on transcriptomic pressure.

3. Transcriptional_Pressure_Distribution_tissue_name
    The transcriptomic pressure distributions across all animals
    shown with their phenotypic prediction based on the mean of the
    transcriptomic score. When we do the tissues separately, there 
    is visible difference between the top and bottom animals. It
    is not really visible when the tissues are merged.

4. Transcriptional_Pressure_v_Trait_PC_tissue_name
    This figure plots the predicted phenotype based on transcriptomic
    pressure vs. the first PC of the trait matrix.

5. Clustered_Enrichment_tissue_name
    We calculated functional enrichments for strongest effect genes
    in each individual. There are too many enrichments to show, so
    we clustered them based on GO term similarity and show the results
    here. I was hoping to see some clustering of functional enrichments 
    that might be able to subset the groups, but there doesn't seem to
    be a relationship between functional enrichments and the final predicted
    phenotype score. Plots in this pdf plot up and down enrichmen matrices
    each two times. Once sorted by predicted phenotype score, and once sorted
    by enrichments.

6. Large_Effect_Transcript_Decomp_tissue_name
    These plots show the first two PCs of the actual expression of the 
    transcripts with the largest population level transcriptomic pressure
    scores. We show the decomposition both by individuals and by transcripts.
    The transcripts are colored by population-level transcriptomic pressure,
    and the individuals are colored by predicted phenotype score.


The genes that have large effects across multiple organisms seem to be rather
obscure. Some are known diabetes genes, but most of them seem pretty irrelevant.

```{r gosem}
mf <- godata('org.Mm.eg.db', ont="MF", computeIC=TRUE)
cc <- godata('org.Mm.eg.db', ont="CC", computeIC=TRUE)
bp <- godata('org.Mm.eg.db', ont="BP", computeIC=TRUE)


get_sim_mat <- function(go.terms){

    #classify go terms
    mf.idx <- which(names(go.terms) %in% mf@geneAnno$GO)
    cc.idx <- which(names(go.terms) %in% cc@geneAnno$GO)
    bp.idx <- which(names(go.terms) %in% bp@geneAnno$GO)
    
    bp.sim <- goSim(names(go.terms)[bp.idx], names(go.terms)[bp.idx], 
        semData = bp, measure = "Rel")
    bp.sim.mat <- matrix(bp.sim, nrow = length(bp.idx), ncol = length(bp.idx))
    rownames(bp.sim.mat) <- colnames(bp.sim.mat) <- go.terms[bp.idx]
    #pheatmap(bp.sim.mat)
    
    cc.sim <- goSim(names(go.terms)[cc.idx], names(go.terms)[cc.idx], 
        semData = cc, measure = "Rel")
    cc.sim.mat <- matrix(cc.sim, nrow = length(cc.idx), ncol = length(cc.idx))
    rownames(cc.sim.mat) <- colnames(cc.sim.mat) <- go.terms[cc.idx]
    #pheatmap(cc.sim.mat)

    mf.sim <- goSim(names(go.terms)[mf.idx], names(go.terms)[mf.idx], 
        semData = mf, measure = "Rel")
    mf.sim.mat <- matrix(mf.sim, nrow = length(mf.idx), ncol = length(mf.idx))
    rownames(mf.sim.mat) <- colnames(mf.sim.mat) <- go.terms[mf.idx]
    #pheatmap(mf.sim.mat)

    result <- list("BP" = bp.sim.mat, "CC" = cc.sim.mat, "MF" = mf.sim.mat)
    return(result)
}
```

```{r summarize_enrichment_fun}
summarize_enrichment <- function(individual.enrichments, max.term.size = 5000,
    max.char = 100, enrich.sig.thresh = 1e3, top.n.terms = 5, min.cl = 2, 
    max.cl = 20){

    enrich.mat <- plot.enrichment.group(individual.enrichments, sort.by = "default", 
            max.term.size = max.term.size, plot.results = FALSE, max.char = max.char)
    
    #add back any individuals that didn't have any significant enrichments
    missing.names <- setdiff(colnames(transcript.pressure), colnames(enrich.mat)) 
    no.enrich.mat <- matrix(0, nrow = nrow(enrich.mat), ncol = length(missing.names))
    colnames(no.enrich.mat) <- missing.names
    enrich.mat <- cbind(enrich.mat, no.enrich.mat)
        
    #filter for the most significant terms
    sig_vals  <- apply(enrich.mat, 1, max)
    to_keep <- which(sig_vals > -log10(enrich.sig.thresh))
    sig.enrich.mat <- enrich.mat[to_keep,]
    names(rownames(sig.enrich.mat)) <- names(rownames(enrich.mat)[to_keep])    

    ind.sim <- get_sim_mat(go.terms = rownames(enrich.mat))
    
    clustered_enrich <- summarize_go_mat(go_term_mat = enrich.mat, 
        go_term_sim = ind.sim, min.cl = min.cl, max.cl = max.cl,
        top.n.terms = top.n.terms, use.pc.mat = TRUE, pc = 2, 
        plot.results = FALSE)

    return(clustered_enrich)        
}

#This function subsets an enrichment matrix to only the 
#terms that are significantly correlated with phenotype
#score. It then clusters th
subset_enrichment <- function(individual.enrichments, max.term.size = 5000,
    max.char = 100, enrich.sig.thresh = 1e3, min.cl = 2, max.cl = 20, 
    sig.val = 0.05){

    enrich.mat <- plot.enrichment.group(individual.enrichments, sort.by = "default", 
            max.term.size = max.term.size, plot.results = FALSE, max.char = max.char)
    
    #add back any individuals that didn't have any significant enrichments
    missing.names <- setdiff(colnames(transcript.pressure), colnames(enrich.mat)) 
    no.enrich.mat <- matrix(0, nrow = nrow(enrich.mat), ncol = length(missing.names))
    colnames(no.enrich.mat) <- missing.names
    enrich.mat <- cbind(enrich.mat, no.enrich.mat)
        
    #filter for the most significant terms
    sig_vals  <- apply(enrich.mat, 1, max)
    to_keep <- which(sig_vals > -log10(enrich.sig.thresh))
    sig.enrich.mat <- enrich.mat[to_keep,]
    names(rownames(sig.enrich.mat)) <- names(rownames(enrich.mat)[to_keep])

    common.names <- intersect(colnames(transcript.pressure), colnames(sig.enrich.mat))
    mean.pressure <- colMeans(transcript.pressure[,common.names])
    
    bin.enrich <- sig.enrich.mat[,common.names]
    bin.enrich[which(bin.enrich > 0)] <- 1    
    ordered.score <- colMeans(transcript.pressure[,common.names])
    aov.p <- apply(bin.enrich, 1, function(x) summary(aov(ordered.score~x))[[1]][1,"Pr(>F)"])

    sig.cor <- which(aov.p <= sig.val)

    sub.mat <- sig.enrich.mat[sig.cor,,drop=FALSE]
    max.cl <- min(c(20, nrow(sub.mat)-1))
    term_cl <- kmeans_cluster_mat(sub.mat, max.cl = max.cl)
    ind_cl <- kmeans_cluster_mat(t(sub.mat), max.cl = max.cl)

    #pdf("~/Desktop/test.pdf", width = 10, height = 10)
    #pheatmap(sub.mat[order(term_cl),order(ind_cl)], cluster_row = FALSE, cluster_col = FALSE)
    #dev.off()

    return(sub.mat[order(term_cl), order(ind_cl)])  
}
```

```{r polygenic_risk_score, warning = FALSE, message = FALSE}

if(mediation.text == "complete_mediation"){
    #read in the imputed transcripts generated by Matt
    if(use.local.imputation){
        tissue.imp.gen <- readRDS(here("Data", "imputed", paste0("Adjusted_Expression_DO_imputed_local.RDS")))
    }else{
        tissue.imp.gen <- readRDS(here("Data", "imputed", paste0("Adjusted_Expression_DO_imputed_genetic.RDS")))
    }

    #Get the first principle componenet of the phenotype matrix
    trait.decomp <- plot.decomp(sub.pheno, plot.results = FALSE, pc = 3)
    trait.pc <- trait.decomp$u
    rownames(trait.pc) <- rownames(sub.pheno)

    large.effect.size = 0.5 #minimum effect size that is considered large
    enrichment.num <- 250 #number of transcripts to use to look for enrichments of top and bottom of lists
    enrich.sig.thresh = 1e-3 #maximum p value for significant enrichments.
    num.common.genes <- 150

    #For each tissue, calculate the pressure
    #exerted by each transcript on the phenotype
    common.large.effect.genes <- pop.pressure <- vector(mode = "list", length = length(tissue.names))
    names(common.large.effect.genes) <- names(pop.pressure) <- tissue.names
    for(tx in 1:length(tissue.names)){
    
        trans.load <- transcript_loadings[[tx]]
        transcript.id <- gene.table[match(rownames(trans.load), gene.table[,"symbol"]),"gene.id"]
        rownames(trans.load) <- transcript.id
        
        common.transcripts <- intersect(transcript.id, colnames(tissue.imp.gen[[tx]]))
        transcript.pressure <- apply(tissue.imp.gen[[tx]][,common.transcripts], 1, function(x) x*trans.load[common.transcripts,])
        expr.names <- gene.table[match(rownames(transcript.pressure), gene.table[,1]),"symbol"]
        rownames(transcript.pressure) <- expr.names
        ind.score <- colMeans(transcript.pressure)
        mean.order <- order(ind.score)

        #also get a population-level transcriptomic pressure for each transcript
        #these are transcripts that are affecting the trait through their 
        #transcription AND have some population-level variation in transcription
        #these are the not necessarily the genes that are central to the disease
        #but ones that can vary enough to affect variation in outcome across 
        #individuals.
        #get imputed R2 
        tx.r2 <- apply(tissue.imp.gen[[tx]], 2, var)
        pop.pressure[[tx]] <- tx.r2[common.transcripts]*trans.load[common.transcripts,1]
        #hist(pop.pressure, breaks = 100)
        pop.neg.pressure <- gost(names(sort(pop.pressure[[tx]]))[1:enrichment.num], 
            organism = "mmusculus")
        pop.pos.pressure <- gost(names(sort(pop.pressure[[tx]], decreasing = TRUE))[1:enrichment.num], 
            organism = "mmusculus")

        pdf(file.path(results.dir, paste0("Population_Pressure_Enrichments_", tissue.names[tx], ".pdf")), width = 10, height = 5)
        par(mfrow = c(1,2))
        plot.enrichment.wordcloud(pop.pos.pressure, max.term.size = 5000,
            plot.label = "Transcripts with population-level positive pressure")
        plot.enrichment.wordcloud(enrichment = pop.neg.pressure, max.term.size = 5000,
            plot.label = "Transcripts with population-level negative pressure")
        dev.off()

        #par(mfrow = c(1,2))
        pdf(file.path(results.dir, paste0("Individual_Level_Transcriptional_Pressure_", tissue.names[tx], ".pdf")), width = 5, height = 5)
        hist(transcript.pressure[,mean.order[1]], breaks = 100, 
            main = "Polygenic Transcriptional Pressure\non Phenotype Space\nFor Lowest Individual",
            xlab = "Transcriptional Pressure", ylab = "Gene Count")
        abline(v = mean(transcript.pressure[,mean.order[1]]), col = "red")
        dev.off()
         
        pdf(file.path(results.dir, paste0("Transcriptional_Pressure_Distribution_", tissue.names[tx], ".pdf")), width = 10, height = 5)
        #bin transcriptional pressure so we can see all of them.
        bins <- segment_region(min(transcript.pressure), max(transcript.pressure), 100, "ends")
        binned.pressure <- apply(transcript.pressure, 2, function(x) hist(x, plot = FALSE, breaks = bins))
        bin.count <- sapply(binned.pressure, function(x) x$count)
        ordered.count <- bin.count[,rev(mean.order)]

        layout(matrix(c(1,2), ncol = 1), heights = c(0.6, 1))
        par(mar = c(0,4,2,4))
        barplot(colMeans(transcript.pressure[,mean.order]), names = NA, 
            ylab = "Transcriptional Pressure")
        par(mar = c(2,4,0,4))
        imageWithText(log(ordered.count+1), show.text = FALSE, 
            use.pheatmap.colors = TRUE, col.names = NULL)
        mtext("Transcript Counts", side = 1, outer = TRUE, line = -2.5)
        mtext("Transcriptional Pressure", side = 2, -1.5)
        dev.off()


        pdf(file.path(results.dir, paste0("Transcriptional_Pressure_v_Trait_PC", tissue.names[tx], ".pdf")), width = 5, height = 5)
        common.ind <- intersect(rownames(sub.pheno), colnames(transcript.pressure))
        plot.with.model(ind.score[common.ind], trait.pc[common.ind,1], 
            xlab = "Transcriptionally Predicted Phenotype", 
            ylab = "First PC of Trait Matrix")
        dev.off()

        #get enrichment terms for all negatively loaded transcripts across 
        #individuals
        ind.down.enrichment.file <- file.path(results.dir, 
            paste0("Individual_Enrichment_Down_", tissue.names[[tx]], ".RDS"))
        if(!file.exists(ind.down.enrichment.file)){
            ind.down.enrich <- apply(transcript.pressure, 2, 
                function(x) gost(rownames(transcript.pressure)[order(x)[1:enrichment.num]], 
                organism = "mmusculus"))
            saveRDS(ind.down.enrich, ind.down.enrichment.file)
        }else{
            ind.down.enrich <- readRDS(ind.down.enrichment.file)
        }

        ind.up.enrichment.file <- file.path(results.dir, 
            paste0("Individual_Enrichment_Up_", tissue.names[tx], ".RDS"))
        if(!file.exists(ind.up.enrichment.file)){
            ind.up.enrich <- apply(transcript.pressure, 2, 
                function(x) gost(rownames(transcript.pressure)[order(x, decreasing = TRUE)[1:enrichment.num]], 
                organism = "mmusculus"))
            saveRDS(ind.up.enrich, ind.up.enrichment.file)
        }else{
            ind.up.enrich <- readRDS(ind.up.enrichment.file)
        }

        clustered_down_enrich <- subset_enrichment(ind.down.enrich, 
            max.term.size = 5000, max.char = 100, sig.val = 0.01)

        clustered_up_enrich <- subset_enrichment(ind.up.enrich, 
            max.term.size = 5000, max.char = 100, enrich.sig.thresh = 1e3, 
            sig.val = 0.01)

        all_enrich <- rbind(clustered_up_enrich, clustered_down_enrich)

        pdf(file.path(results.dir, paste0("Clustered_Enrichment_", 
            tissue.names[tx], ".pdf")), width = 18, height = 10)
            
            left.mar = 20
            ordered.names <- colnames(transcript.pressure)[mean.order]

            #up enrichment ordered by score
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,0))
            barplot(ind.score[mean.order], names = NA, ylab = "Predicted Score",
                main = "Up Enrichment")
            par(mar = c(0,left.mar,0,0))
            imageWithText(clustered_up_enrich[,ordered.names], 
                col.names = NULL, show.text = FALSE, use.pheatmap.colors = TRUE,
                row.text.cex = 0.7)
            
            #up enrichment ordered by enrichment
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,0))
            barplot(ind.score[colnames(clustered_up_enrich)], names = NA, 
                ylab = "Predicted Score",main = "Up Enrichment")
            par(mar = c(0,left.mar,0,0))
            imageWithText(clustered_up_enrich, 
                use.pheatmap.colors = TRUE, show.text = FALSE, col.names = NULL,
                row.text.cex = 0.7)

            #down enrichment ordered by score
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,2))
            barplot(ind.score[mean.order], names = NA, ylab = "Predicted Score",
                main = "Down Enrichment")
            par(mar = c(0,left.mar,0,2))
            imageWithText(clustered_down_enrich[, ordered.names], 
                use.pheatmap.colors = TRUE, show.text = FALSE, col.names = NULL,
                row.text.cex = 0.7)
            
            #down enrichment ordered by enrichment
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,2))
            barplot(ind.score[colnames(clustered_down_enrich)], 
                names = NA, ylab = "Predicted Score", main = "Down Enrichment")
            par(mar = c(0,left.mar,0,2))
            imageWithText(clustered_down_enrich, 
                use.pheatmap.colors = TRUE, show.text = FALSE, col.names = NULL,
                row.text.cex = 0.7)

            #all enrichment ordered by score
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,2))
            barplot(ind.score[mean.order], names = NA, ylab = "Predicted Score",
                main = "All Enrichment")
            par(mar = c(0,left.mar,0,2))
            imageWithText(all_enrich[,ordered.names], 
                use.pheatmap.colors = TRUE, show.text = FALSE, col.names = NULL,
                row.text.cex = 0.7)
            plot.dim <- par("usr")
            plot.height <- plot.dim[4]
            line.height <- plot.height*nrow(clustered_down_enrich)/nrow(all_enrich)-1
            abline(h = line.height)

            #down enrichment ordered by enrichment
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,left.mar,2,2))
            barplot(ind.score[colnames(all_enrich)], names = NA, 
                ylab = "Predicted Score", main = "All Enrichment")
            par(mar = c(0,left.mar,0,2))
            imageWithText(all_enrich, use.pheatmap.colors = TRUE, 
                show.text = FALSE, col.names = NULL, row.text.cex = 0.7)
            abline(h = line.height)

        dev.off()

        pdf("~/Desktop/test.pdf", width = 15, height = 15)
        pheatmap(cor(t(all_enrich)))
        dev.off()

        #looking at large-effect transcripts
        large.effect <- apply(transcript.pressure, 2, function(x) which(abs(x) > large.effect.size))
        all.large <- unlist(large.effect)
        u_large <- unique(all.large)
        large.ind <- sapply(u_large, function(x) which(all.large == x))
        num.ind <- sapply(large.ind, length)

        pdf(file.path(results.dir, paste0("Large_Effect_Transcript_Decomp", tissue.names[tx], ".pdf")), width = 10, height = 5)
        large.mat <- scaled.expr[[tx]][,u_large]
        par(mfrow = c(1,2))
        pop.pressure.transcript.col <- colors.from.values(pop.pressure[[tx]], 
            use.pheatmap.colors = TRUE)
        individual.pheno.score <- colors.from.values(ind.score, 
            use.pheatmap.colors = TRUE)
        plot.decomp(t(large.mat), cols = pop.pressure.transcript.col[u_large], 
            main = "Large-Effect Transcript Decomposition\nby Transcript")
        plot.decomp(large.mat, cols = individual.pheno.score, 
            main = "Large-Effect Transcript Decomposition\nby Individual")
        dev.off()

    }

    #cat(names(common.large.effect.genes[[1]]), sep = "\n")
}
```

## Loadings vs. LOD {.tabset .tabset-fade .tabset-pills}

What is the maximum eQTL LOD score for transcripts compared with 
their loading? The following plots show the loading of each 
transript vs. its maximum LOD score. We still see a negative
relationship between loading and LOD score.

```{r to_label}
num.label = 30 #the number of top genes to label in the plots below
```

The transcripts are colored by their population level 
transcriptional pressure. The `r num.label` genes with
the largest transcriptional pressure magnitudes are labeled.
These transcripts are along the pareto front of the distribution.

The plots are saved as pdfs called LOD_vs_Loading_tissue_name
so that the gene names are searchable and highlightable.

```{r eqtl_plot, eval = FALSE}
for(tx in 1:length(tissue.names)){
    eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive
    lod.col <- colors.from.values(log10(log10(eqtl.table$lod)), 
        light.dark = "d", grad.dir = "high", 
        custom.colors = c("#9ecae1", "#6baed6", "#084594", "#000000"))
    split.pos <- strsplit(eqtl.table$marker.id, "_")
    eqtl.chr <- sapply(split.pos, function(x) x[1])
    eqtl.pos <- sapply(split.pos, function(x) x[2])
    eqtl.mat <- cbind(eqtl.table$gene.id, eqtl.chr, as.numeric(eqtl.pos)/1e6, eqtl.table$lod)
    colnames(eqtl.mat) <- c("ensembl.id", "chr", "pos", "lod")
    pos.table <- cbind(gene.table[,1], gene.table[,"chr"], gene.table[,"middle"])
    pdf(file.path(results.dir, paste0("eqtl_", tissue.names[tx], ".pdf")))
    plot.cistrans.table(eqtl.mat, pos.table, map = map, col = lod.col, cex = 0.4)
    dev.off()
}

```

```{r lod_v_loading}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "\n")
        eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive

        gene.id <- gene.table[match(rownames(transcript_loadings[[tx]]), gene.table[,"symbol"]),1]
        gene.lod <- lapply(gene.id, function(x) eqtl.table$lod[which(eqtl.table$gene.id == x)])
        max.lod <- sapply(gene.lod, function(x) if(length(x) > 0){max(x)}else{3})
        pressure.col <- colors.from.values(pop.pressure[[tx]][gene.id], use.pheatmap.colors = TRUE)
        #pdf("~/Desktop/test.pdf")
        #plot in the order of population-level transcriptomic pressure,
        #so we can see the outliers more easily
        pressure.order <- order(abs(pop.pressure[[tx]][gene.id]), decreasing = FALSE, na.last = FALSE)
        xV <- max.lod[pressure.order] 
        yV <- transcript_loadings[[tx]][,1][pressure.order]
        
        pdf(file.path(results.dir, paste("LOD_vs_Loading_", tissue.names[tx], ".pdf")), width = 10, height = 8)
        layout(matrix(c(1,1,2,3), ncol = 2, byrow = FALSE), widths = c(1, 0.5))
        par(mar = c(4,4,4,0))
        plot(xV, yV, xlab = "Maximum LOD", ylab = "Loading", 
            main = tissue.names[tx], col = pressure.col[pressure.order], 
            pch = 16, cex = 0.5)
        text(tail(xV, num.label), tail(yV, num.label), 
            labels = names(tail(yV, num.label)), pos = 4, cex = 0.7)
        abline(h = 0)  
        top.genes <- names(tail(yV, num.label))
        gene.pressure <- tail(pop.pressure[[tx]][gene.id][pressure.order], num.label)
        pos.idx <- which(gene.pressure > 0)
        pos.order <- order(gene.pressure[pos.idx], decreasing = TRUE)
        pos.par <- words_to_paragraph(top.genes[pos.idx[pos.order]], line.len = 5)
        par(mar = c(0,0,0,0))
        plot.text(paste("Positive Pressure Genes", pos.par, sep = "\n\n"))
        
        neg.idx <- which(gene.pressure < 0)
        neg.order <- order(gene.pressure[neg.idx], decreasing = FALSE)
        neg.par <- words_to_paragraph(top.genes[neg.idx[neg.order]], line.len = 5)
        par(mar = c(0,0,0,0))
        plot.text(paste("Negative Pressure Genes", neg.par, sep = "\n\n"))
        dev.off()
    }
}
```

## Prediction of inbred phenotypes {.tabset .tabset-fade .tabset-pills}

Can we use allele effects across all transcripts to predict
where an inbred mouse will fall in phenotype space? And can 
we further predict the effect that swapping in an allele from
another mouse will have on the phenotype?

caveat: Any predictions will only incorporate local effects, 
and will ignore kinship.

First we collect the allele effects for all transcripts with
eQTL. For now we will only use the allele effects in the eQTL
browser. This only includes transcripts with eQTL LOD scores
above 6. Eventually we may want to expand to all transcripts.


```{r inbred_prediction}
if(mediation.text == "complete_mediation"){
    inbred.effects.file <- file.path(results.dir, "Inbred_Effects.RDS")

    if(!file.exists(inbred.effects.file) || delete_previous){
        tissue.inbred.effects <- vector(mode = "list", length = length(tissue.names))
        names(tissue.inbred.effects) <- tissue.names
        for(tx in 1:length(tissue.names)){
            t.loadings <- transcript_loadings[[tx]]
            t.id <- gene.table[match(rownames(t.loadings), gene.table[,"symbol"]),1]
            eqtl.table <- get(data.set.names[[tx]])$lod.peaks$additive
            u_transcripts <- unique(eqtl.table$gene.id)
            inbred.effects <- matrix(NA, nrow = length(u_transcripts), ncol = 8)
            colnames(inbred.effects) <- names(CCcolors)
            rownames(inbred.effects) <- u_transcripts
            for(tr in 1:length(u_transcripts)){
                if(is.interactive){report.progress(tr, length(u_transcripts))}
                tr.idx <- which(eqtl.table$gene.id == u_transcripts[tr])
                tr.alleles <- eqtl.table[tr.idx,LETTERS[1:8]]
                tr.loading <- t.loadings[which(t.id == u_transcripts[tr])]
                tr.effects <- colMeans(tr.alleles*tr.loading)
                inbred.effects[tr,] <- tr.effects
            }
            tissue.inbred.effects[[tx]] <- inbred.effects
        }
        saveRDS(tissue.inbred.effects, inbred.effects.file)
    }else{
        tissue.inbred.effects <- readRDS(inbred.effects.file)
    }
}
```

The following plots show the predicted phenotype for each inbred
strain based on their collective transcriptional pressure.

```{r plot_predictions, results = "asis"}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "\n")
        inbred.means <- colMeans(tissue.inbred.effects[[tx]], na.rm = TRUE)
        mean.order <- order(inbred.means)
        barplot(inbred.means[mean.order], col = CCcolors[mean.order], main = tissue.names[tx])
        cat("\n\n")
    }
}
```

## Overall Effects

The effects overall are interesting, if a little confusing. 
The following plot shows that we predict the order of the 
three bears using this method. This shows the overall
phenotype merged across all tissues for the three bear
strains.

```{r overall_effects}
if(mediation.text == "complete_mediation"){
    three.bears <- c("CAST", "B6", "NZO")
    overall.strain.effect <- sapply(tissue.inbred.effects, function(x) colMeans(x, na.rm = TRUE))
    barplot(rowMeans(overall.strain.effect)[three.bears], 
        col = CCcolors[three.bears], ylab = "Phenotype")
}
```

Looking across all strains shows an interesting pattern.
NZO is predicted to be the outlier on the high end. 
PWK is predicted to be the outlier on the low end, but 
I'm not sure this is right. I think CAST is the most
resistant to these diet-induced traits. We have to 
remember, though, that our trait is a composite
trait, not any individual trait. 
[Mitok et al. (2017)](https://doi.org/10.1074/jbc.RA117.001102).
showed that CAST, PWK, and WSB had the least weight gain
on an HF diet, while NZO had the greatest gain, followed
by NOD and then B6. Glucose levels were not distinguishable
by strain. CAST had the lowest insulin levels across both 
sexes, while NZO levels were highest only in females. 
A/J had the second lowest insulin levels, and NOD had the
second highest. NZO males really lost their islets, but 
the NZO females retained theirs. The picture is complex
and depends on sex and other factors. 

Mitok et al. found that PWK and CAST mice have elevated
levels of tyrosine hydroxylase (Th) in their islets, 
which causes a blunted insulin response. Th is used in
the first step in catecholamine synthesis. Increased
Th leads to increased dopamine production and blunted
insulin secretion.


```{r overall_strains}
if(mediation.text == "complete_mediation"){
    effect.order <- order(rowMeans(overall.strain.effect))
    barplot(rowMeans(overall.strain.effect)[effect.order], 
        col = CCcolors[effect.order], ylab = "Phenotype")
}
```

If we look at breakout of effects by tissue in the three bears, it looks
as if the tissue that leads to the most variance in phenotype is the 
adipose tissue. Its transcription pattern pushes the NZO way up in 
phenotype space, and pushes the other two down relative to the overall
mean. 

For NZO, the adipose and liver contribute most to the high phenotype
levels. For CAST, its adipose and islet transcriptomes both help 
it be resistant. And for B6, the adipose transcriptome is the primary
source of resistance to diet-induced obesity and insulin resistance.

```{r tissue_effects}
if(mediation.text == "complete_mediation"){
    pheatmap(overall.strain.effect[rev(three.bears),], cluster_rows = FALSE)
}
```

If we look at all strains, the pattern breaks down a bit. We predict
that PWK will be more resistant than CAST, but I think CAST is actually
the more resistant strain.

Also, NOD has a big positive effect from the adipose transcriptome,
In Mitok et al, NOD was susceptible to diet-induced obesity, so this
does make sense. NOD also has the largest contribution from islets 
across all the strains, which we expect, since this is a diabetes 
model.

```{r all_strains, fig.width = 5, fig.height = 5}
if(mediation.text == "complete_mediation"){
    pheatmap(overall.strain.effect[rev(effect.order),], cluster_rows = FALSE)
}
```

## In silico complementation 

Can we predict the effect of a given allele swap into B6?
Since we can't do all possible allele swaps among strains, 
we will use B6 as the reference, since this is the preferred
model and best for CRISPR.

To further reduce the combinations we look at, we will only
consider the allele swap that is likely to have the biggest
effect. That is, the one with the largest difference in 
effect from B6.

To perform a swap, we simply replace the transcript effect 
calculated for B6 with the transcript effect calculated for
the strain with the maximum difference to B6. This does igore
kinship, and so we should do this swap only with transcript
effects estimated from local effects.


```{r allele_swaps, eval = FALSE}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        inbred.effects <- tissue.inbred.effects[[tx]]
        gene.names <- gene.table[match(rownames(inbred.effects), gene.table[,1]),"symbol"]
        b6.allele.pheno <- inbred.effects[,"B6",drop=FALSE]
        b6.start.pheno <- mean(b6.allele.pheno, na.rm = TRUE)
        num.alleles <- length(which(!is.na(b6.allele.pheno)))
        
        max.diff <- lapply(1:nrow(inbred.effects), 
            function(x) which.max(abs(inbred.effects[x,2]-inbred.effects[x,])))
        b6.swap.pheno <- lapply(1:length(max.diff), 
            function(x) b6.start.pheno-(b6.allele.pheno[x,1]/num.alleles)+(inbred.effects[x,max.diff[[x]]]/num.alleles))
        vals.used <- which(sapply(b6.swap.pheno, length) == 1)
        final.table <- cbind(unlist(b6.swap.pheno), unlist(max.diff)) 
        colnames(final.table) <- c("B6_swap_pheno", "allele")
        rownames(final.table) <- rownames(inbred.effects)[vals.used]

        b6.diff.pheno <- b6.start.pheno - final.table[,1]

        trans.table <- gene.table[match(rownames(final.table), gene.table[,1]),]
        u_chr <- unique(trans.table[,"chr"])
        ylim = c(min(b6.diff.pheno), max(b6.diff.pheno))
        layout(matrix(1:20, nrow = 1))
        par(mar = c(2,0,2,0))
        for(ch in c(1:19, "X")){
            ch.locale <- which(trans.table[,"chr"] == ch)
            plot(as.numeric(trans.table[ch.locale,"start"]), b6.diff.pheno[ch.locale], 
                type = "h", axes = FALSE, ylim = ylim, col = CCcolors[final.table[ch.locale,2]])
            mtext(side = 1, ch)
            abline(h = 0, col = "red")
            #axis(1)
        }
    }
}

```

## Allele effects by chromosome {.tabset .tabset-fade .tabset-pills}

The following plots show the predicted transcriptomic pressure by 
founder allele for every transcript. The effects are shown on the
genome at the position of the encoding gene. Positive effects
exacerbate the overall phenotype, and negative effects ameliorate
the overall phenotype. The color of the line indicates the founder
of the allele. Transcripts with effects greater than 0.5 are labeled.

```{r effects_by_chr, results = "asis", fig.width = 10, fig.height = 6}
if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")
        inbred.effects <- tissue.inbred.effects[[tx]]
        ylim <- c(min(inbred.effects, na.rm = TRUE), max(inbred.effects, na.rm = TRUE))
        inbred.gene.table <- gene.table[match(rownames(inbred.effects), gene.table[,1]),]
        for(ch in c(1:19, "X")){
            cat("####", ch, "\n")
            ch.locale <- which(inbred.gene.table[,"chr"] == ch)
            xlim <- c(min(as.numeric(inbred.gene.table[ch.locale,"start"])), max(as.numeric(inbred.gene.table[ch.locale,"start"])))
            plot.new()
            plot.window(xlim = xlim, ylim = ylim)
            for(a in 1:ncol(inbred.effects)){
                start.order <- order(as.numeric(inbred.gene.table[ch.locale,"start"]), decreasing = FALSE)
                points(as.numeric(inbred.gene.table[ch.locale[start.order],"start"]), 
                    inbred.effects[ch.locale[start.order],a], col = CCcolors[a], type = "h")
            }
            axis(1);axis(2)
            large.effects <- which(abs(inbred.effects[ch.locale,]) > 0.5, arr.ind = TRUE)
            if(nrow(large.effects) > 0){
                for(g in 1:nrow(large.effects)){
                    gene.row <- ch.locale[large.effects[g,1]]
                    max.effect <- which.max(abs(inbred.effects[gene.row,]))
                    text(as.numeric(inbred.gene.table[gene.row,"start"]), inbred.effects[gene.row,max.effect], 
                        labels = inbred.gene.table[gene.row,"symbol"], col = CCcolors[max.effect])
                }
            }
            mtext(paste("Chr", ch), side = 3, line = 2.5)
            cat("\n\n")
        }
        cat("\n\n")
    }
}

```