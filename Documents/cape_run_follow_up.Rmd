---
title: "Follow up for cape with transcripts"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

The pupose of this workflow is to explore the results of a cape run 
that uses expression values instead of genotypes.

```{r set_exp}
library("here")
exp.name = "all_gene_int"
data.path <- here("results", exp.name)
```

```{r load_code}
code.dir <- list.files(here("code"), full.names = TRUE)
for(i in 1:length(code.dir)){
    all.fun <- list.files(code.dir[i], full.names = TRUE, pattern = ".R")
    for(j in 1:length(all.fun)){
        source(all.fun[j])    
    }
}
```

```{r load_libraries}
needed.packages <- c("cape", "pheatmap", "gprofiler2", "cluster")
load_libraries(needed.packages)
#cape.fun <- list.files("~/Documents/git_repositories/cape/R", full.names = TRUE, pattern = ".R")
#for(i in 1:length(cape.fun)){source(cape.fun[i])}
```


```{r load_results}
data.obj <- readRDS(file.path(data.path, "cross.RData"))

all.var <- ls()
data.loaded <- as.logical(length(which(all.var == "dataset.clinical.phenotypes")))
if(!data.loaded){
  islets <- load(here("results", "Attie_DO378_eQTL_viewer_v6.Rdata"))
  }
```

```{r wgcna_modules}
gene.info <- dataset.islet.rnaseq$annots
```

Make an adjacency matrix and network from the cape interactions.


```{r make_net_and_adj, eval = FALSE}

var.inf <- plotVariantInfluences(final.cross, show.marker.labels = TRUE,
standardize = FALSE, plot.all.vals = FALSE)
int.mat <- var.inf[,1:nrow(var.inf)] #get just the interactions (no main effects)
non.rep.col <- which(colnames(int.mat) != "")
non.rep.row <- which(rownames(int.mat) != "")
int.mat <- int.mat[non.rep.row,non.rep.col]

no.na.mat <- int.mat
no.na.mat[which(is.na(int.mat))] <- 0
#make the network
int.net <- graph_from_adjacency_matrix(abs(no.na.mat), weighted = TRUE, mode = "undirected")

```

## Modules {.tabset .tabset-fade .tabset-pills}

Which modules are represented in our final network?

```{r mod_overlap}
net.names <- gsub("_B", "", rownames(int.mat))
gene.locale <- match(net.names, gene.info[,"symbol"])
gene.mod <- gene.info[gene.locale, "module"]
barplot(sort(table(gene.mod)), las = 2, ylab = "Gene Count")
```

Most of the genes we picked for the cape analysis are in the brown module.
Below we see that genes in the same WGCNA module do tend to have similar
interaction patterns, though not always. 

They also seem to cluster within the modules based on their cape 
interaction patterns. For example, in the greenyellow module, some
of the genes are overall suppressors, some suppress clusters of 
genes, and three have enhancing patterns.

```{r mod_cape_interactions, results = "asis"}
u_mod <- unique(gene.mod)
mod.mats <- lapply(u_mod, function(x) int.mat[which(gene.mod == x),])
mod.genes <- list()
mod.gene.names <- c()
idx = 1
for(i in 1:length(mod.mats)){
  cape.mod <- mod.mats[[i]]
  if(class(cape.mod) == "matrix" && nrow(cape.mod) > 2){
    cat("\n### ", u_mod[i], "\n")
    pheatmap(cape.mod, cluster_rows = FALSE, cluster_cols = FALSE, 
    main = paste(u_mod[i], "Module"))
    mod.genes[[idx]] <- gsub("_B", "", rownames(cape.mod))
    idx = idx + 1
    mod.gene.names <- c(mod.gene.names, u_mod[i])
    cat("\n")
  }
}
names(mod.genes) <- mod.gene.names
```

## Module enrichment

The enrichments of these clusters is as follows.

```{r cape_mod_enrich}
mod.enrich <- lapply(mod.genes, function(x) gost(x, organism = "mmusculus", sources = "GO"))
plot.enrichment.group(mod.enrich)
```

## Clustering cape interactions 

What happens when we generate modules directly from the cape interactions?
We can cluster the genes based on the correlations between their interactions.
The following heatmap shows gene-gene correlations based on their interaction 
patterns

```{r cape_mod, fig.width = 5, fig.height = 5}
int.cor <- cor(no.na.mat)
pheatmap(int.cor)
```

The following plot shows the PC decomposition of the correlation matrix.
It looks as if we should be able to cluster this into three clusters.

```{r cor_deomp}
plot.decomp(int.cor)
```

We used `pam` from the package `cluster` to do kmeans clustering on the
matrix. The following plot shows the sillouhette plot for the three clusters.

```{r cluster_cor}
cluster.cols <- brewer.pal(12, "Set3")
k = 3
km <- pam(int.cor, k, diss = FALSE)
mem <- km$clustering
mem.f <- data.frame(as.factor(mem))
si <- silhouette(km)
plot(si, col = cluster.cols[1:k])
widths[[i]] <- summary(si)$clus.avg.widths
```

The following plot shows how these clusters map onto the decomposition
of the correlation matrix.

```{r cluster_pc}
plot.decomp(int.cor, cols = mem)
```

And the following plot shows how those clusters map onto the
original correlation matrix. The heatmap is ordered by cluster
membership.

```{r clust_heat}
pheatmap(int.cor[order(mem), order(mem)], cluster_rows = FALSE, cluster_cols = FALSE,
annotation_row = mem.f)
```

The following plot shows the GO term enrichment for the three clusters
identified by the cape interactions. They are not as richly enriched
as the WGCNA clusters.

```{r cape_clust_enrich}
cape.mod.genes <- lapply(unique(mem), function(x) gsub("_B", "", names(mem)[which(mem == x)]))
cape.enrich <- lapply(cape.mod.genes, function(x) gost(x, organism = "mmusculus", sources = "GO"))
names(cape.enrich) <- unique(mem)
plot.enrichment.group(cape.enrich)
```

## Overlap of CAPE modules and WGCNA modules

How do the cape modules overlap with the WGCNA modules?
The following two plots show the cape matrix with the vertices
colored first by the cape module membership, and then by WGCNA
membership. 

```{r full_net_mem}
cape.mod <- mem
u_cape.mod <- unique(cape.mod)
wgcna.mod <- gene.mod
u_wgcna.mod <- unique(wgcna.mod)

plot(int.net, layout = layout_nicely, vertex.size = 5, 
  main = "Nodes colored by CAPE modules", edge.arrow.size = 0.5,
  vertex.label.cex = 0.7, vertex.label.dist = 1, vertex.color = cape.mod)

plot(int.net, layout = layout_nicely, vertex.size = 5, 
  main = "Nodes colored by WGCNA module", edge.arrow.size = 0.5,
  vertex.label.cex = 0.7, vertex.label.dist = 1, vertex.color = wgcna.mod)
```

The following Jaccard matrix shows that cape module 1 maps mostly to
the brown WGCNA module, and cape module 3 maps mostly to the greenyellow
WGCNA module, with a little bit in darkred. Cape module 2 is split 
between the brown and yellow WGCNA modules. You can also see this in
the network plots above.


```{r jacc}
jaccard.mat <- matrix(NA, nrow = length(u_cape.mod), ncol = length(u_wgcna.mod))
rownames(jaccard.mat) <- u_cape.mod
colnames(jaccard.mat) <- u_wgcna.mod
for(i in 1:length(u_cape.mod)){
  for(j in 1:length(u_wgcna.mod)){
    jaccard.mat[i,j] <- jaccard.ind(which(cape.mod == u_cape.mod[i]), which(wgcna.mod == u_wgcna.mod[j]))
  }
}
pheatmap(jaccard.mat)
```

## Network comparison

The following plots show how the genes with the rest of the
genes tested. Module genes are indicated by blue dots.
Genes outside the module are gray.

```{r cape_mod_net}
for(i in 1:length(u_cape.mod)){
  mod.locale <- which(cape.mod == u_cape.mod[i])
  cape.mod.mat <- no.na.mat[mod.locale,,drop=FALSE]
  cape.weights <- cape.mod.mat[which(cape.mod.mat != 0)]
  cape.edges <- which(cape.mod.mat != 0, arr.ind = TRUE)
  cape.edges[,1] <- rownames(cape.mod.mat)[as.numeric(cape.edges[,1])]
  cape.edges[,2] <- colnames(cape.mod.mat)[as.numeric(cape.edges[,2])]
  mod.net <- graph_from_edgelist(cape.edges)
  vert.col <- rep("gray", vcount(mod.net))
  vert.col[which(V(mod.net)$name %in% names(mod.locale))] <- "lightblue"
  E(mod.net)$weight <- abs(cape.weights)
  plot(mod.net, layout = layout_nicely, vertex.size = 5, 
  main = paste("Module", u_cape.mod[i]), edge.arrow.size = 0.5,
  vertex.label.cex = 0.7, vertex.label.dist = 1, vertex.color = vert.col)
}



```

```{r net_stats, eval = FALSE}
u_comm <- unique(comm)
enrich <- lapply(u_comm, function(x) gost(vertex.names[which(comm == x)], 
organism = "mmusculus", sources = "GO"))
names(enrich) <- u_comm
plot.enrichment.group(enrich)

bet <- betweenness(int.net)
deg <- degree(int.net)

par(mar = c(4,8,4,4))
quartz(height = 20, width = 7)
barplot(sort(deg), las = 2, horiz = TRUE, cex.names = 0.5)

plot(deg, bet, xlab = "Degree", ylab = "Betweenness", type = "n")
text(deg, bet, labels = gsub("_B", "", names(deg)))


all.enrich <- gost(vertex.names, organism = "mmusculus")
plot.enrichment.vis(all.enrich)

pheatmap(int.mat)

pheatmap(int.mat, cluster_cols = FALSE, cluster_rows = FALSE)

pdf("~/Desktop/int.pdf", width = 10, height = 10)
pheatmap(int.mat, fontsize_row = 7, fontsize_col = 7)
dev.off()
```

```{r chr11, eval = FALSE}
t.thresh <- 5
data.obj <- readRDS(here("results", "all_gene_int", "cross.RData"))
single <- readRDS(here("results", "all_gene_int", "cross.singlescan.RData"))
t.stats <- single$singlescan.t.stats
#plot(abs(t.stats[,3,]));abline(h = t.thresh)
high.t <- which(abs(t.stats[,3,]) > t.thresh)
high.t.chr <- get.marker.chr(data.obj, names(high.t))
chr11.locale <- which(high.t.chr == 11)
chr11.markers <- high.t[chr11.locale]
chr11.pos <- get.marker.location(data.obj, names(chr11.markers))
plot(as.numeric(chr11.pos), abs(t.stats[high.t[chr11.locale],3,]),
xlab = "Genomic Position on Chr 11", ylab = "|t statistic| for ET3")
```